<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>redis | SUCKED BloG</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/logo.ico">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.35bcedcf.css" as="style"><link rel="preload" href="/assets/js/app.42575a28.js" as="script"><link rel="preload" href="/assets/js/2.0d7d09b8.js" as="script"><link rel="preload" href="/assets/js/41.3f4581d8.js" as="script"><link rel="prefetch" href="/assets/js/10.1a30ebe5.js"><link rel="prefetch" href="/assets/js/100.022f696a.js"><link rel="prefetch" href="/assets/js/101.06eb0acb.js"><link rel="prefetch" href="/assets/js/102.e944c220.js"><link rel="prefetch" href="/assets/js/103.45b9da9a.js"><link rel="prefetch" href="/assets/js/104.cf53f5d1.js"><link rel="prefetch" href="/assets/js/105.200d7fe5.js"><link rel="prefetch" href="/assets/js/106.a0cc3502.js"><link rel="prefetch" href="/assets/js/107.4a71d17e.js"><link rel="prefetch" href="/assets/js/108.d7a39a75.js"><link rel="prefetch" href="/assets/js/109.35619cf9.js"><link rel="prefetch" href="/assets/js/11.f78ae8b3.js"><link rel="prefetch" href="/assets/js/110.f667d72e.js"><link rel="prefetch" href="/assets/js/111.de83ce6f.js"><link rel="prefetch" href="/assets/js/112.417d40bf.js"><link rel="prefetch" href="/assets/js/113.0f26c1ca.js"><link rel="prefetch" href="/assets/js/114.c7014acb.js"><link rel="prefetch" href="/assets/js/115.b502c0f1.js"><link rel="prefetch" href="/assets/js/116.10fb230e.js"><link rel="prefetch" href="/assets/js/117.f7cb9e2a.js"><link rel="prefetch" href="/assets/js/118.978d3075.js"><link rel="prefetch" href="/assets/js/119.09272191.js"><link rel="prefetch" href="/assets/js/12.140aa2af.js"><link rel="prefetch" href="/assets/js/120.32b5dbd7.js"><link rel="prefetch" href="/assets/js/121.8d618bbb.js"><link rel="prefetch" href="/assets/js/122.dcd4190d.js"><link rel="prefetch" href="/assets/js/123.2ee061d1.js"><link rel="prefetch" href="/assets/js/124.5a3760a7.js"><link rel="prefetch" href="/assets/js/125.a874a4bc.js"><link rel="prefetch" href="/assets/js/126.c6c6b7e6.js"><link rel="prefetch" href="/assets/js/127.38c35051.js"><link rel="prefetch" href="/assets/js/128.8d775ac8.js"><link rel="prefetch" href="/assets/js/129.6100ddb1.js"><link rel="prefetch" href="/assets/js/13.b2a6e590.js"><link rel="prefetch" href="/assets/js/130.9a83da2a.js"><link rel="prefetch" href="/assets/js/131.22de7670.js"><link rel="prefetch" href="/assets/js/132.f88798bf.js"><link rel="prefetch" href="/assets/js/133.925bbfed.js"><link rel="prefetch" href="/assets/js/134.481fad71.js"><link rel="prefetch" href="/assets/js/135.c3efb09b.js"><link rel="prefetch" href="/assets/js/136.758c447a.js"><link rel="prefetch" href="/assets/js/137.dcde1032.js"><link rel="prefetch" href="/assets/js/138.616a346b.js"><link rel="prefetch" href="/assets/js/139.b58dd07f.js"><link rel="prefetch" href="/assets/js/14.15374560.js"><link rel="prefetch" href="/assets/js/140.62b4c7ea.js"><link rel="prefetch" href="/assets/js/15.ffd155fa.js"><link rel="prefetch" href="/assets/js/16.feb1b022.js"><link rel="prefetch" href="/assets/js/17.6d491eb6.js"><link rel="prefetch" href="/assets/js/18.03ddaa95.js"><link rel="prefetch" href="/assets/js/19.021bbcc8.js"><link rel="prefetch" href="/assets/js/20.8aa708b0.js"><link rel="prefetch" href="/assets/js/21.59d7a21e.js"><link rel="prefetch" href="/assets/js/22.21597439.js"><link rel="prefetch" href="/assets/js/23.77303f0b.js"><link rel="prefetch" href="/assets/js/24.0789ed5b.js"><link rel="prefetch" href="/assets/js/25.244a12a8.js"><link rel="prefetch" href="/assets/js/26.a6ee95e4.js"><link rel="prefetch" href="/assets/js/27.9e0f0e9d.js"><link rel="prefetch" href="/assets/js/28.189031c5.js"><link rel="prefetch" href="/assets/js/29.b3100d33.js"><link rel="prefetch" href="/assets/js/3.2a5d4cd5.js"><link rel="prefetch" href="/assets/js/30.fe8fe8c0.js"><link rel="prefetch" href="/assets/js/31.86fec3f7.js"><link rel="prefetch" href="/assets/js/32.24cac061.js"><link rel="prefetch" href="/assets/js/33.f1db2ed0.js"><link rel="prefetch" href="/assets/js/34.c220692f.js"><link rel="prefetch" href="/assets/js/35.9e7b4779.js"><link rel="prefetch" href="/assets/js/36.0cb1d1bc.js"><link rel="prefetch" href="/assets/js/37.7d1fcf79.js"><link rel="prefetch" href="/assets/js/38.bc9bc4b3.js"><link rel="prefetch" href="/assets/js/39.10801a2a.js"><link rel="prefetch" href="/assets/js/4.b4d9a5aa.js"><link rel="prefetch" href="/assets/js/40.c980543d.js"><link rel="prefetch" href="/assets/js/42.60b85cdf.js"><link rel="prefetch" href="/assets/js/43.1338528d.js"><link rel="prefetch" href="/assets/js/44.786fc51f.js"><link rel="prefetch" href="/assets/js/45.d65f6744.js"><link rel="prefetch" href="/assets/js/46.543c2b26.js"><link rel="prefetch" href="/assets/js/47.59f19ed2.js"><link rel="prefetch" href="/assets/js/48.60de6b25.js"><link rel="prefetch" href="/assets/js/49.f3df62ef.js"><link rel="prefetch" href="/assets/js/5.013522c1.js"><link rel="prefetch" href="/assets/js/50.fd9871d6.js"><link rel="prefetch" href="/assets/js/51.1fb1863e.js"><link rel="prefetch" href="/assets/js/52.c06ce3f3.js"><link rel="prefetch" href="/assets/js/53.a3d55203.js"><link rel="prefetch" href="/assets/js/54.89ac64bc.js"><link rel="prefetch" href="/assets/js/55.ccf38d1e.js"><link rel="prefetch" href="/assets/js/56.ffb8595b.js"><link rel="prefetch" href="/assets/js/57.5f1bd695.js"><link rel="prefetch" href="/assets/js/58.7463616d.js"><link rel="prefetch" href="/assets/js/59.ea4eb5dd.js"><link rel="prefetch" href="/assets/js/6.72ad7c85.js"><link rel="prefetch" href="/assets/js/60.a2add219.js"><link rel="prefetch" href="/assets/js/61.3eae0362.js"><link rel="prefetch" href="/assets/js/62.801d1658.js"><link rel="prefetch" href="/assets/js/63.b47a17bb.js"><link rel="prefetch" href="/assets/js/64.d5e2bdea.js"><link rel="prefetch" href="/assets/js/65.24d540f4.js"><link rel="prefetch" href="/assets/js/66.09a1ae52.js"><link rel="prefetch" href="/assets/js/67.75bd38e7.js"><link rel="prefetch" href="/assets/js/68.1fe6956e.js"><link rel="prefetch" href="/assets/js/69.d3306c2d.js"><link rel="prefetch" href="/assets/js/7.60760bb7.js"><link rel="prefetch" href="/assets/js/70.95aa4503.js"><link rel="prefetch" href="/assets/js/71.7065ebf0.js"><link rel="prefetch" href="/assets/js/72.55ae5081.js"><link rel="prefetch" href="/assets/js/73.c7624eee.js"><link rel="prefetch" href="/assets/js/74.63bcc7bd.js"><link rel="prefetch" href="/assets/js/75.e2731e20.js"><link rel="prefetch" href="/assets/js/76.1711af80.js"><link rel="prefetch" href="/assets/js/77.f1c4e2d3.js"><link rel="prefetch" href="/assets/js/78.900bc856.js"><link rel="prefetch" href="/assets/js/79.a1b8c47b.js"><link rel="prefetch" href="/assets/js/8.0c261cf2.js"><link rel="prefetch" href="/assets/js/80.7cf435bf.js"><link rel="prefetch" href="/assets/js/81.fa33b2af.js"><link rel="prefetch" href="/assets/js/82.cdabd386.js"><link rel="prefetch" href="/assets/js/83.879fc50c.js"><link rel="prefetch" href="/assets/js/84.7e460788.js"><link rel="prefetch" href="/assets/js/85.339356d5.js"><link rel="prefetch" href="/assets/js/86.d526418c.js"><link rel="prefetch" href="/assets/js/87.12877e38.js"><link rel="prefetch" href="/assets/js/88.d5a7d193.js"><link rel="prefetch" href="/assets/js/89.2f4a62c2.js"><link rel="prefetch" href="/assets/js/9.50eda380.js"><link rel="prefetch" href="/assets/js/90.6d83f5bf.js"><link rel="prefetch" href="/assets/js/91.f3364825.js"><link rel="prefetch" href="/assets/js/92.158fcc7a.js"><link rel="prefetch" href="/assets/js/93.0c4e5f88.js"><link rel="prefetch" href="/assets/js/94.c5725f80.js"><link rel="prefetch" href="/assets/js/95.dc61d501.js"><link rel="prefetch" href="/assets/js/96.3a598fc5.js"><link rel="prefetch" href="/assets/js/97.712aa8be.js"><link rel="prefetch" href="/assets/js/98.e757fe7a.js"><link rel="prefetch" href="/assets/js/99.1418024a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35bcedcf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">SUCKED BloG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/other/index.html" class="nav-link">
  index
</a></div><div class="nav-item"><a href="/question/index.html" class="nav-link">
  question
</a></div><div class="nav-item"><a href="/audition/index.html" class="nav-link">
  audition
</a></div><div class="nav-item"><a href="/point/index.html" class="nav-link">
  point
</a></div><div class="nav-item"><a href="/work/index.html" class="nav-link">
  work
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="url" class="dropdown-title"><span class="title">url</span> <span class="arrow down"></span></button> <button type="button" aria-label="url" class="mobile-dropdown-title"><span class="title">url</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/other/config.html" class="nav-link">
  其他
</a></li><li class="dropdown-item"><!----> <a href="https://git.code.tencent.com/u/nampy" target="_blank" rel="noopener noreferrer" class="nav-link external">
  腾讯工蜂
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/willwxt" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="http://nbcb.icu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  导航首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/other/index.html" class="nav-link">
  index
</a></div><div class="nav-item"><a href="/question/index.html" class="nav-link">
  question
</a></div><div class="nav-item"><a href="/audition/index.html" class="nav-link">
  audition
</a></div><div class="nav-item"><a href="/point/index.html" class="nav-link">
  point
</a></div><div class="nav-item"><a href="/work/index.html" class="nav-link">
  work
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="url" class="dropdown-title"><span class="title">url</span> <span class="arrow down"></span></button> <button type="button" aria-label="url" class="mobile-dropdown-title"><span class="title">url</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/other/config.html" class="nav-link">
  其他
</a></li><li class="dropdown-item"><!----> <a href="https://git.code.tencent.com/u/nampy" target="_blank" rel="noopener noreferrer" class="nav-link external">
  腾讯工蜂
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/willwxt" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="http://nbcb.icu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  导航首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>redis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/point/04cache/redis-main.html#_01-简单概述" class="sidebar-link">01. 简单概述</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/point/04cache/redis-main.html#_02-redis-api的理解和使用" class="sidebar-link">02. redis API的理解和使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#数据结构和内部编码" class="sidebar-link">数据结构和内部编码</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#字符串" class="sidebar-link">字符串</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#hash-哈希" class="sidebar-link">hash 哈希</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#list-列表" class="sidebar-link">list 列表</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#set-集合" class="sidebar-link">set 集合</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#zset排序集合" class="sidebar-link">zset排序集合</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#key管理" class="sidebar-link">key管理</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#数据库管理" class="sidebar-link">数据库管理</a></li></ul></li><li><a href="/point/04cache/redis-main.html#_03-其他功能" class="sidebar-link">03. 其他功能</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#pipeline" class="sidebar-link">Pipeline</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#事务与lua" class="sidebar-link">事务与Lua</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#bitmaps" class="sidebar-link">Bitmaps</a></li></ul></li><li><a href="/point/04cache/redis-main.html#_04-客户端" class="sidebar-link">04. 客户端</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#客户端管理" class="sidebar-link">客户端管理</a></li></ul></li><li><a href="/point/04cache/redis-main.html#_05-持久化" class="sidebar-link">05. 持久化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#rdb" class="sidebar-link">RDB</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#aof" class="sidebar-link">AOF</a></li></ul></li><li><a href="/point/04cache/redis-main.html#_06-复制" class="sidebar-link">06. 复制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#复制原理" class="sidebar-link">复制原理</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#问题解决" class="sidebar-link">问题解决</a></li></ul></li><li><a href="/point/04cache/redis-main.html#_07-redis阻塞" class="sidebar-link">07. redis阻塞</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/point/04cache/redis-main.html#_08-理解内存" class="sidebar-link">08. 理解内存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#内存优化" class="sidebar-link">内存优化</a></li></ul></li><li><a href="/point/04cache/redis-main.html#_09-哨兵" class="sidebar-link">09. 哨兵</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/point/04cache/redis-main.html#_10-集群-redis-cluster" class="sidebar-link">10. 集群 redis cluster</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#数据分布-分区" class="sidebar-link">数据分布/分区</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#搭建redis-cluster集群" class="sidebar-link">搭建redis cluster集群</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#gossip消息" class="sidebar-link">Gossip消息</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#集群伸缩" class="sidebar-link">集群伸缩</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#请求重定向" class="sidebar-link">请求重定向</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#故障转移-2" class="sidebar-link">故障转移</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#集群运维" class="sidebar-link">集群运维</a></li></ul></li><li><a href="/point/04cache/redis-main.html#_11-缓存设计" class="sidebar-link">11. 缓存设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#缓存更新策略" class="sidebar-link">缓存更新策略</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#缓存穿透优化" class="sidebar-link">缓存穿透优化</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#缓存雪崩优化" class="sidebar-link">缓存雪崩优化</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#热点key重建优化" class="sidebar-link">热点key重建优化</a></li></ul></li><li><a href="/point/04cache/redis-main.html#_12-其他" class="sidebar-link">12. 其他</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#补充" class="sidebar-link">补充</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-main.html#redis分布式锁" class="sidebar-link">Redis分布式锁</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="redis"><a href="#redis" class="header-anchor">#</a> redis</h1> <blockquote><p>目录结构参考 <a href="https://github.com/7-sevens/Developer-Books/tree/master/Redis" target="_blank" rel="noopener noreferrer">Redis开发与运维.pdf<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="/point/04cache/redis-structure/">redis多数据底层源码参考</a> 🎈 <a href="/point/04cache/redis-config-file/">redis配置文件</a></p></blockquote> <h2 id="_01-简单概述"><a href="#_01-简单概述" class="header-anchor">#</a> 01. 简单概述</h2> <p>概述: 一种基于键值对的NoSQL数据库, 支持如下特性: 多数据类型, 高读写性能, 支持快照和日志的持久化, 还有键过期, 发布订阅, 事务, Lua脚本等</p> <p>全称: Remote Dictionary Server</p> <h4 id="redis特性"><a href="#redis特性" class="header-anchor">#</a> redis特性</h4> <ul><li>内存数据库, 速度快: 单机10万/秒</li> <li>单线程架构: 避免了高并发多线程问题 (6.x引入多线程IO, worker还是单线程的)</li> <li>多数据类型: 字符串, 列表, 哈希, 集合, 有序集合; 字符串还能扩展为位图, 地理信息定位等</li> <li>键过期, 发布订阅, Lua脚本, 简单事务, Pipeline等功能</li> <li>持久化: RDB 和 AOF (4.x可混合使用)</li> <li>主从复制(Redis副本), 高可用(Sentinel), 分布式集群(Cluster)</li></ul> <h4 id="redis-vs-memcached"><a href="#redis-vs-memcached" class="header-anchor">#</a> redis vs memcached</h4> <ul><li>memcached中value只有一种类型string, redis多数据类型</li> <li>内存管理机制不同</li> <li>redis使用单线程worker, memcached可以多线程</li> <li>memcached没有原生支持分布式架构</li></ul> <h4 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h4> <ol><li>缓存: 通过合理的缓存设计减少数据库压力</li> <li>排行榜: 通过zset构建各种排行榜系统</li> <li>计数器: 对一些视频网站的浏览次数进行累计</li> <li>社交网络: 应对社交网站的高访问量: 点赞数, 推送, 共同好友/爱好(交集)</li> <li>消息队列: 满足一般的消息队列功能</li></ol> <p>建议: 根据数据规模和数据冷热等特性决定是否使用redis</p> <h2 id="_02-redis-api的理解和使用"><a href="#_02-redis-api的理解和使用" class="header-anchor">#</a> 02. redis API的理解和使用</h2> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>keys * <span class="token comment">#查看所有键</span>
dbsize <span class="token comment">#查看键总数</span>
exist key	<span class="token comment">#查询键是否存在</span>
del key<span class="token punctuation">..</span>	<span class="token comment">#删除键</span>
expire key seconds	<span class="token comment">#给键设置过期时间</span>
<span class="token builtin class-name">type</span> key	<span class="token comment">#键的数据结构类型</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="header-anchor">#</a> 数据结构和内部编码</h3> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">type</span> key	<span class="token comment">#返回的数据结构类型有这些(string, hash, list, set, zset)</span>
<span class="token comment">#但这些只是堆外的数据结果, 都有自己底层的内部编码实现(而且是多种实现)</span>
<span class="token comment">#redis会在合适的场景选择合适的内部编码</span>
object encoding key	<span class="token comment">#查看内部编码实现</span>
<span class="token comment">#例如</span>
<span class="token comment">#list数据结果包含了linkedlist和ziplist两种内部编码</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5waHAuY24vdXBsb2FkL2FydGljbGUvMDAwLzA1NC8wMjUvNDFhYWFkZWNhOThlMTQ2NDA5NDhiZGJhOGJjNGJhMTItMS5wbmc?x-oss-process=image/format,png" alt="内部编码"></p> <h4 id="单线程架构"><a href="#单线程架构" class="header-anchor">#</a> 单线程架构</h4> <p>概述: 命令到达redis会进入一个队列中, 然后逐个执行, 不存在多个命令被同时执行的情况</p> <ol><li>单线程模型</li> <li><strong>为什么单线程模型还能那么快</strong> <ol><li>纯内存访问</li> <li>非阻塞IO, 使用epoll的IO多路复用技术处理tcp连接/关闭, buffer读写</li> <li>单线程避免了线程切换, 高并发下锁问题</li> <li>redis6.0开始使用多线程io threads</li></ol></li> <li><strong>问题</strong>: 如果某个命令执行时间过长, 会造成其他命令阻塞</li></ol> <h4 id="io-threads"><a href="#io-threads" class="header-anchor">#</a> IO threads</h4> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment">#旧redis处理两条指令: 指令1,指令2</span>
读取IO1  计算1	   写IO1   读取IO2   计算2   写IO2

<span class="token comment">#IO THREADS	6.x 以后提供</span>
		计算1		计算2					worker
读取IO1			写IO1				io thread1
读取IO2					写IO2		io thread2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>不能保证先处理C1还是C2, 但如果是同一个客户端, 同一个IO中的读取顺序是可以保证的</p> <h3 id="字符串"><a href="#字符串" class="header-anchor">#</a> 字符串</h3> <p>概述: 最基础的数据结构;</p> <ul><li>key都是字符串类型, 其他的几种数据结构都是在字符串基础上构建的</li> <li>可以存储数值, 二进制, 但是最大不能超过512MB</li></ul> <h4 id="string基本操作api"><a href="#string基本操作api" class="header-anchor">#</a> string基本操作API</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#set and get</span>
<span class="token builtin class-name">set</span> key value <span class="token punctuation">[</span>ex seconds<span class="token punctuation">]</span> <span class="token punctuation">[</span>px millisenconds<span class="token punctuation">]</span> <span class="token punctuation">[</span>nx<span class="token operator">|</span>xx<span class="token punctuation">]</span>
<span class="token comment">#设置kv, 秒级/毫秒级超时时间, </span>
<span class="token comment">#键必须不存在NX(锁) / 必须存在XX(更新)</span>
get key	<span class="token comment">#查询</span>

<span class="token comment">#计数</span>
incr key	<span class="token comment">#对值做自增操作</span>

<span class="token comment">#不常用命令</span>
append key value	<span class="token comment">#追加值</span>
strlen key 	<span class="token comment">#字符串长度</span>
getset key value <span class="token comment">#设置并返回原值</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="string内部编码"><a href="#string内部编码" class="header-anchor">#</a> string内部编码</h4> <p>字符串类型的内部编码:</p> <ol><li>int: 8个字节的长整形</li> <li>embstr: 小于等于39个字节的字符串</li> <li>raw: 大于39个字节的字符串</li></ol> <h4 id="string典型使用场景"><a href="#string典型使用场景" class="header-anchor">#</a> string典型使用场景</h4> <h5 id="_1-缓存功能-加速读写-降低后端压力"><a href="#_1-缓存功能-加速读写-降低后端压力" class="header-anchor">#</a> 1. 缓存功能: 加速读写, 降低后端压力</h5> <p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5waHAuY24vdXBsb2FkL2FydGljbGUvMDAwLzA1NC8wMjUvNzJmMTQ3ZDAwZDIwNzUxZGFkNjk4OTg5ZTY2NmNiYzgtNS5wbmc?x-oss-process=image/format,png" alt="缓存"></p> <h5 id="_2-计数-将redis作为基础计数组件-再异步落到其他数据源"><a href="#_2-计数-将redis作为基础计数组件-再异步落到其他数据源" class="header-anchor">#</a> 2. 计数: 将redis作为基础计数组件, 再异步落到其他数据源</h5> <p>比如说秒杀, 将库存数量缓存到redis, 被秒杀到0后结束秒杀;</p> <p>点赞, 评论数</p> <h5 id="_3-共享session"><a href="#_3-共享session" class="header-anchor">#</a> 3. 共享session</h5> <p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5waHAuY24vdXBsb2FkL2FydGljbGUvMDAwLzA1NC8wMjUvNzJmMTQ3ZDAwZDIwNzUxZGFkNjk4OTg5ZTY2NmNiYzgtNi5wbmc?x-oss-process=image/format,png" alt="session"></p> <h5 id="_4-限流-通过incr和超时时间做"><a href="#_4-限流-通过incr和超时时间做" class="header-anchor">#</a> 4. 限流: 通过incr和超时时间做</h5> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">set</span> key <span class="token number">0</span> ex <span class="token number">60</span> nx <span class="token comment">#如果没有就设置为1</span>
incr key	<span class="token comment">#判断递增后的结果是否超限</span>
<span class="token comment">#超时时间还可以做限时优惠活动, 手机验证码...</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="合理设置键名"><a href="#合理设置键名" class="header-anchor">#</a> 合理设置键名</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>推荐使用如下规则, 保证足够区分度下控制key的长度越小越好
业务名/数据库名:对象名:id:[属性] 比如user:123:password
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="hash-哈希"><a href="#hash-哈希" class="header-anchor">#</a> hash 哈希</h3> <p>哈希, 字典, 关联数组</p> <h4 id="hash-基本操作api"><a href="#hash-基本操作api" class="header-anchor">#</a> hash 基本操作API</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>hset key field value	<span class="token comment">#增加</span>
hget key field			<span class="token comment">#查询</span>
hdel key field			<span class="token comment">#删除</span>
hlen key
hexist key field
hkeys key
hvals key
hgetall key			<span class="token comment">#获取所有kv对</span>
hincrby key field	<span class="token comment">#自增</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>注意: hgetall等命令如果元素个数较多可能阻塞redis</p> <h4 id="hash内部编码"><a href="#hash内部编码" class="header-anchor">#</a> hash内部编码</h4> <p>有两种:</p> <ol><li>ziplist(压缩列表):
<ul><li>当元素个数小于hash-max-ziplist-entries(512个)</li> <li>每个元素的值都小于hash-max-ziplist-value(64字节)</li> <li>ziplist使用更加紧凑的内存结构, 以节省空间</li></ul></li> <li>hashtable(哈希表):
<ul><li>超出ziplist的条件时会使用, 因为ziplist的读写效率在此时下降</li></ul></li></ol> <h4 id="hash使用场景"><a href="#hash使用场景" class="header-anchor">#</a> hash使用场景</h4> <ol><li><p>例如: 用户表, 根据用户id来保存对应用户的信息;</p></li> <li><p>聚集数据(多个地方的数据汇总,频繁访问,但是较少修改), 商品/用户的详情页</p></li> <li><p>避免redis的哈希表膨胀</p></li></ol> <p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5waHAuY24vdXBsb2FkL2FydGljbGUvMDAwLzA1NC8wMjUvM2ZlODYwNWQxMGQ4ZTc0MmIwYWUxYjU2YzExZWYzY2ItOS5wbmc?x-oss-process=image/format,png" alt="hash使用"></p> <h4 id="使用hash和使用格式化string的优劣"><a href="#使用hash和使用格式化string的优劣" class="header-anchor">#</a> 使用hash和使用格式化string的优劣</h4> <ul><li>哈希类型: 简单直观, 但是如果内部编码转换为hashtable, 会消耗较多内存</li> <li>序列化字符串类型: 简化编程, 提高内存利用率, 但是每次都需要全量读取, 还需要额外序列化开销</li></ul> <h3 id="list-列表"><a href="#list-列表" class="header-anchor">#</a> list 列表</h3> <p>存储有序元素(string), 是一种灵活的数据结构, 可以充当栈和队列, 阻塞队列</p> <ul><li>列表中元素是有序的, 可以通过索引下标获取某个元素或范围</li> <li>元素可重复</li></ul> <h4 id="list基本操作api"><a href="#list基本操作api" class="header-anchor">#</a> list基本操作api</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>rpush lpush linsert		<span class="token comment"># 添加</span>
lrange lindex llen		<span class="token comment"># 查询</span>
rpop lpop lrem ltrim	<span class="token comment"># 删除</span>
lset					<span class="token comment"># 修改</span>
blpop brpop				<span class="token comment"># 阻塞操作</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="list内部编码"><a href="#list内部编码" class="header-anchor">#</a> list内部编码</h4> <ol><li>ziplist: 压缩列表 (压缩+偏移量, 大大减少每个key存储空间, 但无法存储大量key)
<ul><li>元素个数小于 list-max-ziplist-entries (默认512个)</li> <li>每个元素值小于 list-max-ziplist-value (默认64字节)</li></ul></li> <li>linkedlist: 链表</li> <li>quicklist: Redis3.2开始提供的内部编码, 可简单的认为以ziplist作为节点的链表, 是对上述数据结构的优化 <a href="https://matt.sh/redis-quicklist" target="_blank" rel="noopener noreferrer">quicklist原理&amp;优势<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h4 id="list使用场景"><a href="#list使用场景" class="header-anchor">#</a> list使用场景</h4> <ol><li>消息队列: lpush+brpop生产消费者模型实现阻塞队列</li> <li>文章列表, 评论列表: 列表不但有序, 还支持按索引范围查找</li> <li>替代java一些容器 - JVM(服务)无状态 - 数据可靠</li></ol> <ul><li>lpush+lpop=Stack (栈)</li> <li>lpush+rpop=Queue (队列)</li> <li>lpsh+ltrim=Capped Collection (有限集合)</li> <li>lpush+brpop=Message Queue (消息队列)</li></ul> <h3 id="set-集合"><a href="#set-集合" class="header-anchor">#</a> set 集合</h3> <p>集合中不允许有重复元素, 并且集合中的元素是无序的</p> <h4 id="set基本操作api"><a href="#set基本操作api" class="header-anchor">#</a> set基本操作api</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 增删改查</span>
sadd 
srem 
scard 	<span class="token comment">#元素个数</span>
sismember	<span class="token comment">#contains</span>
srandmember	<span class="token comment">#随机元素</span>
spop		<span class="token comment">#随机弹出</span>
SADD k1 ooxx xxoo oxox xoxo oxxo xoox ooxx
SMEMBERS k1 <span class="token number">2</span>	<span class="token comment"># 随机返回大小为2的set</span>
SRANDMEMBER k1 <span class="token number">2</span>	<span class="token comment"># 随机返回大小为2的set, 如果超出set大小不补全</span>
SRANDMEMBER k1 -8	<span class="token comment"># 随机返回大小为8的set, 如果超出set大小补全</span>
<span class="token comment"># 集合操作</span>
sinterstore <span class="token comment">#将交集的结果保存</span>
SUNION k1 k2	<span class="token comment"># 并集</span>
SINTER k1 k2	<span class="token comment"># 交集</span>
SDIFF k1 k2		<span class="token comment"># 差集有方向</span>
<span class="token comment"># 场景: 共同好友(游戏...), 好友/游戏/商品推荐</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h4 id="set内部编码"><a href="#set内部编码" class="header-anchor">#</a> set内部编码</h4> <ol><li>intset: 整数集合
<ul><li>元素都是整数且个数小于 set-max-intset-entries (默认512个)</li></ul></li> <li>hashtable</li></ol> <h4 id="set使用场景"><a href="#set使用场景" class="header-anchor">#</a> set使用场景</h4> <ol><li>set的典型使用场景是标签(tag), 可以给用户贴标签, 进行分类/分析</li> <li>共同好友(游戏...), 好友/游戏/商品推荐</li> <li>抽奖, 验证码, 扑克牌游戏</li> <li>利用唯一性, 可以统计访问网站的所有独立 IP</li></ol> <h3 id="zset排序集合"><a href="#zset排序集合" class="header-anchor">#</a> zset排序集合</h3> <p>不能有重复member, 但是元素可以根据score进行排序</p> <p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5waHAuY24vdXBsb2FkL2FydGljbGUvMDAwLzA1NC8wMjUvMmUyZTU2MGFjMzM0MjIxNDAwNmU1NzA3MGY3MWQzY2MtMTYucG5n?x-oss-process=image/format,png" alt="zset"></p> <h4 id="zset基本操作api"><a href="#zset基本操作api" class="header-anchor">#</a> zset基本操作api</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#增删改查</span>
zadd	<span class="token comment">#增加操作复杂度提高至logN</span>
zcard
zscore
zrank	zrevrank	<span class="token comment">#排名</span>
zrange				<span class="token comment">#返回范围内的member</span>
zrangebyscore
ZADD k1 <span class="token number">22.5</span> apple <span class="token number">11</span> orange <span class="token number">33</span> banana	
ZRANGE k1 <span class="token number">0</span> -1 WITHSCORES
ZREVRANGE k1 <span class="token number">0</span> <span class="token number">1</span>	<span class="token comment"># 逆向, 注意正负索引</span>
ZRANGEBYSCORE k1 <span class="token number">10</span> <span class="token number">33</span>	<span class="token comment"># 分数区间</span>
<span class="token comment">#集合间操作, 参数较多, 设计分数的计算, 权重...</span>
zinterstore 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="zset内部编码"><a href="#zset内部编码" class="header-anchor">#</a> zset内部编码</h4> <ol><li>ziplist: 压缩列表
<ul><li>当有序集合元素小于 zset-max-ziplist-entries (默认128个)</li> <li>每个元素值小于 zset-max-ziplist-value (64字节)</li></ul></li> <li>skiplist: 跳跃表
<ul><li>链表, 每个节点拥有随机的层级, head头结点是满层的, 查询元素时从头开始向右下遍历</li> <li>插入元素的时候随机造层, 上层元素需要找到周围层的指针地址, 进行高层的指针修改</li></ul></li></ol> <h4 id="zset使用场景"><a href="#zset使用场景" class="header-anchor">#</a> zset使用场景</h4> <ol><li>zset典型使用场景是排行榜系统</li> <li>做权重队列, 重要任务先执行</li></ol> <h3 id="key管理"><a href="#key管理" class="header-anchor">#</a> key管理</h3> <h4 id="单key管理"><a href="#单key管理" class="header-anchor">#</a> 单key管理</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">rename</span> key newkey	<span class="token comment">#key重命名</span>
randomkey	<span class="token comment">#随机返回一个key</span>
expire key seconds	<span class="token comment">#key过期时间, 注意字符串类型设置值会去掉过期时间</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>迁移键: 例如把部分数据从生产redis迁移到测试redis</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>move key db	<span class="token comment">#redis内部数据库移动数据 (没啥用)</span>
<span class="token comment"># dump+restore可以实现在不同的Redis实例之间进行数据迁移</span>
dump key	<span class="token comment">#在源Redis上, dump命令会将键值序列化, 格式采用的是RDB格式</span>
restore key ttl value	<span class="token comment">#在目标Redis上复原</span>
migrate	<span class="token comment">#本质就是dump, restore, del三个命令进行组合, 不过是原子性的</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>遍历键:</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>key pattern	<span class="token comment">#支持格式匹配, 避免遍历大量key, 导致redis阻塞</span>
scan	<span class="token comment">#渐进式遍历, 游标, (分页?), 可能遍历到的不是当前快照</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="数据库管理"><a href="#数据库管理" class="header-anchor">#</a> 数据库管理</h3> <p>略</p> <h2 id="_03-其他功能"><a href="#_03-其他功能" class="header-anchor">#</a> 03. 其他功能</h2> <p>慢查询分析, Redis Shell, Pipeline(管道/流水线), 事务与Lua, Bitmaps, 发布订阅, HyperLogLog, GEO</p> <h4 id="慢查询分析"><a href="#慢查询分析" class="header-anchor">#</a> 慢查询分析</h4> <p>概述: 系统在命令执行前后计算执行时间, 将超过阈值的命令信息记录下来</p> <h4 id="redis-shell"><a href="#redis-shell" class="header-anchor">#</a> redis-shell</h4> <p>执行多次, 每隔几秒执行一次, 从标准输入读取数据, 集群, 鉴权, 从节点, rdb, 管道, bigkeys, eval执行Lua脚本, 检测网络延迟, stat统计信息, raw返回原始格式</p> <h4 id="redis-sever"><a href="#redis-sever" class="header-anchor">#</a> redis-sever</h4> <p>test-memory内存测试, benchmark性能测试</p> <h3 id="pipeline"><a href="#pipeline" class="header-anchor">#</a> Pipeline</h3> <p>redis的瓶颈之一在于网络往返延迟, pipeline将一组redis命令组装, 一次执行n条命令, 减少网络往返次数从而降低延迟; 该功能一般通过客户端软件实现</p> <h3 id="事务与lua"><a href="#事务与lua" class="header-anchor">#</a> 事务与Lua</h3> <p>redis提供简单的事务, 可以使用WATH进行CAS监控让指令不执行, 但不支持回滚</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">watch</span> key	<span class="token comment">#监控某个key未被其他客户端修改, 才会正常执行事务</span>
multi	<span class="token comment">#开启事务</span>
<span class="token punctuation">..</span>.		<span class="token comment">#事务内容</span>
<span class="token builtin class-name">exec</span>	<span class="token comment">#提交事务</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="lua简单功能"><a href="#lua简单功能" class="header-anchor">#</a> Lua简单功能</h4> <div class="language-lua line-numbers-mode"><pre class="language-lua"><code><span class="token keyword">local</span> strings val <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span>	<span class="token comment">--定义局部变量, 字符串</span>
<span class="token function">print</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
<span class="token keyword">local</span> tables array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;redis&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;jedis&quot;</span><span class="token punctuation">,</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token number">88.0</span><span class="token punctuation">}</span>	<span class="token comment">--数组</span>
<span class="token comment">-- for, while循环; if else判断; hash类型tables</span>
<span class="token comment">-- 函数定义</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="redis使用lua"><a href="#redis使用lua" class="header-anchor">#</a> redis使用lua</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">eval</span>
evalsha	<span class="token comment">#可复用脚本</span>
redis.call	<span class="token comment">#Lua可以调用redis.call函数实现对redis的访问</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="bitmaps"><a href="#bitmaps" class="header-anchor">#</a> Bitmaps</h3> <p>实现了对位的操作, 其本身不是一种数据结构, 实际上就是字符串</p> <h4 id="bitmaps应用"><a href="#bitmaps应用" class="header-anchor">#</a> Bitmaps应用</h4> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#将每个独立用户是否访问过网站存放在Bitmaps中</span>
setbit unique:users:2016-04-05 <span class="token number">0</span> <span class="token number">1</span>	<span class="token comment">#这天用户0访问了网站</span>
setbit unique:users:2016-04-05 <span class="token number">5</span> <span class="token number">1</span>	<span class="token comment">#这天用户5访问了网站...</span>
getbit unique:users:2016-04-05 <span class="token number">8</span>	<span class="token comment">#查询用户8这天是否访问过网站</span>
bitcount <span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>end<span class="token punctuation">]</span>	<span class="token comment">#查询指定范围1的个数</span>
bitop <span class="token function">op</span> destkey key<span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token comment">#二进制操作,与或非异或(and or not xor)</span>

<span class="token comment">#场景: 统计10万用户任意时间窗口的登录情况 </span>
SETBIT username <span class="token number">10</span> <span class="token number">1</span>	<span class="token comment"># 记录用户第10天的登录</span>
BITCOUNT username	<span class="token comment"># 统计登录数</span>
<span class="token comment">#场景: 活动前统计活跃用户, 僵尸用户, 权限</span>
SETBIT <span class="token number">20200101</span> 用户id <span class="token number">1</span>
BITCOUNT <span class="token number">20200101</span>	<span class="token comment"># 统计当天活跃用户</span>
BITOP or result <span class="token number">20200101</span> <span class="token number">20200102</span>	<span class="token comment">#做或运算统计活跃用户, 波形</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h4 id="hyperloglog-发布订阅-geo"><a href="#hyperloglog-发布订阅-geo" class="header-anchor">#</a> HyperLogLog, 发布订阅, GEO</h4> <p>略</p> <h2 id="_04-客户端"><a href="#_04-客户端" class="header-anchor">#</a> 04. 客户端</h2> <p>redis制定RESP通讯协议, 简单高效, 容易识别</p> <h4 id="jedis使用"><a href="#jedis使用" class="header-anchor">#</a> Jedis使用</h4> <p>略</p> <h4 id="jedis连接池"><a href="#jedis连接池" class="header-anchor">#</a> Jedis连接池</h4> <p>JedisPool连接池, 可以降低开销, 保护机器资源不被滥用; 难点在于合理规划连接池的参数配置</p> <h4 id="jedis使用管道-lua脚本"><a href="#jedis使用管道-lua脚本" class="header-anchor">#</a> Jedis使用管道, Lua脚本</h4> <p>略</p> <h3 id="客户端管理"><a href="#客户端管理" class="header-anchor">#</a> 客户端管理</h3> <p>客户端信息, 输入缓冲区qbuf/qbuf-free, 输出缓冲区obl/oll/omem, 客户端类型, monitor监控, 客户端配置, 客户端常见异常, 常见问题, 案例分析</p> <h2 id="_05-持久化"><a href="#_05-持久化" class="header-anchor">#</a> 05. 持久化</h2> <p>redis支持RDB和AOF两种持久化机制</p> <h3 id="rdb"><a href="#rdb" class="header-anchor">#</a> RDB</h3> <p>把当前进程数据生成快照保存到硬盘, 特点是全量, 按时间点备份, 体积与真实数据相近, 恢复速度较快(不需要cpu计算)</p> <h4 id="触发机制"><a href="#触发机制" class="header-anchor">#</a> 触发机制</h4> <ol><li>手动触发: save(阻塞) 和 bgsave(非阻塞)
<ul><li>bgsave: fork出子进程生成RDB</li></ul></li> <li>自动触发: 使用配置, 从节点复制...</li></ol> <h4 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h4> <ul><li>紧凑压缩的二进制文件, 适用于备份, 全量复制, 恢复数据速度快</li> <li>没办法做到实时持久化, 新老版本RDB不兼容</li> <li>fork后, 内存会被克隆, 要考虑内存膨胀</li></ul> <h3 id="aof"><a href="#aof" class="header-anchor">#</a> AOF</h3> <p>append only file持久化: 以独立日志的方式记录(行为记录), 趋向于实时性</p> <h4 id="aof流程"><a href="#aof流程" class="header-anchor">#</a> AOF流程</h4> <p>所有写入的命令都追加到aof_buf缓冲区, 根据策略进行同步操作</p> <p>write: 触发延时写: 将输入写入linux内核缓冲区, 根据操作系统配置同步到磁盘</p> <p>fsync: 强制硬盘同步: 阻塞写入硬盘后返回</p> <h4 id="rewrite重写"><a href="#rewrite重写" class="header-anchor">#</a> rewrite重写</h4> <p>由于AOF日志文件越来越大, rewrite通过删除无效命令, 整合多条命令来减小日志size</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>bgrewriteaof	<span class="token comment">#手动触发</span>
<span class="token comment">#自动触发则使用配置</span>
<span class="token comment">#auto-aof-rewrite-min-size		触发重写最小体积</span>
<span class="token comment">#auto-aof-rewrite-percentage	和上次重写后AOF文件空间比值</span>
<span class="token comment">#还有aof_current_size和aof_base_size两个统计信息</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="重启加载"><a href="#重启加载" class="header-anchor">#</a> 重启加载</h4> <p>优先加载AOF文件, 如果AOF不存在, 加载RDB文件, 如果文件存在错误, 启动失败</p> <p>文件校验-手动修改, 自动忽略</p> <h4 id="问题定位与优化"><a href="#问题定位与优化" class="header-anchor">#</a> 问题定位与优化</h4> <p>fork操作, 子进程, 内存, 硬盘, AOF追加阻塞, 同机器多实例部署时开启AOF重写</p> <h4 id="aof特点"><a href="#aof特点" class="header-anchor">#</a> AOF特点</h4> <ol><li>趋于实时性, 最多丢失两秒数据</li> <li>日志文件太大, AOF追加阻塞, 恢复数据较慢</li></ol> <h4 id="持久化推荐"><a href="#持久化推荐" class="header-anchor">#</a> 持久化推荐</h4> <p>如果重启redis数据全部丢失? 如果缓存不要求强一致性可以用最快的持久化方案, 或网络异地主从备 (用主从做数据备份)</p> <h2 id="_06-复制"><a href="#_06-复制" class="header-anchor">#</a> 06. 复制</h2> <p>概述: 为了解决单点问题而把数据复制多个副本部署到其他机器, 满足故障恢复和负载均衡等需求; redis本身提供了复制功能</p> <h4 id="redis主从复制"><a href="#redis主从复制" class="header-anchor">#</a> redis主从复制</h4> <p>redis分主从节点, 单主多从</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>slaveof <span class="token operator">&lt;</span>masterHost<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>masterPort<span class="token operator">&gt;</span> <span class="token comment">#建立复制no one</span>
slaveof no one	<span class="token comment">#断开复制, 成为主节点	#切主</span>
<span class="token comment">#安全性, 主节点设置密码, 从节点配置密码才能正确连接</span>
<span class="token comment">#只读, 为保证数据一致, 从节点必须只读</span>
<span class="token comment">#传输延迟, repl-disable-tcp-nodelay参数</span>
<span class="token comment">#拓扑: 一主一从, 一主多从, 树状主从</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="复制原理"><a href="#复制原理" class="header-anchor">#</a> 复制原理</h3> <ol><li>保存主节点 ip, port 信息</li> <li>主从建立socket连接</li> <li>发送ping命令, 检测socket是否可用</li> <li>权限验证</li> <li>同步数据集, 首次连接开始复制, 首次一般是全量复制 sync/psync</li> <li>后续命令持续复制</li></ol> <h4 id="psync"><a href="#psync" class="header-anchor">#</a> psync</h4> <p>redis2.8开始使用psync完成主从同步</p> <ol><li>复制偏移量</li> <li>复制积压缓冲区</li> <li>主节点运行ID</li> <li>使用 psync 命令完成部分复制和全量复制</li></ol> <h4 id="全量复制"><a href="#全量复制" class="header-anchor">#</a> 全量复制</h4> <ol><li>首次复制, 发送psync-1</li> <li>主节点收到命令并回复+FULLRESYNC响应</li> <li>从节点接收响应数据</li> <li>主节点执行bgsave保存RDB</li> <li>主节点发送RDB文件给从节点, 从节点接收并保存至本地</li> <li>主节点在传递RDB文件期间依然接收指令, 这些指令将保存在缓冲区 (如果传输时间过长导致缓冲区溢出会复制失败), 从节点接收并加载完毕RDB后, 再把缓冲区内数据发送给从节点</li> <li>从节点清空自身旧数据</li> <li>从节点开始加载RDB</li> <li>从节点加载完RDB后, 查看AOF是否开启, 决定是否执行bgrewriteaof</li></ol> <p>总结: 慢</p> <h4 id="部分复制"><a href="#部分复制" class="header-anchor">#</a> 部分复制</h4> <ol><li>当主从节点出现网络中断, 超时</li> <li>主从中断期间, 主节点在缓冲区保存最近一段时间的写命令</li> <li>主从网络恢复后, 从节点将原来保存的复制偏移量和主节点运行id发送给主节点</li> <li>逐渐点检查参数, 返回+CONTINUE响应</li> <li>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点</li></ol> <h4 id="心跳"><a href="#心跳" class="header-anchor">#</a> 心跳</h4> <p>主从节点在建立复制后, 它们之间维护长连接并彼此发送心跳</p> <ol><li>主从互为对方的客户端发送命令</li> <li>主节点默认10秒对从节点发送ping命令, 检测从节点存活状态</li> <li>从节点每个1秒发送主节点replconf ack{offset}命令, 上报当前复制偏移量</li></ol> <h4 id="异步复制"><a href="#异步复制" class="header-anchor">#</a> 异步复制</h4> <p>概述: 主节点不但负责数据读写, 还负责把写命令同步给从节点; 写命令的发送是异步的: 主节点自身处理完毕后直接返回客户端, 并不等待从节点复制完成</p> <p>正常情况下延迟在1秒以内</p> <h3 id="问题解决"><a href="#问题解决" class="header-anchor">#</a> 问题解决</h3> <h4 id="读写分离"><a href="#读写分离" class="header-anchor">#</a> 读写分离</h4> <ol><li>数据延迟: 使用monitor监控主从, 避免复制偏移量过大</li> <li>读到过期数据:
<ul><li><strong>惰性删除</strong>: 每次读取命令时会检查key是否超时, 如果超时会执行del删除key</li> <li><strong>定期删除</strong>: redis主节点定时循环采样一定数量的key, 如果过期将执行del</li> <li>以上两个操作会同步给从节点, 如果从节点还未收到del命令, 存在主从不一致现象, redis3.2解决了该问题</li></ul></li> <li>从节点故障
<ul><li>需要客户端维护可用从节点列表, 当从节点故障时立刻切换到其他节点</li> <li>总结: 不推荐主从, 推荐优化主节点, 或者使用Redis Cluster分布式方案</li></ul></li></ol> <h4 id="主从配置不一致"><a href="#主从配置不一致" class="header-anchor">#</a> 主从配置不一致</h4> <p>看配置</p> <h4 id="规避全量复制"><a href="#规避全量复制" class="header-anchor">#</a> 规避全量复制</h4> <h4 id="规避复制风暴"><a href="#规避复制风暴" class="header-anchor">#</a> 规避复制风暴</h4> <p>略</p> <h2 id="_07-redis阻塞"><a href="#_07-redis阻塞" class="header-anchor">#</a> 07. redis阻塞</h2> <h4 id="发现阻塞"><a href="#发现阻塞" class="header-anchor">#</a> 发现阻塞</h4> <p>redis连接异常时, 打印连接实例的ip号和端口号, 使用redis监控系统</p> <h4 id="内在原因"><a href="#内在原因" class="header-anchor">#</a> 内在原因</h4> <ol><li>API和数据结果使用不合理</li> <li>CPU饱和</li> <li>持久化相关阻塞</li></ol> <h4 id="外在原因"><a href="#外在原因" class="header-anchor">#</a> 外在原因</h4> <ol><li>CPU竞争</li> <li>内存交换</li> <li>网络问题</li></ol> <h2 id="_08-理解内存"><a href="#_08-理解内存" class="header-anchor">#</a> 08. 理解内存</h2> <h4 id="内存消耗"><a href="#内存消耗" class="header-anchor">#</a> 内存消耗</h4> <ul><li>内存使用统计</li> <li>内存分类</li> <li>子进程消耗内存</li></ul> <h4 id="内存管理"><a href="#内存管理" class="header-anchor">#</a> 内存管理</h4> <ul><li>设置内存上限, 动态调整内存上限</li> <li>内存回收策略</li></ul> <h4 id="内存回收策略"><a href="#内存回收策略" class="header-anchor">#</a> 内存回收策略</h4> <h5 id="删除过期key"><a href="#删除过期key" class="header-anchor">#</a> 删除过期key</h5> <p>惰性删除: 基于CPU成本考虑, 但是存在内存泄漏</p> <p>定时任务删除: redis维护的定时任务, 默认每秒运行10次, 并采用自适应算法</p> <p>定时任务流程:</p> <ol><li>在每个数据库随机检查20个key, 发现过期就删除</li> <li>如果超过25%的key过期, 循环步骤1直到过期key占比不足25%或运行超时(25ms)</li> <li>如果步骤2超时, 触发快模式进行回收, 超时时间1ms且2秒内只运行一次</li></ol> <h4 id="内存溢出控制策略"><a href="#内存溢出控制策略" class="header-anchor">#</a> 内存溢出控制策略</h4> <p>redis使用内存达到 maxmemory 触发相关策略, redis支持以下模式</p> <ol><li>noeviction(默认): 不删除任何数据, 拒绝写入操作</li> <li>volatile-lru: 按LRU算法删除设置了超时时间的key, 直到腾出足够空间</li> <li>allkeys-lru: 按LRU删除key(不管有没有设置超时时间)</li> <li>allkeys-random: 随机删除任意key</li> <li>volatile-random: 随机删除设置超时时间的key</li> <li>volatile-ttl: 根据ttl删除最快过期的数据</li></ol> <p>LRU: 最近最少使用: 每个key拥有一个LRU计时, 淘汰最久没被访问的</p> <p>LFU: 最不经常使用: 根据每个key的访问次数, 淘汰最少访问的</p> <h3 id="内存优化"><a href="#内存优化" class="header-anchor">#</a> 内存优化</h3> <h4 id="redisobject对象"><a href="#redisobject对象" class="header-anchor">#</a> redisObject对象</h4> <p>redis存储的所有值对象定义为redisObject结构体, 其中当value为字符串类型时, 尽量保持小于39字节</p> <h4 id="缩减键值对象"><a href="#缩减键值对象" class="header-anchor">#</a> 缩减键值对象</h4> <ul><li>缩减 key 和 value 的长度</li> <li>使用高效序列化工具: protostuff/kryo; java自带序列化压缩效果差, 速度辣鸡</li></ul> <h4 id="共享对象池"><a href="#共享对象池" class="header-anchor">#</a> 共享对象池</h4> <p>redis内部维护了[0-9999]的整数对象, 推荐多使用整数对象</p> <h4 id="字符串优化"><a href="#字符串优化" class="header-anchor">#</a> 字符串优化</h4> <p>字符串是最常用的数据结构</p> <h4 id="字符串结构"><a href="#字符串结构" class="header-anchor">#</a> 字符串结构</h4> <p>redis自己实现了字符串结构, 简单动态字符串SDS(simple dynamic string)</p> <ul><li><p>len 已用字节长度</p></li> <li><p>free 未用字节长度</p></li> <li><p>buf[] 字节数组</p></li> <li><p>用于保存字节数组, 安全的二进制存储</p></li> <li><p>内部实现空间预分配机制: 避免内存频繁分配</p></li> <li><p>惰性删除机制: 缩减后空间不释放, 作为预分配空间</p></li></ul> <h4 id="预分配机制"><a href="#预分配机制" class="header-anchor">#</a> 预分配机制</h4> <ol><li>第一次创建已用字节长度等于实际大小, 未用字节长度等于0, 即不做预分配</li> <li>修改后如果free空间不够且数据小于1MB, 每次预分配一倍容量
<ul><li>60, 0 &gt;&gt;&gt;&gt; 120, 120</li></ul></li> <li>修改后free空间不够且数据大于1MB, 每次预分配1MB数据</li></ol> <h4 id="字符串重构"><a href="#字符串重构" class="header-anchor">#</a> 字符串重构</h4> <p>使用hash存储json格式字符串, 同时修改配置保证hash内部编码为ziplist, 可以减少内存占用</p> <h4 id="编码优化"><a href="#编码优化" class="header-anchor">#</a> 编码优化</h4> <ul><li>redis想通过不同编码实现效率和空间的平衡</li> <li>编码类型转换在写入数据时自动完成, 只能从小内存编码向大内存编码转换</li></ul> <h4 id="ziplist编码"><a href="#ziplist编码" class="header-anchor">#</a> ziplist编码</h4> <p>ziplist编码主要目的是为了节约内存, 采用线性连续的内存结构</p> <ul><li>zlbytes : 记录整个ziplist的字节长度</li> <li>zltail : 记录tail的偏移量, 方便pop</li> <li>zllen : 记录zipist节点数量</li> <li>entry-1 : 具体节点
<ul><li>prev_entry_bytes_length : 前一个节点所占空间, 可以视为prev指针</li> <li>encoding : 表示当前节点编码和长度</li> <li>contents : 节点的value</li></ul></li> <li>entry-2 ....</li> <li>zlend : 结尾标记</li></ul> <p>特点: 大幅降低内存占用, 但是命令操作更耗时</p> <h4 id="intset编码"><a href="#intset编码" class="header-anchor">#</a> intset编码</h4> <ul><li>encoding : 表示类型, 分为 int-16, int-32, int-64, 根据长度自动升级</li> <li>length : 集合元素长度</li> <li>contents : 整数数组, 从小到大顺序保存</li></ul> <p>尽量保持整数返回一致</p> <h4 id="控制键的数量"><a href="#控制键的数量" class="header-anchor">#</a> 控制键的数量</h4> <p>可以把大量key分组映射到多个hash结构中降低key的数量, 比如将100万个key映射到1000个hash中, 可以配置参数在hash中使用ziplist编码</p> <h2 id="_09-哨兵"><a href="#_09-哨兵" class="header-anchor">#</a> 09. 哨兵</h2> <p>redis主从复制下, 如果主节点故障将不能提供服务; redis2.8开始提供了 redis sentinel 哨兵来解决这个问题</p> <h4 id="解决痛点"><a href="#解决痛点" class="header-anchor">#</a> 解决痛点</h4> <ul><li>主节点挂了需要人为操作从节点, 切换从节点的slaveof, 重启旧主节点作为从节点</li> <li>判断节点不可达是否标准</li> <li>通知客户端新的主节点</li></ul> <p>当主节点出现故障时, redis sentinel 能自动完成故障发现和故障转移, 并通知应用方</p> <p>流程</p> <ol><li>sentinel节点将监控所有其他redis节点, 并定期检查其他节点是否可用</li> <li>主节点挂了, sentinel发现</li> <li>多个sentinel对主节点的故障达成一致, 则选举出一个sentinel节点进行故障转移</li> <li>sentinel leader执行故障转移</li> <li>将转移结果通知应用方</li></ol> <h4 id="sentinel实际操作"><a href="#sentinel实际操作" class="header-anchor">#</a> sentinel实际操作</h4> <p>略</p> <h4 id="sentinel实现原理"><a href="#sentinel实现原理" class="header-anchor">#</a> sentinel实现原理</h4> <h4 id="三个定时监控任务"><a href="#三个定时监控任务" class="header-anchor">#</a> 三个定时监控任务</h4> <ol><li>每隔10秒, 每个sentinel向主节点和从节点发送info命令获取最新拓扑结构
<ul><li>info从主节点获取从节点信息</li> <li>有新的从节点加入可以立即感知</li> <li>节点挂掉后, 通过info命令更新节点拓扑信息</li></ul></li> <li>每隔2秒, 每个sentinel向redis的 <code>__sentinel__频道</code> 上发送其信息以及对主节点的判断;  同时每个sentinel订阅该频道
<ul><li>发现新的sentinel节点</li> <li>sentinel之间交换主节点状态, 作为后续下线以及leader选举的依据</li></ul></li> <li>每隔1秒, 每个sentinel向主节点, 从节点, 其他sentinel发送ping命令
<ul><li>确认这些节点是否可达</li></ul></li></ol> <h4 id="主观下线"><a href="#主观下线" class="header-anchor">#</a> 主观下线</h4> <p>在ping心跳检测时, 节点超过 down-after-milliseconds 没有回复, 就视为主观下线</p> <h4 id="客观下线"><a href="#客观下线" class="header-anchor">#</a> 客观下线</h4> <p>当sentinel主观下线主节点, sentinel会通过命令向其他sentinel投票, 超过一定票数, 将对主节点进行客观下线</p> <h4 id="领导者sentinel节点选举"><a href="#领导者sentinel节点选举" class="header-anchor">#</a> 领导者sentinel节点选举</h4> <p>当sentinel对主节点进行客观下线, sentinel之间做leader选举的工作, 再让leader进行故障转移工作;</p> <p>redis使用了Raft算法实现领导者选举</p> <ol><li>sentinel确认主观下线时, 则竞选, 并拉票</li> <li>收到拉票的sentinel直接同意</li> <li>如果拉票的sentinel收到半数选票, 当选为leader</li> <li>如果选举失败则进行下一次选举</li></ol> <h4 id="故障转移"><a href="#故障转移" class="header-anchor">#</a> 故障转移</h4> <ol><li>在从节点中选择一个节点作为新的主节点
<ol><li>过滤 主观下线, 短信, 5秒内没有回复过sentinel, 与主节点失联10秒以上的</li> <li>选择从节点优先级最高的从节点列表</li> <li>选择复制偏移量最大的节点</li> <li>选择runid最小的从节点</li></ol></li> <li>对从节点执行slaveof no one</li> <li>leader向剩余的从节点发送slaveof, 切换主节点</li> <li>sentinel集群将原来的主节点更新为从节点, 当其回复后去slaveof新主节点</li></ol> <h4 id="开发与运维中的问题"><a href="#开发与运维中的问题" class="header-anchor">#</a> 开发与运维中的问题</h4> <p>故障转移日志分析, 节点运维, 读写分离高可用</p> <h2 id="_10-集群-redis-cluster"><a href="#_10-集群-redis-cluster" class="header-anchor">#</a> 10. 集群 redis cluster</h2> <p>redis cluster是redis的分布式解决方案</p> <h3 id="数据分布-分区"><a href="#数据分布-分区" class="header-anchor">#</a> 数据分布/分区</h3> <p>分布式数据库首先要把数据分区映射到多个节点中, 让每个节点负责整体数据的一个子集</p> <h4 id="分区规则"><a href="#分区规则" class="header-anchor">#</a> 分区规则</h4> <ol><li>哈希分区 : redis cluster, cassandra</li> <li>顺序分区 : Bigtable HBase</li></ol> <h4 id="哈希分区"><a href="#哈希分区" class="header-anchor">#</a> 哈希分区</h4> <ol><li><strong>节点取余分区</strong> : 简单, 一般需要根据数据量规划预分区, 一旦需要扩容需要迁移数据</li> <li><strong>一致性哈希分区</strong> <ul><li>取 0~2³² 范围作为哈希环, 为每个集群节点各分配一个hash值;</li> <li>key计算出hash后, 顺时针寻找到最近的节点</li> <li>优势在于新增节点会影响一部分数据, 其他节点不影响</li> <li>存在哈希倾斜; 分布式节点多的效果更好</li></ul></li> <li><strong>虚拟槽分区</strong> : 用分散度好的hash将数据映射到固定范围的整数集合中
<ul><li>整数集合size远远大于分布式节点数量, 方便数据拆分和集群扩展</li> <li>redis cluster槽范围0-16383, 如果有5个节点则每个节点负责3276个槽</li></ul></li></ol> <h4 id="redis数据分区"><a href="#redis数据分区" class="header-anchor">#</a> redis数据分区</h4> <p>redis采用虚拟槽分区, 每一个节点负责维护一部分槽, 所有的key映射到这些槽内</p> <p><code>slot=CRC16(key) &amp; 16383</code></p> <ul><li>解耦数据和节点之间的关系, 简化了节点扩容和缩容的难度</li> <li>节点自身维护槽的映射关系, 不需要其他代理服务维护</li> <li>支持节点, 槽, key之间的映射查询, 用于数据路由, 在线伸缩</li></ul> <h4 id="redis-cluster集群功能限制"><a href="#redis-cluster集群功能限制" class="header-anchor">#</a> redis cluster集群功能限制</h4> <ol><li>key批量操作支持有线, 如mset, mget只支持相同slot内的key执行批量操作</li> <li>不同槽位的key不支持事务</li> <li>无法将一个大key(可能是hash, list)拆分到多个槽</li> <li>不支持多数据库空间, 集群模式下只能使用db0</li> <li>复制结构只支持一层主从</li></ol> <h3 id="搭建redis-cluster集群"><a href="#搭建redis-cluster集群" class="header-anchor">#</a> 搭建redis cluster集群</h3> <h4 id="准备节点"><a href="#准备节点" class="header-anchor">#</a> 准备节点</h4> <p>节点数量至少6个才能保证组成完整高可用的集群, 3主3从</p> <h4 id="节点握手"><a href="#节点握手" class="header-anchor">#</a> 节点握手</h4> <p>集群模式下的节点通过Gossip协议彼此通信, 通过发送meet, ping, pong消息通信</p> <h4 id="分配槽位"><a href="#分配槽位" class="header-anchor">#</a> 分配槽位</h4> <p>cluster addslots 命令分配槽位</p> <h4 id="节点通信"><a href="#节点通信" class="header-anchor">#</a> 节点通信</h4> <p>分布式存储中需要提供 [维护节点元数据信息] 的机制: 主要包括 节点负责哪些数据, 节点状态信息;  常见的元数据维护方式有 集中式和P2P方式</p> <p>redis cluster采用 P2P的 Gossip协议 : 节点之间不断通信交换信息</p> <ol><li>集群中的每个节点都会单独开辟一个TCP端口, 端口号是基础端口上加10000</li> <li>每个节点通过特定规则定时发送ping消息, 接收到ping的节点响应pong消息</li></ol> <h3 id="gossip消息"><a href="#gossip消息" class="header-anchor">#</a> Gossip消息</h3> <p>Gossip协议的主要职责是信息交换</p> <ol><li>meet消息: 通知新节点加入, meet消息正常完成后, 接收节点加入集群周期发送ping/pong消息</li> <li>ping消息: 每个节点每秒向多个其他节点发送, 用于检测节点是否在线, 交换彼此状态信息</li> <li>pong消息: 当接收到ping/meet消息, 作为响应回复对方; 消息内部封装了自身状态数据; 也可以向集群内广播pong消息来通知自身状态的更新</li> <li>fail消息: 当节点判定另一个节点下线时, 会向集群内广播fail消息, 用于故障转移</li></ol> <h4 id="gossip消息通讯节点选择"><a href="#gossip消息通讯节点选择" class="header-anchor">#</a> Gossip消息通讯节点选择</h4> <p>redis的Gossip协议需要兼顾信息交换实时性和通讯成本开销</p> <ol><li>首先, 定时任务是每秒执行10次</li> <li>选择发送的节点, 发送ping消息
<ul><li>每秒一次: 选取5个节点, 选择最久没有通信的节点发送ping消息</li> <li>每秒10次: 扫描本地节点列表, 找出最近一次接受pong消息时间大于cluster_node_timeout/2的节点发送ping消息</li></ul></li> <li>消息数据量: ping消息携带本节点信息+十分之一其他节点信息</li></ol> <h3 id="集群伸缩"><a href="#集群伸缩" class="header-anchor">#</a> 集群伸缩</h3> <p>redis在不影响集群对外服务的情况下, 可以扩容缩容: 其原理可以简单理解为槽位在不同节点之间灵活移动</p> <h4 id="集群扩容"><a href="#集群扩容" class="header-anchor">#</a> 集群扩容</h4> <ul><li>推荐使用 redis-trib.rb工具加入新节点, 同时注意不要不同集群的节点互相加入</li> <li>新节点加入集群后, 可以进行部分槽迁移作为扩容, 或是作为其他主节点的从节点负责故障转移</li></ul> <h4 id="槽位迁移-数据迁移"><a href="#槽位迁移-数据迁移" class="header-anchor">#</a> 槽位迁移,数据迁移</h4> <p>槽迁移需要确保每个节点负责相似数量的槽, 尽量保证各节点数据均匀</p> <ol><li>目标节点准备导入槽的数据</li> <li>源节点准备迁出槽的数据</li> <li>原节点批量迁移到目标节点</li> <li>通知所有主节点, 更新槽映射指向新节点</li></ol> <h4 id="集群缩容"><a href="#集群缩容" class="header-anchor">#</a> 集群缩容</h4> <ol><li>确定下线节点是否有负责的槽位, 如果有需要把槽迁移到其他节点</li> <li>通知集群内其他节点忘记下线节点, 然后将下线节点正常关闭</li></ol> <h4 id="请求路由"><a href="#请求路由" class="header-anchor">#</a> 请求路由</h4> <p>redis cluster并没有采用代理, 而是客户端直连</p> <h3 id="请求重定向"><a href="#请求重定向" class="header-anchor">#</a> 请求重定向</h3> <p>redis cluster模式下, redis接收任何key相关命令首先计算对应的槽和节点; 如果节点是自身则处理命令, 否则回复MOVED重定向错误</p> <ol><li>使用redis客户端, 在客户端中维护slot和node的映射, 本地实现key到节点的查找</li> <li>也有可能返回ASK重定向异常 说明集群正在进行slot数据迁移</li></ol> <h3 id="故障转移-2"><a href="#故障转移-2" class="header-anchor">#</a> 故障转移</h3> <p>redis cluster自身实现了高可用, 解决节点故障问题</p> <h4 id="故障发现"><a href="#故障发现" class="header-anchor">#</a> 故障发现</h4> <p>redis cluster通过ping/pong消息实现节点通信, 传播节点状态</p> <ol><li>主观下线(pfail): 发送节点发送ping消息, 如果目标节点超过超时时间都未响应pong消息, 则被视为pfail</li> <li>客观下线(fail): 主观下线通过Gossip消息在集群内传播, 当半数以上持有槽的主节点都主观下线目标节点, 则触发客观下线</li> <li>广播一条fail消息, 将目标节点标记为客观下线</li></ol> <h4 id="故障恢复"><a href="#故障恢复" class="header-anchor">#</a> 故障恢复</h4> <ol><li>资格检查</li> <li>准备选举时间</li> <li>发起选举</li> <li>选举投票</li> <li>替换主节点</li></ol> <h3 id="集群运维"><a href="#集群运维" class="header-anchor">#</a> 集群运维</h3> <p>超大规模集群带宽消耗,  pub/sub广播问题, 集群节点倾斜问题, 手动故障转移, 在线迁移数据</p> <h2 id="_11-缓存设计"><a href="#_11-缓存设计" class="header-anchor">#</a> 11. 缓存设计</h2> <p>缓存使用技巧, 设计方案</p> <h4 id="缓存的收益和成本"><a href="#缓存的收益和成本" class="header-anchor">#</a> 缓存的收益和成本</h4> <ol><li>加速读写</li> <li>降低后端负载</li> <li>数据不一致</li> <li>代码维护成本</li> <li>运维成本</li></ol> <p>场景:</p> <ol><li>开销大的复杂计算</li> <li>加速请求响应</li></ol> <h3 id="缓存更新策略"><a href="#缓存更新策略" class="header-anchor">#</a> 缓存更新策略</h3> <p>缓存数据通常有生命周期, 在指定时间后被删除或更新, 这样可以保证缓存空间在一个可控范围</p> <ol><li>LRU LFU FIFO算法剔除 : 通常用于使用量超过预设值
<ul><li>一致性差(不是人为决定的剔除哪些key)</li> <li>成本低(仅需配置策略即可)</li></ul></li> <li>超时剔除 : 给缓存设置过期时间
<ul><li>一段时间内存在一致性问题</li> <li>成本不高</li></ul></li> <li>主动更新 : 需要真实数据更新后, 立即更新缓存数据
<ul><li>一致性最高</li> <li>维护成本高</li></ul></li></ol> <p>最佳实践: 低一致性业务甚至可以只靠淘汰策略</p> <p>高一致性业务结合使用超时剔除和主动更新, 即使主动更新失败, 也能保证过期时间后删除脏数据</p> <h4 id="缓存粒度控制"><a href="#缓存粒度控制" class="header-anchor">#</a> 缓存粒度控制</h4> <p>缓存全部属性更通用, 但空间占用大, 网络开销大, 代码维护少; 缓存部分属性则反之</p> <h3 id="缓存穿透优化"><a href="#缓存穿透优化" class="header-anchor">#</a> 缓存穿透优化</h3> <p>缓存穿透值查询一个根本不存在的数据, 缓存层和存储层都不会命中, 通常从存储层查不到的数据都不写入缓存</p> <p>缓存穿透的每次请求都到达存储层, 可能是恶意攻击和代码bug造成</p> <ol><li><strong>缓存空对象</strong> <ul><li>占用更多内存空间, 可以通过设置较短ttl自动剔除</li> <li>可能导致数据不一致</li></ul></li> <li><strong>布隆过滤器拦截</strong> <ul><li>可以将所有数据做成布隆过滤器, 判断数据是否存在</li> <li>适用于数据命中不高, 数据相对固定, 实时性低的引用场景</li> <li>代码复杂但缓存空间占用少</li> <li>redis4.0开始提供RedisBloom插件</li></ul></li></ol> <h4 id="布隆过滤器"><a href="#布隆过滤器" class="header-anchor">#</a> 布隆过滤器</h4> <ol><li>通过多个映射函数将已有的元素映射到bitmap上, 一个元素会映射到多个bit</li> <li>如果目标元素经过函数映射到没有数据的bitmap位置上, 说明数据库中肯定没有, 但会有一定概率穿透(误判), 1%</li> <li>传统的布隆过滤器并不支持删除操作(会增加误判率), 使用counting布隆或布谷鸟过滤器</li></ol> <h4 id="无底洞优化"><a href="#无底洞优化" class="header-anchor">#</a> 无底洞优化</h4> <p>大量redis节点反而导致性能下降 --- 分布式下的批量操作</p> <ol><li>命令本身优化</li> <li>减少网络通信次数</li> <li>降低接入成本, 长连接/连接池/NIO</li></ol> <p><img src="https://img-blog.csdn.net/20180424144835553?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ltMTIzNDU2Njc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="comp"></p> <p>方案选择</p> <ol><li>串行 get key * n次</li> <li>将一个批量命令按节点拆分成多个mget, 发送给对应节点处理</li> <li>并行IO, 使用异步发送方案2中的多个mget</li> <li>hash_tag实现: 将多个key强制分配到一个节点上</li></ol> <h3 id="缓存雪崩优化"><a href="#缓存雪崩优化" class="header-anchor">#</a> 缓存雪崩优化</h3> <p>大量请求下, 缓存down掉后, 所有请求到达数据库造成级联宕机的情况</p> <ol><li>保证缓存服务高可用性</li> <li>隔离组件为后端限流, 降级 : 将重要资源隔离, Hystrix</li> <li>提前演练: 项目上线前演练缓存宕机之后, 应用及后端负载情况, 以及可能出现的问题</li></ol> <h3 id="热点key重建优化"><a href="#热点key重建优化" class="header-anchor">#</a> 热点key重建优化</h3> <p>使用 缓存+过期时间 策略能满足大部分需求, 但是</p> <ol><li>当前key上一个热点key, 并发量非常大</li> <li>重建缓存不能短时间完成, 可能是个复杂计算, 多次SQL, 多次IO</li> <li>缓存失效瞬间, 大量请求达到后端数据库</li></ol> <p>解决</p> <ol><li>分布式锁
<ul><li>死锁风险, 线程池阻塞, 但是数据一致性保证</li></ul></li> <li>永远不过期
<ol><li>不设置过期时间</li> <li>设置逻辑过期时间, 用单独的线程不断构建缓存(可能不一致)</li></ol></li></ol> <p><img src="https://img-blog.csdn.net/20180424151829748?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ltMTIzNDU2Njc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="热点key"></p> <h2 id="_12-其他"><a href="#_12-其他" class="header-anchor">#</a> 12. 其他</h2> <p>开发运维, CacheCloud, 配置目录等, 略</p> <h3 id="补充"><a href="#补充" class="header-anchor">#</a> 补充</h3> <h3 id="redis分布式锁"><a href="#redis分布式锁" class="header-anchor">#</a> Redis分布式锁</h3> <p><a href="https://mp.weixin.qq.com/s/s8xjm1ZCKIoTGT3DCVA4aw" target="_blank" rel="noopener noreferrer">Redis分布式锁到底安全吗, 关于RedLock的争论<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="redis分布式锁实现"><a href="#redis分布式锁实现" class="header-anchor">#</a> redis分布式锁实现</h4> <ol><li><strong>加锁</strong>: Lua脚本, SET lock_key $unique_id EX $expire_time NX
<ul><li>最初版: setnx 命令抢占锁 (SET if Not Exist) , 此时目标key (此处为lock_key) 作为锁</li> <li>解决死锁问题: 设置EX超时时间, 避免占锁线程挂掉, 导致的死锁</li></ul></li> <li><strong>释放锁</strong>:
<ul><li>解决释放别人的锁的问题: key中的value还没用到, 设置为UUID吧! 先 GET 判断锁是否归属自己, 再决定是否 DEL 释放锁, 整个过程为了<strong>保证原子性, 使用Lua脚本</strong></li></ul></li> <li><strong>锁续期</strong> :
<ul><li>解决锁过期时间不好评估的问题: 如果占锁线程正常, 定时对锁续期</li></ul></li> <li>仍然存在的<strong>问题</strong>: redis主从集群下, 数据不同步导致锁失效
<ul><li>主机设置完锁后还未同步到从机就宕机了, 此时新主机根本没有上锁</li></ul></li></ol> <p>Redisson提供了基于redis的分布式锁, 实现了自动续期功能</p> <h4 id="redlock"><a href="#redlock" class="header-anchor">#</a> RedLock</h4> <p>至少要部署 5 个 Redis 实例, 而且都是主库, 它们之间没有任何关系</p> <ol><li>客户端先获取「当前时间戳T1」</li> <li>客户端依次向这 5 个 Redis 实例发起加锁请求 (用前面讲到的 SET 命令)
<ul><li>且每个请求会设置超时时间 (毫秒级, 要远小于锁的有效时间)</li> <li>如果某一个实例加锁失败 (包括网络超时、锁被其它人持有等各种异常情况) , 就立即向下一个 Redis 实例申请加锁</li></ul></li> <li>如果客户端在 &gt;=3 个 Redis 实例加锁成功 (大多数加锁成功) , 则
<ol><li>再次获取「当前时间戳T2」</li> <li>判断 T2 - T1 &lt; 锁的过期时间, 如果还未超过过期(有效)时间, 则加锁成功, 否则加锁失败</li></ol></li> <li>加锁成功, 去操作共享资源</li> <li>加锁失败, 向「全部节点」发起释放锁请求 (前面讲到的 Lua 脚本释放锁)</li></ol> <p><svg id="SvgjsSvg1006" width="327" height="333" xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"><defs id="SvgjsDefs1007"><marker id="SvgjsMarker1046" markerWidth="16" markerHeight="12" refX="16" refY="6" viewBox="0 0 16 12" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1047" d="M0,2 L14,6 L0,11 L0,2" fill="#323232" stroke="#323232" stroke-width="2"></path></marker><marker id="SvgjsMarker1050" markerWidth="16" markerHeight="12" refX="16" refY="6" viewBox="0 0 16 12" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1051" d="M0,2 L14,6 L0,11 L0,2" fill="#323232" stroke="#323232" stroke-width="2"></path></marker><marker id="SvgjsMarker1054" markerWidth="16" markerHeight="12" refX="16" refY="6" viewBox="0 0 16 12" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1055" d="M0,2 L14,6 L0,11 L0,2" fill="#323232" stroke="#323232" stroke-width="2"></path></marker><marker id="SvgjsMarker1058" markerWidth="16" markerHeight="12" refX="16" refY="6" viewBox="0 0 16 12" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1059" d="M0,2 L14,6 L0,11 L0,2" fill="#323232" stroke="#323232" stroke-width="2"></path></marker><marker id="SvgjsMarker1062" markerWidth="16" markerHeight="12" refX="16" refY="6" viewBox="0 0 16 12" orient="auto" markerUnits="userSpaceOnUse" stroke-dasharray="0,0"><path id="SvgjsPath1063" d="M0,2 L14,6 L0,11 L0,2" fill="#323232" stroke="#323232" stroke-width="2"></path></marker></defs><g id="SvgjsG1008" transform="translate(25,131.5)"><path id="SvgjsPath1009" d="M 0 35C 0 -11.666666666666666 70 -11.666666666666666 70 35C 70 81.66666666666667 0 81.66666666666667 0 35Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#bbdefb"></path><g id="SvgjsG1010"><text id="SvgjsText1011" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="50px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="25.375" transform="rotate(0)"><tspan id="SvgjsTspan1012" dy="16" x="35"><tspan id="SvgjsTspan1013">app</tspan></tspan></text></g></g><g id="SvgjsG1014" transform="translate(210,25)"><path id="SvgjsPath1015" d="M 0 4Q 0 0 4 0L 88 0Q 92 0 92 4L 92 38Q 92 42 88 42L 4 42Q 0 42 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#ffcdd2"></path><g id="SvgjsG1016"><text id="SvgjsText1017" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="72px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="11.375" transform="rotate(0)"><tspan id="SvgjsTspan1018" dy="16" x="46"><tspan id="SvgjsTspan1019">Redis</tspan></tspan></text></g></g><g id="SvgjsG1020" transform="translate(210,85.25)"><path id="SvgjsPath1021" d="M 0 4Q 0 0 4 0L 88 0Q 92 0 92 4L 92 38Q 92 42 88 42L 4 42Q 0 42 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#ffcdd2"></path><g id="SvgjsG1022"><text id="SvgjsText1023" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="72px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="11.375" transform="rotate(0)"><tspan id="SvgjsTspan1024" dy="16" x="46"><tspan id="SvgjsTspan1025">Redis</tspan></tspan></text></g></g><g id="SvgjsG1026" transform="translate(210,145.5)"><path id="SvgjsPath1027" d="M 0 4Q 0 0 4 0L 88 0Q 92 0 92 4L 92 38Q 92 42 88 42L 4 42Q 0 42 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#ffcdd2"></path><g id="SvgjsG1028"><text id="SvgjsText1029" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="72px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="11.375" transform="rotate(0)"><tspan id="SvgjsTspan1030" dy="16" x="46"><tspan id="SvgjsTspan1031">Redis</tspan></tspan></text></g></g><g id="SvgjsG1032" transform="translate(210,205.75)"><path id="SvgjsPath1033" d="M 0 4Q 0 0 4 0L 88 0Q 92 0 92 4L 92 38Q 92 42 88 42L 4 42Q 0 42 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#ffcdd2"></path><g id="SvgjsG1034"><text id="SvgjsText1035" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="72px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="11.375" transform="rotate(0)"><tspan id="SvgjsTspan1036" dy="16" x="46"><tspan id="SvgjsTspan1037">Redis</tspan></tspan></text></g></g><g id="SvgjsG1038" transform="translate(210,266)"><path id="SvgjsPath1039" d="M 0 4Q 0 0 4 0L 88 0Q 92 0 92 4L 92 38Q 92 42 88 42L 4 42Q 0 42 0 38Z" stroke="rgba(50,50,50,1)" stroke-width="2" fill-opacity="1" fill="#ffcdd2"></path><g id="SvgjsG1040"><text id="SvgjsText1041" font-family="微软雅黑" text-anchor="middle" font-size="13px" width="72px" fill="#323232" font-weight="400" align="middle" lineHeight="125%" anchor="middle" family="微软雅黑" size="13px" weight="400" font-style="" opacity="1" y="11.375" transform="rotate(0)"><tspan id="SvgjsTspan1042" dy="16" x="46"><tspan id="SvgjsTspan1043">Redis</tspan></tspan></text></g></g><g id="SvgjsG1044"><path id="SvgjsPath1045" d="M95 166.5C 161.37408368287248 172.30697987417233 143.3723781003704 46 210 46" stroke="#323232" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1046)"></path></g><g id="SvgjsG1048"><path id="SvgjsPath1049" d="M95 166.5C 146.733206919738 171.02606913331795 158.06918063423223 106.25 210 106.25" stroke="#323232" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1050)"></path></g><g id="SvgjsG1052"><path id="SvgjsPath1053" d="M95 166.5C 140.8249561122203 170.50916416639225 164 166.5 210 166.5" stroke="#323232" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1054)"></path></g><g id="SvgjsG1056"><path id="SvgjsPath1057" d="M95 166.5C 146.733206919738 171.02606913331795 158.06918063423223 226.75 210 226.75" stroke="#323232" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1058)"></path></g><g id="SvgjsG1060"><path id="SvgjsPath1061" d="M95 166.5C 161.37408368287248 172.30697987417233 143.3723781003704 287 210 287" stroke="#323232" stroke-width="2" fill="none" marker-end="url(#SvgjsMarker1062)"></path></g></svg></p> <h4 id="spring整合redis"><a href="#spring整合redis" class="header-anchor">#</a> Spring整合redis</h4> <p>jedis, lettuce</p> <ol><li>连接redis</li> <li>选择高阶或低阶的api进行调用</li> <li>数据要序列化成什么样子放进去 (Jackson2JsonRedisSerializer)</li></ol> <h4 id="select-epoll"><a href="#select-epoll" class="header-anchor">#</a> select epoll</h4> <ol><li>早期对内核socket读取是阻塞的</li> <li>后来对socket可以非阻塞读取, 轮询读取, 多个socket还是要每个去读取</li> <li>出现select, 使用后内核一次返回哪些socket可以读取</li> <li></li></ol></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">10/27/2021, 10:16:44 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.42575a28.js" defer></script><script src="/assets/js/2.0d7d09b8.js" defer></script><script src="/assets/js/41.3f4581d8.js" defer></script>
  </body>
</html>
