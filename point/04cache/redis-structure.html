<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>redis | SUCKED BloG</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/logo.ico">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.35bcedcf.css" as="style"><link rel="preload" href="/assets/js/app.42575a28.js" as="script"><link rel="preload" href="/assets/js/2.0d7d09b8.js" as="script"><link rel="preload" href="/assets/js/42.60b85cdf.js" as="script"><link rel="prefetch" href="/assets/js/10.1a30ebe5.js"><link rel="prefetch" href="/assets/js/100.022f696a.js"><link rel="prefetch" href="/assets/js/101.06eb0acb.js"><link rel="prefetch" href="/assets/js/102.e944c220.js"><link rel="prefetch" href="/assets/js/103.45b9da9a.js"><link rel="prefetch" href="/assets/js/104.cf53f5d1.js"><link rel="prefetch" href="/assets/js/105.200d7fe5.js"><link rel="prefetch" href="/assets/js/106.a0cc3502.js"><link rel="prefetch" href="/assets/js/107.4a71d17e.js"><link rel="prefetch" href="/assets/js/108.d7a39a75.js"><link rel="prefetch" href="/assets/js/109.35619cf9.js"><link rel="prefetch" href="/assets/js/11.f78ae8b3.js"><link rel="prefetch" href="/assets/js/110.f667d72e.js"><link rel="prefetch" href="/assets/js/111.de83ce6f.js"><link rel="prefetch" href="/assets/js/112.417d40bf.js"><link rel="prefetch" href="/assets/js/113.0f26c1ca.js"><link rel="prefetch" href="/assets/js/114.c7014acb.js"><link rel="prefetch" href="/assets/js/115.b502c0f1.js"><link rel="prefetch" href="/assets/js/116.10fb230e.js"><link rel="prefetch" href="/assets/js/117.f7cb9e2a.js"><link rel="prefetch" href="/assets/js/118.978d3075.js"><link rel="prefetch" href="/assets/js/119.09272191.js"><link rel="prefetch" href="/assets/js/12.140aa2af.js"><link rel="prefetch" href="/assets/js/120.32b5dbd7.js"><link rel="prefetch" href="/assets/js/121.8d618bbb.js"><link rel="prefetch" href="/assets/js/122.dcd4190d.js"><link rel="prefetch" href="/assets/js/123.2ee061d1.js"><link rel="prefetch" href="/assets/js/124.5a3760a7.js"><link rel="prefetch" href="/assets/js/125.a874a4bc.js"><link rel="prefetch" href="/assets/js/126.c6c6b7e6.js"><link rel="prefetch" href="/assets/js/127.38c35051.js"><link rel="prefetch" href="/assets/js/128.8d775ac8.js"><link rel="prefetch" href="/assets/js/129.6100ddb1.js"><link rel="prefetch" href="/assets/js/13.b2a6e590.js"><link rel="prefetch" href="/assets/js/130.9a83da2a.js"><link rel="prefetch" href="/assets/js/131.22de7670.js"><link rel="prefetch" href="/assets/js/132.f88798bf.js"><link rel="prefetch" href="/assets/js/133.925bbfed.js"><link rel="prefetch" href="/assets/js/134.481fad71.js"><link rel="prefetch" href="/assets/js/135.c3efb09b.js"><link rel="prefetch" href="/assets/js/136.758c447a.js"><link rel="prefetch" href="/assets/js/137.dcde1032.js"><link rel="prefetch" href="/assets/js/138.616a346b.js"><link rel="prefetch" href="/assets/js/139.b58dd07f.js"><link rel="prefetch" href="/assets/js/14.15374560.js"><link rel="prefetch" href="/assets/js/140.62b4c7ea.js"><link rel="prefetch" href="/assets/js/15.ffd155fa.js"><link rel="prefetch" href="/assets/js/16.feb1b022.js"><link rel="prefetch" href="/assets/js/17.6d491eb6.js"><link rel="prefetch" href="/assets/js/18.03ddaa95.js"><link rel="prefetch" href="/assets/js/19.021bbcc8.js"><link rel="prefetch" href="/assets/js/20.8aa708b0.js"><link rel="prefetch" href="/assets/js/21.59d7a21e.js"><link rel="prefetch" href="/assets/js/22.21597439.js"><link rel="prefetch" href="/assets/js/23.77303f0b.js"><link rel="prefetch" href="/assets/js/24.0789ed5b.js"><link rel="prefetch" href="/assets/js/25.244a12a8.js"><link rel="prefetch" href="/assets/js/26.a6ee95e4.js"><link rel="prefetch" href="/assets/js/27.9e0f0e9d.js"><link rel="prefetch" href="/assets/js/28.189031c5.js"><link rel="prefetch" href="/assets/js/29.b3100d33.js"><link rel="prefetch" href="/assets/js/3.2a5d4cd5.js"><link rel="prefetch" href="/assets/js/30.fe8fe8c0.js"><link rel="prefetch" href="/assets/js/31.86fec3f7.js"><link rel="prefetch" href="/assets/js/32.24cac061.js"><link rel="prefetch" href="/assets/js/33.f1db2ed0.js"><link rel="prefetch" href="/assets/js/34.c220692f.js"><link rel="prefetch" href="/assets/js/35.9e7b4779.js"><link rel="prefetch" href="/assets/js/36.0cb1d1bc.js"><link rel="prefetch" href="/assets/js/37.7d1fcf79.js"><link rel="prefetch" href="/assets/js/38.bc9bc4b3.js"><link rel="prefetch" href="/assets/js/39.10801a2a.js"><link rel="prefetch" href="/assets/js/4.b4d9a5aa.js"><link rel="prefetch" href="/assets/js/40.c980543d.js"><link rel="prefetch" href="/assets/js/41.3f4581d8.js"><link rel="prefetch" href="/assets/js/43.1338528d.js"><link rel="prefetch" href="/assets/js/44.786fc51f.js"><link rel="prefetch" href="/assets/js/45.d65f6744.js"><link rel="prefetch" href="/assets/js/46.543c2b26.js"><link rel="prefetch" href="/assets/js/47.59f19ed2.js"><link rel="prefetch" href="/assets/js/48.60de6b25.js"><link rel="prefetch" href="/assets/js/49.f3df62ef.js"><link rel="prefetch" href="/assets/js/5.013522c1.js"><link rel="prefetch" href="/assets/js/50.fd9871d6.js"><link rel="prefetch" href="/assets/js/51.1fb1863e.js"><link rel="prefetch" href="/assets/js/52.c06ce3f3.js"><link rel="prefetch" href="/assets/js/53.a3d55203.js"><link rel="prefetch" href="/assets/js/54.89ac64bc.js"><link rel="prefetch" href="/assets/js/55.ccf38d1e.js"><link rel="prefetch" href="/assets/js/56.ffb8595b.js"><link rel="prefetch" href="/assets/js/57.5f1bd695.js"><link rel="prefetch" href="/assets/js/58.7463616d.js"><link rel="prefetch" href="/assets/js/59.ea4eb5dd.js"><link rel="prefetch" href="/assets/js/6.72ad7c85.js"><link rel="prefetch" href="/assets/js/60.a2add219.js"><link rel="prefetch" href="/assets/js/61.3eae0362.js"><link rel="prefetch" href="/assets/js/62.801d1658.js"><link rel="prefetch" href="/assets/js/63.b47a17bb.js"><link rel="prefetch" href="/assets/js/64.d5e2bdea.js"><link rel="prefetch" href="/assets/js/65.24d540f4.js"><link rel="prefetch" href="/assets/js/66.09a1ae52.js"><link rel="prefetch" href="/assets/js/67.75bd38e7.js"><link rel="prefetch" href="/assets/js/68.1fe6956e.js"><link rel="prefetch" href="/assets/js/69.d3306c2d.js"><link rel="prefetch" href="/assets/js/7.60760bb7.js"><link rel="prefetch" href="/assets/js/70.95aa4503.js"><link rel="prefetch" href="/assets/js/71.7065ebf0.js"><link rel="prefetch" href="/assets/js/72.55ae5081.js"><link rel="prefetch" href="/assets/js/73.c7624eee.js"><link rel="prefetch" href="/assets/js/74.63bcc7bd.js"><link rel="prefetch" href="/assets/js/75.e2731e20.js"><link rel="prefetch" href="/assets/js/76.1711af80.js"><link rel="prefetch" href="/assets/js/77.f1c4e2d3.js"><link rel="prefetch" href="/assets/js/78.900bc856.js"><link rel="prefetch" href="/assets/js/79.a1b8c47b.js"><link rel="prefetch" href="/assets/js/8.0c261cf2.js"><link rel="prefetch" href="/assets/js/80.7cf435bf.js"><link rel="prefetch" href="/assets/js/81.fa33b2af.js"><link rel="prefetch" href="/assets/js/82.cdabd386.js"><link rel="prefetch" href="/assets/js/83.879fc50c.js"><link rel="prefetch" href="/assets/js/84.7e460788.js"><link rel="prefetch" href="/assets/js/85.339356d5.js"><link rel="prefetch" href="/assets/js/86.d526418c.js"><link rel="prefetch" href="/assets/js/87.12877e38.js"><link rel="prefetch" href="/assets/js/88.d5a7d193.js"><link rel="prefetch" href="/assets/js/89.2f4a62c2.js"><link rel="prefetch" href="/assets/js/9.50eda380.js"><link rel="prefetch" href="/assets/js/90.6d83f5bf.js"><link rel="prefetch" href="/assets/js/91.f3364825.js"><link rel="prefetch" href="/assets/js/92.158fcc7a.js"><link rel="prefetch" href="/assets/js/93.0c4e5f88.js"><link rel="prefetch" href="/assets/js/94.c5725f80.js"><link rel="prefetch" href="/assets/js/95.dc61d501.js"><link rel="prefetch" href="/assets/js/96.3a598fc5.js"><link rel="prefetch" href="/assets/js/97.712aa8be.js"><link rel="prefetch" href="/assets/js/98.e757fe7a.js"><link rel="prefetch" href="/assets/js/99.1418024a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35bcedcf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">SUCKED BloG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/other/index.html" class="nav-link">
  index
</a></div><div class="nav-item"><a href="/question/index.html" class="nav-link">
  question
</a></div><div class="nav-item"><a href="/audition/index.html" class="nav-link">
  audition
</a></div><div class="nav-item"><a href="/point/index.html" class="nav-link">
  point
</a></div><div class="nav-item"><a href="/work/index.html" class="nav-link">
  work
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="url" class="dropdown-title"><span class="title">url</span> <span class="arrow down"></span></button> <button type="button" aria-label="url" class="mobile-dropdown-title"><span class="title">url</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/other/config.html" class="nav-link">
  其他
</a></li><li class="dropdown-item"><!----> <a href="https://git.code.tencent.com/u/nampy" target="_blank" rel="noopener noreferrer" class="nav-link external">
  腾讯工蜂
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/willwxt" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="http://nbcb.icu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  导航首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/other/index.html" class="nav-link">
  index
</a></div><div class="nav-item"><a href="/question/index.html" class="nav-link">
  question
</a></div><div class="nav-item"><a href="/audition/index.html" class="nav-link">
  audition
</a></div><div class="nav-item"><a href="/point/index.html" class="nav-link">
  point
</a></div><div class="nav-item"><a href="/work/index.html" class="nav-link">
  work
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="url" class="dropdown-title"><span class="title">url</span> <span class="arrow down"></span></button> <button type="button" aria-label="url" class="mobile-dropdown-title"><span class="title">url</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/other/config.html" class="nav-link">
  其他
</a></li><li class="dropdown-item"><!----> <a href="https://git.code.tencent.com/u/nampy" target="_blank" rel="noopener noreferrer" class="nav-link external">
  腾讯工蜂
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/willwxt" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="http://nbcb.icu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  导航首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>redis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/point/04cache/redis-structure.html#redis数据结构" class="sidebar-link">redis数据结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#string" class="sidebar-link">string</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#bitmap" class="sidebar-link">bitmap</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#hash" class="sidebar-link">hash</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#list" class="sidebar-link">list</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#set" class="sidebar-link">set</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#zset" class="sidebar-link">zset</a></li></ul></li><li><a href="/point/04cache/redis-structure.html#redis内部数据结构" class="sidebar-link">redis内部数据结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#研究目标" class="sidebar-link">研究目标</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#dict" class="sidebar-link">dict</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#sds" class="sidebar-link">sds</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#robj-redisobject" class="sidebar-link">robj(redisObject)</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#ziplist" class="sidebar-link">ziplist</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#quicklist" class="sidebar-link">quicklist</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#skiplist" class="sidebar-link">skiplist</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#intset" class="sidebar-link">intset</a></li></ul></li><li><a href="/point/04cache/redis-structure.html#redis工作模型" class="sidebar-link">redis工作模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#单线程worker-免去加锁的过程" class="sidebar-link">单线程worker, 免去加锁的过程</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#使用epoll进行io通信" class="sidebar-link">使用epoll进行IO通信</a></li></ul></li><li><a href="/point/04cache/redis-structure.html#redis持久化" class="sidebar-link">redis持久化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#rdb" class="sidebar-link">RDB</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#aof" class="sidebar-link">AOF</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#区别" class="sidebar-link">区别</a></li></ul></li><li><a href="/point/04cache/redis-structure.html#redis过期淘汰机制" class="sidebar-link">redis过期淘汰机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#volatile-表示在过期时间的key中做选择" class="sidebar-link">volatile: 表示在过期时间的key中做选择</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#noeviction" class="sidebar-link">noeviction</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#_100-要求解释lru和lfu的实现-区别" class="sidebar-link">100%要求解释lru和lfu的实现, 区别</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#redis的过期策略" class="sidebar-link">redis的过期策略</a></li></ul></li><li><a href="/point/04cache/redis-structure.html#redis分布式集群的常见形式" class="sidebar-link">redis分布式集群的常见形式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/point/04cache/redis-structure.html#分布式锁" class="sidebar-link">分布式锁</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/point/04cache/redis-structure.html#缓存击穿" class="sidebar-link">缓存击穿</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/point/04cache/redis-structure.html#缓存雪崩" class="sidebar-link">缓存雪崩</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/point/04cache/redis-structure.html#缓存一致性" class="sidebar-link">缓存一致性</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/point/04cache/redis-structure.html#常见问题" class="sidebar-link">常见问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#redis性能为什么高" class="sidebar-link">redis性能为什么高?</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#单线程的redis如何利用多核cpu机器" class="sidebar-link">单线程的redis如何利用多核cpu机器？</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#redis的缓存淘汰策略" class="sidebar-link">redis的缓存淘汰策略？</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#redis如何持久化数据" class="sidebar-link">redis如何持久化数据？</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#redis有哪几种数据结构" class="sidebar-link">redis有哪几种数据结构？</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#redis集群有哪几种形式" class="sidebar-link">redis集群有哪几种形式？</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#有海量key和value都比较小的数据-在redis中如何存储才更省内存" class="sidebar-link">有海量key和value都比较小的数据，在redis中如何存储才更省内存？</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#如何保证redis和db中的数据一致性" class="sidebar-link">如何保证redis和DB中的数据一致性？</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#如何解决缓存穿透和缓存雪崩" class="sidebar-link">如何解决缓存穿透和缓存雪崩？</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#如何用redis实现分布式锁" class="sidebar-link">如何用redis实现分布式锁？</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#redis对比memcached" class="sidebar-link">redis对比memcached</a></li><li class="sidebar-sub-header"><a href="/point/04cache/redis-structure.html#redis为什么用skiplist而不用平衡树" class="sidebar-link">Redis为什么用skiplist而不用平衡树</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="redis"><a href="#redis" class="header-anchor">#</a> redis</h1> <h2 id="redis数据结构"><a href="#redis数据结构" class="header-anchor">#</a> redis数据结构</h2> <p>使用者角度/Redis暴露的接口</p> <h3 id="string"><a href="#string" class="header-anchor">#</a> string</h3> <ul><li>string底层实现-动态字符串SDS</li> <li>子主题 2</li> <li>子主题 3</li></ul> <h3 id="bitmap"><a href="#bitmap" class="header-anchor">#</a> bitmap</h3> <h3 id="hash"><a href="#hash" class="header-anchor">#</a> hash</h3> <h3 id="list"><a href="#list" class="header-anchor">#</a> list</h3> <h3 id="set"><a href="#set" class="header-anchor">#</a> set</h3> <h3 id="zset"><a href="#zset" class="header-anchor">#</a> zset</h3> <h2 id="redis内部数据结构"><a href="#redis内部数据结构" class="header-anchor">#</a> redis内部数据结构</h2> <h3 id="研究目标"><a href="#研究目标" class="header-anchor">#</a> 研究目标</h3> <p>存储效率（memory efficiency）
快速响应时间（fast response time）
单线程（single-threaded）</p> <ul><li>节省内存, 压缩数据、减少内存碎片</li> <li>单个请求的响应时间要求很高, 有时可能与高吞吐量矛盾</li> <li>瓶颈在于内存访问和网络IO</li></ul> <h3 id="dict"><a href="#dict" class="header-anchor">#</a> dict</h3> <p>所谓的hashtable</p> <p>https://mp.weixin.qq.com/s/qFDOFr4HYpgUg-J_VCNvQw</p> <ul><li><p>dict概述</p> <ul><li>用于维护key-value映射关系, Redis中的一个db就用一个dict来维护;</li> <li>当hash结构的field较多, 就会采用dict存储;</li> <li>dict和skiplist配合使用来维护sorted set;</li> <li>基于哈希表的算法, 与传统哈希算法类似, 拥有loadfactor, rehash
特点是采用了增量式哈希incremental rehash:
避免一次性将所有key rehash, 而是将rehash操作分散到对dict各个增删改查操作中
避免rehash期间请求响应时间的剧烈增加</li></ul></li> <li><p>dict结构</p> <p>每个dict包含
两个dictht, dictht是一个存储dictEntry的数组, 平时只有ht[0]有效
dictType结构的指针type, 类似java的<T>
私有数据指针privdata
当前rehash索引 long rehashidx
遍历的个数int iterators</T></p> <ul><li><p>dictht ht[2]</p> <p>平时只有ht[0]有效, 只有在重哈希的过程中，ht[0]和ht[1]才都有效</p> <ul><li><p>dictEntry **table
dictEntry指针数组</p> <ul><li><p>dictEntry</p> <ul><li><p>void *key (可以指向任何类型)</p></li> <li><p>union v</p> <p>union {
void *val;
uint64_t;
int64_t;
double d;
} v;
当v是uint64_t、int64_t或double类型, 不再需要额外的存储, 这有利于减少内存碎片;
v也可以是void指针</p></li> <li><p>next</p></li></ul></li></ul></li> <li><p>unsigned long size
table的长度, 总为2的指数</p></li> <li><p>unsigned long sizemask
(size-1, 各位全1的数组, 用于取余)</p></li> <li><p>unsigned long used
记录dict中现有的数据个数</p></li> <li><p>(used/size的比值就是装载因子load factor)</p></li></ul></li> <li><p>dataType *type
有一堆函数指针</p> <ul><li>hashFunction, 计算hash值的</li> <li>keyDup和valDup, 拷贝函数(深拷贝)</li> <li>keyCompare, 比较函数, 查找key使用</li> <li>keyDestructor和valDestructor析构函数</li></ul></li> <li><p>void *privdata
私有数据指针</p> <ul><li>dictType的某些操作被调用时会传回给调用者</li></ul></li> <li><p>long rehashidx
当前rehash索引</p></li> <li><p>int iterators</p></li></ul></li> <li><p>dict方法</p> <ul><li><p>dict的创建(dictCreate)</p> <ul><li><ol><li>zmalloc(sizeof(*d)); 给dict分配空间</li></ol></li></ul></li></ul></li></ul> <ol start="2"><li><p>dictht中的table=NULL, 数组还未分配空间</p> <ul><li><p>dict的查找(dictFind)</p> <ul><li><p>如果正在进行rehash,
调用_dictRehashStep</p></li> <li><p>调用dictHashKey, 计算key的hash值</p> <ul><li>调用了dictType的hashFunction</li></ul></li> <li><p>在ht[0]查找,
找到直返回</p> <ul><li>根据hash值与sizemask按位与, 找到指定下标的dictEntry(链表),
调用dictCompareKeys在链表中逐个比较, (用到keyCompare)</li></ul></li> <li><p>如果ht[0]中未找到</p> <ul><li>判断是否rehash
是-在ht[1]中查找
否-返回null</li></ul></li></ul></li> <li><p>_dictRehashStep调用
dictRehash(*d, 1)
(将rehash向前推进1步)</p> <ul><li>每一步将ht[0]上一个dictEntry链表(bucket
移动到ht[1]上(rehashidx记录尚未迁移的ht[0]位置), 新位置根据ht[1]的sizemask重新计算</li> <li>rehashidx: 如果指向的bucket没有数据, 会向后遍历n*10步查找</li> <li>如果ht[0]上的数据都迁移到ht[1]上, 整个重哈希结束, ht[0]变成ht[1]的内容, 而ht[1]重置为空</li></ul></li> <li><p>dict的插入</p> <ul><li><p>dictAdd
val已存在会失败</p> <ul><li><p>dictAddRaw</p> <ul><li><p>_dictRehashStep 推进rehash</p></li> <li><p>_dictKeyIndex</p> <ul><li>寻找插入位置, 如果rehash, 查找ht[0]和ht[1]</li> <li>可能触发_dictExpandIfNeeded</li></ul></li> <li><p>如果正在rehash. 会把数据插入到ht[1]</p></li> <li><p>总是插入到bucket的dictEntry头部:
因为新数据被访问概率比较高</p></li></ul></li></ul></li> <li><p>dictReplace
会更新已存在的val</p> <ul><li><p>在dictAdd基础上实现</p> <ul><li>先调用dictAdd, 如果失败再find再setvalue</li></ul></li></ul></li></ul></li> <li><p>dict的删除dictDelete</p> <ul><li>_dictRehashStep 推进rehash</li> <li>ht[0]或两个数组中查找并删除并调用析构函数</li></ul></li></ul></li></ol> <h3 id="sds"><a href="#sds" class="header-anchor">#</a> sds</h3> <p>字符串</p> <p>Simple Dynamic String</p> <p>https://mp.weixin.qq.com/s/_uqWOC1Gau-yCja1fmTdqA</p> <ul><li><p>特点</p> <ul><li>可动态扩展内存, mutable</li> <li>二进制安全, 存储二进制数据</li> <li>与传统C语言字符串类型兼容</li></ul></li> <li><p>结构</p> <ul><li><p>5种类型header结构</p> <p>能让不同长度的字符串可以使用不同大小的header, 节省内存
#define SDS_TYPE_5  0
#define SDS_TYPE_8  1
#define SDS_TYPE_16 2
#define SDS_TYPE_32 3
#define SDS_TYPE_64 4</p> <ul><li><p>len: 表示字符串的真正长度</p></li> <li><p>alloc: 表示字符串的最大容量</p></li> <li><p>flags: 总是占用一个字节。</p> <p>其中的最低3个bit用来表示header的类型。header的类型共有5种，在sds.h中有常量定义。</p></li> <li><p>char buf[]: 表明flags后是一个字符数组</p></li> <li><p>sdshdr5与其它几个header结构不同</p> <p>sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。</p></li></ul></li> <li><p>字符串数组</p> <p>通常是最大容量+1, 因为要存放NULL结束符, 兼容传统C字符串</p></li> <li><p>通过字符串指针获取内存中header的位置</p> <ul><li><p>通过s1[-1]找到flags, 低3位解析出header的类型</p></li> <li><p>拥有header类型后调用SDS_HDR(8, s1) 定位到header指针</p> <p>在各个header的定义中使用了__attribute__ ((packed))，是为了让编译器以紧凑模式来分配内存, 保证
header和sds的数据部分紧紧前后相邻,
向低地址方向偏移1个字节的方式来获取flags</p></li></ul></li></ul></li> <li><p>结构优势</p> <ul><li>header和数据相邻, 减少内存碎片, 提高存储效率</li> <li>统一的char *表达, 兼容C, 可直接进行C函数调用</li></ul></li> <li><p>sds基础函数</p> <ul><li><p>sdslen(s) 求长度</p> <ul><li>字符串-&gt;flag-&gt;header类型-&gt;SDS_HDR-&gt;len</li></ul></li> <li><p>sdsReqType 不同size选用不同header</p> <p>通过sdsReqType的代码，很容易看到：
长度在0和2^5-1之间，选用SDS_TYPE_5类型的header
长度在2^5和2^8-1之间，选用SDS_TYPE_8类型的header
长度在2^8和2^16-1之间，选用SDS_TYPE_16类型的header
长度在2^16和2^32-1之间，选用SDS_TYPE_32类型的header
长度大于2^32的选用SDS_TYPE_64类型的header。能表示的最大长度为2^64-1
注：sdsReqType的实现代码，直到3.2.0，它在长度边界值上都一直存在问题，直到最近3.2 branch上的commit 6032340才修复。</p></li> <li><p>sdscatlen(s, <em>t, len)
将</em>t指向的数据(长度len)追加到s后</p> <ul><li>子主题 1</li></ul></li> <li><p>sdsMakeRoomFor(s, addlen)
保证字符串s有足够空间追加(len长度)</p> <ul><li><p>如果原字符串空间够用, 直接返回</p></li> <li><p>如果需要分配空间, 会比实际请求多分配一些, 以备接下来继续追加</p> <p>它在字符串已经比较长的情况下要至少多分配SDS_MAX_PREALLOC个字节，这个常量在sds.h中定义为(1024*1024)=1MB。</p></li> <li><p>按分配后的空间大小，可能需要更换header类型</p> <p>（原来header的alloc字段太短，表达不了增加后的容量）</p></li> <li><p>如果需要更换header, 整个sds重新分配, 数据搬迁</p> <p>如果需要更换header，那么整个字符串空间（包括header）都需要重新分配（s_malloc），并拷贝原来的数据到新的位置</p></li> <li><p>如果不需要更换header, 尝试原地址上重新分配; 成功直接返回, 失败重新分配新地址+数据搬迁</p> <p>如果不需要更换header（原来的header够用），那么调用一个比较特殊的s_realloc，试图在原来的地址上重新分配空间
如果原来的地址位置有足够的空余空间完成重新分配，那么它返回的新地址与传入的旧地址相同；否则，它分配新的地址块，并进行数据搬迁</p></li></ul></li> <li><p>sdscatlen函数使用模式</p> <p>调用它的时候，传入一个旧的sds变量，然后它返回一个新的sds变量。由于它的内部实现可能会造成地址变化，因此调用者在调用完之后，原来旧的变量就失效了，而都应该用新返回的变量来替换。不仅仅是sdscatlen函数，sds中的其它函数（比如sdscpy、sdstrim、sdsjoin等），还有Redis中其它一些能自动扩展内存的数据结构（如ziplist），也都是同样的使用模式。</p></li></ul></li> <li><p>sds创建和销毁</p> <ul><li><p>sdsnewlen(*init, initlen)</p> <ul><li><p>创建长度为initlen的sds字符串, 用*init的数据初始化sds字符串</p> <p>如果init为NULL，那么使用全0来初始化数据。</p></li> <li><p>如果创建长度为0的空字符串, 很可能接下来的操作是追加, 所以创建SDS_TYPE_8类型的header</p></li> <li><p>需要的内存一次性进行分配</p> <p>其中包含三部分：header、数据、最后的多余字节（hdrlen+initlen+1）</p></li> <li><p>初始化的sds字符串数据最后会追加一个NULL结束符（s[initlen] = ‘\0’）</p></li></ul></li> <li><p>sdsfree</p> <ul><li>内存整体释放, 将header起始指针传给s_free</li></ul></li></ul></li> <li><p>string和sds的关系</p> <ul><li>append, setbit, getrange 使用 sds 实现</li> <li>当string为数值,incr/decr/setbit/getrange,就不是sds实现</li></ul></li></ul> <h3 id="robj-redisobject"><a href="#robj-redisobject" class="header-anchor">#</a> robj(redisObject)</h3> <p>可以表示多种类型</p> <p>https://mp.weixin.qq.com/s/Jlv6AgaO4QrCXvjr6RipIQ</p> <p>为多种数据类型提供一种统一的表示方式。
允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。
支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。</p> <ul><li><p>结构</p> <ul><li><p>type 对象的数据类型(api)</p> <p>OBJ_STRING,
OBJ_LIST,
OBJ_SET,
OBJ_ZSET,
OBJ_HASH</p> <ul><li><p>同一type可能不同encoding</p> <p>当type = OBJ_STRING的时候，表示这个robj存储的是一个string，这时encoding可以是下面3种中的一种：
OBJ_ENCODING_RAW: string采用原生的表示方式，即用sds来表示。
OBJ_ENCODING_INT: string采用数字的表示方式，实际上是一个long型。
OBJ_ENCODING_EMBSTR: string采用一种特殊的嵌入式的sds来表示。</p> <ul><li><p>string可能是raw, int, embstr
hash可能是dict, ziplist</p> <p>string默认不为double, incrbyfloat是在sds基础上做的浮点运算</p></li></ul></li></ul></li> <li><p>encoding 对象的内部表示方式</p> <p>OBJ_ENCODING_RAW: 最原生的表示方式。其实只有string类型才会用这个encoding值（表示成sds）。
OBJ_ENCODING_INT: 表示成数字。实际用long表示。
OBJ_ENCODING_HT: 表示成dict。
OBJ_ENCODING_ZIPMAP: 是个旧的表示方式，已不再用。在小于Redis 2.6的版本中才有。
OBJ_ENCODING_LINKEDLIST: 也是个旧的表示方式，已不再用。
OBJ_ENCODING_ZIPLIST: 表示成ziplist。
OBJ_ENCODING_INTSET: 表示成intset。用于set数据结构。
OBJ_ENCODING_SKIPLIST: 表示成skiplist。用于sorted set数据结构。
OBJ_ENCODING_EMBSTR: 表示成一种特殊的嵌入式的sds。
OBJ_ENCODING_QUICKLIST: 表示成quicklist。用于list数据结构。</p> <ul><li>EMBSTR压缩版sds(存储), RAW原版(操作)</li></ul></li> <li><p>lru 做LRU替换算法用</p></li> <li><p>refcount 引用计数</p> <ul><li>引用计数器归零会将robj内存释放</li></ul></li> <li><p>ptr 数据指针</p> <ul><li>指向真正的数据如 sds</li></ul></li></ul></li> <li><p>tryObjectEncoding(robj)
编码</p> <p>set命令首先将接收到的value值（string类型）表示成一个type = OBJ_STRING并且encoding = OBJ_ENCODING_RAW的对象，然后在存入内部存储之前先执行一个编码过程，试图将它表示成另一种更节省内存的encoding方式。
这一过程的核心代码，tryObjectEncoding函数</p> <ul><li><ol><li>检查type, 确保string</li></ol></li></ul></li></ul> <ol start="2"><li><p>检查encoding, RAW和EMBSTR可进一步编码</p></li> <li><p>检查refcount, 不对共享对象编码</p></li> <li><p>试图转成64位long()</p> <div class="language- extra-class"><pre><code> - 成功, 不要求LRU替换&amp;&amp;数字值较小, 使用预存的小数字对象; 否则转换encoding并直接存在robj的ptr数据指针处
 - 失败, 如果长度足够小, 转成EMPSTR; 
</code></pre></div></li></ol> <p>不足够小, 如果空余字节过多, 释放空余字节</p> <div class="language- extra-class"><pre><code>		- createEmbeddedStringObject
	
		  对sds重新分配内存, 将robj和sds放在连续的内存块中, (对于短字符串)利于减少内存碎片
	
		- sdsRemoveFreeSpace
</code></pre></div><ul><li><p>getDecodedObject(robj)
解码</p> <p>执行get, 需要做编码过程相反的操作</p> <ul><li>sds的两个类型对象直接返回</li> <li>若为数字的robj, 将long转为十进制字符串形式, 调用createStringObject转为EMBSTR(sds)</li></ul></li> <li><p>总结</p> <ul><li>string类型是以robj表示,
有3种encoding, INT, EMBSTR, RAW</li> <li>INT类型的可以直接运算, 而EMBSTR和RAW需要实时转换成long再运算(如果转不了就报错)</li> <li>append, setbit, getrange 会先把INT转成sds字符串操作(一般是RAW)</li></ul></li></ul> <h3 id="ziplist"><a href="#ziplist" class="header-anchor">#</a> ziplist</h3> <p>特殊的&quot;双向链表&quot;</p> <p>ziplist将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存</p> <ul><li><p>结构</p> <ul><li><p>zlbytes, ziplist占用的字节总数</p></li> <li><p>zltail, 最后一项偏移量</p></li> <li><p>zllen, 数据项（entry）的个数</p></li> <li><p>entry 数据项</p> <ul><li><p>prevrawlen, 前一个数据长度</p> <ul><li>1字节(254)或5字节整形</li></ul></li> <li><p>len, data长度</p> <ul><li><p>根据len第一个字节分成多种情况</p> <p>|00pppppp| - 1 byte。第1个字节最高两个bit是00，那么<len>字段只有1个字节，剩余的6个bit用来表示长度值，最高可以表示63 (2^6-1)。
|01pppppp|qqqqqqqq| - 2 bytes。第1个字节最高两个bit是01，那么<len>字段占2个字节，总共有14个bit用来表示长度值，最高可以表示16383 (2^14-1)。
|10__|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes。第1个字节最高两个bit是10，那么len字段占5个字节，总共使用32个bit来表示长度值（6个bit舍弃不用），最高可以表示2^32-1。需要注意的是：在前三种情况下，<data>都是按字符串来存储的；从下面第4种情况开始，<data>开始变为按整数来存储了。
|11000000| - 1 byte。<len>字段占用1个字节，值为0xC0，后面的数据<data>存储为2个字节的int16_t类型。
|11010000| - 1 byte。<len>字段占用1个字节，值为0xD0，后面的数据<data>存储为4个字节的int32_t类型。
|11100000| - 1 byte。<len>字段占用1个字节，值为0xE0，后面的数据<data>存储为8个字节的int64_t类型。
|11110000| - 1 byte。<len>字段占用1个字节，值为0xF0，后面的数据<data>存储为3个字节长的整数。
|11111110| - 1 byte。<len>字段占用1个字节，值为0xFE，后面的数据<data>存储为1个字节的整数。
|1111xxxx| - - (xxxx的值在0001和1101之间)。这是一种特殊情况，xxxx从1到13一共13个值，这时就用这13个值来表示真正的数据。注意，这里是表示真正的数据，而不是数据长度了。也就是说，在这种情况下，后面不再需要一个单独的<data>字段来表示真正的数据了，而是<len>和<data>合二为一了。另外，由于xxxx只能取0001和1101这13个值了（其它可能的值和其它情况冲突了，比如0000和1110分别同前面第7种第8种情况冲突，1111跟结束标记冲突），而小数值应该从0开始，因此这13个值分别表示0到12，即xxxx的值减去1才是它所要表示的那个整数数据的值。</data></len></data></data></len></data></len></data></len></data></len></data></len></data></data></len></len></p></li></ul></li> <li><p>data</p></li></ul></li> <li><p>zlend, 结束标记, 值固定255</p></li> <li><p>小端（little endian）模式存储</p></li> <li><p>ziplist没用struct表达
而是简单的unsigned char *
因为本质上是块连续内存</p></li></ul></li> <li><p>接口</p> <p>unsigned char *ziplistNew(void);
unsigned char *ziplistMerge(unsigned char **first, unsigned char **second);
unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where);
unsigned char *ziplistIndex(unsigned char *zl, int index);
unsigned char *ziplistNext(unsigned char *zl, unsigned char *p);
unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p);
unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen);
unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p);
unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip);
unsigned int ziplistLen(unsigned char *zl);</p> <ul><li><p>ziplistnew, 创建一个空的ziplist</p> <p>ziplist的数据类型，没有用自定义的struct之类的来表达，而就是简单的unsigned char *。这是因为ziplist本质上就是一块连续内存，内部组成结构又是一个高度动态的设计（变长编码），也没法用一个固定的数据结构来表达。
ziplistNew: 创建一个空的ziplist（只包含<zlbytes><zltail><zllen><zlend>）。
ziplistMerge: 将两个ziplist合并成一个新的ziplist。
ziplistPush: 在ziplist的头部或尾端插入一段数据（产生一个新的数据项）。注意一下这个接口的返回值，是一个新的ziplist。调用方必须用这里返回的新的ziplist，替换之前传进来的旧的ziplist变量，而经过这个函数处理之后，原来旧的ziplist变量就失效了。为什么一个简单的插入操作会导致产生一个新的ziplist呢？这是因为ziplist是一块连续空间，对它的追加操作，会引发内存的realloc，因此ziplist的内存位置可能会发生变化。实际上，我们在之前介绍sds的文章中提到过类似这种接口使用模式（参见sdscatlen函数的说明）。
ziplistIndex: 返回index参数指定的数据项的内存位置。index可以是负数，表示从尾端向前进行索引。
ziplistNext和ziplistPrev分别返回一个ziplist中指定数据项p的后一项和前一项。
ziplistInsert: 在ziplist的任意数据项前面插入一个新的数据项。
ziplistDelete: 删除指定的数据项。
ziplistFind: 查找给定的数据（由vstr和vlen指定）。注意它有一个skip参数，表示查找的时候每次比较之间要跳过几个数据项。为什么会有这么一个参数呢？其实这个参数的主要用途是当用ziplist表示hash结构的时候，是按照一个field，一个value来依次存入ziplist的。也就是说，偶数索引的数据项存field，奇数索引的数据项存value。当按照field的值进行查找的时候，就需要把奇数项跳过去。
ziplistLen: 计算ziplist的长度（即包含数据项的个数）。</zlend></zllen></zltail></zlbytes></p></li> <li><p>ziplist插入</p> <ul><li><p>ziplistPush</p></li> <li><p>ziplistInsert</p></li> <li><p>__ziplistInsert</p> <p>unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen)</p> <ul><li><ol><li>在指定位置插入一段新的数据, 后面的数据向后移动</li></ol></li></ul></li></ul></li></ul></li></ul> <ol start="2"><li>计算插入前段数据的长度作为prevrawlen</li> <li>计算当前数据占用总字节数(数据部分尝试转整数)</li> <li>插入位置原来数据的prevrawlen可能变化</li> <li>计算ziplist空间, 调整内存空间, 并将数据插入</li></ol> <ul><li><p>hash数据类型与ziplist
优劣, 总结, 配置</p> <ul><li>field较少, value值较小的时候, hash采用ziplist实现; 反之使用dict</li> <li>&quot;存储一个对象, 使用hash比string节省内存&quot;?</li></ul></li></ul> <ol><li>把对象的属性存储到多个string key上(费)</li> <li>把对象序列化存到一个string(省)</li> <li>hash对于序列化的优势在于对属性的操作; 劣势在于数据过多会失去存储优势(dict实现)
<ul><li><p>hset key field value 会创建出 encoding为ziplist的hashOBJ</p></li> <li><p>ziplist和hash的转换关系?
配置中, 两个条件满足之一</p> <ul><li>hash-max-ziplist-entries 512
最大数据对 512 对</li> <li>hash-max-ziplist-value 64|
value最大长度</li></ul></li> <li><p>ziplist本来就设计为各个数据项挨在一起组成连续的内存空间，这种结构并不擅长做修改操作。
一旦数据发生改动，就会引发内存realloc，可能导致内存拷贝。</p></li></ul></li></ol> <h3 id="quicklist"><a href="#quicklist" class="header-anchor">#</a> quicklist</h3> <p>作为list实现</p> <ul><li><p>概述</p> <ul><li><p>A doubly linked list of ziplists</p></li> <li><p>双向链表: 地址不连续, 内存开销大
ziplist: 每次修改操作可能realloc</p></li> <li><p>quicklist是以ziplist为节点组成的双向链表</p> <ul><li>子主题 1</li></ul></li> <li><p>list-max-ziplist-size -2</p> <p>当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度:
当取负值的时候
-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb =&gt; 1024 bytes）
-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。
-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。
-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）
-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。</p></li> <li><p>list-compress-depth 0</p> <p>列表很长的时候, 中间的数据被访问的频率比较低
可以配置list-compress-depth项来将中间的数据节点进行压缩
0: 是个特殊值，表示都不压缩。这是Redis的默认值。
1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。
2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。
3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。</p> <ul><li>LZF压缩算法</li></ul></li></ul></li> <li><p>结构</p> <ul><li><p>quicklistNode</p> <ul><li><p>prev, next 指针</p></li> <li><p>zl 数据指针, 指向ziplist或LZF结构</p></li> <li><p>sz 表示zl指向的ziplist大小(*无视压缩)</p></li> <li><p>count 表示ziplist里的数据项个数</p> <ul><li><p>count字段这16bit是否够用?</p> <p>我们已经知道，ziplist大小受到list-max-ziplist-size参数的限制。按照正值和负值有两种情况：
当这个参数取正值的时候，就是恰好表示一个quicklistNode结构中zl所指向的ziplist所包含的数据项的最大值。list-max-ziplist-size参数是由quicklist结构的fill字段来存储的，而fill字段是16bit，所以它所能表达的值能够用16bit来表示。
当这个参数取负值的时候，能够表示的ziplist最大长度是64 Kb。而ziplist中每一个数据项，最少需要2个字节来表示：1个字节的prevrawlen，1个字节的data（len字段和data合二为一；详见上一篇）。所以，ziplist中数据项的个数不会超过32 K，用16bit来表达足够了。
实际上，在目前的quicklist的实现中，ziplist的大小还会受到另外的限制，根本不会达到这里所分析的最大值。</p></li></ul></li> <li><p>encoding 是否压缩了</p></li> <li><p>container 预留字段, 表示容器类型</p></li> <li><p>recompress</p> <ul><li>(若使用index解压查看数据)需要再次压缩的标记</li></ul></li></ul></li> <li><p>quicklistLZF</p> <ul><li>sz: 压缩后大小
compressd: 柔性数组 flexible array member</li></ul></li> <li><p>quicklist</p> <ul><li>head: 指向头节点（左侧第一个节点）的指针。</li> <li>tail: 指向尾节点（右侧第一个节点）的指针。</li> <li>count: 所有ziplist数据项的个数总和。</li> <li>len: quicklist节点的个数。</li> <li>fill: 16bit, ziplist大小设置, 存放list-max-ziplist-size参数值</li> <li>compress: 16bit, 节点压缩深度设置, list-compress-depth参数值</li></ul></li></ul></li> <li><p>操作</p> <ul><li><p>lpush操作会先创建quicklist
调用quicklistCreate</p> <ul><li>创建一个空的quicklist</li></ul></li> <li><p>quicklistPush</p> <ul><li>_quicklistNodeAllowInsert
如果头/尾结点ziplist大小没有超过限制
直接插入到ziplist中
如果太大, 新建Node节点, 并加入双向链表
(_quicklistInsertNodeAfter)</li></ul></li> <li><p>pop操作 quicklistPopCustom</p></li> <li><p>quicklistInsertAfter, quicklistInsertBefore
指定下标的插入</p> <p>当插入位置所在的ziplist大小没有超过限制时，直接插入到ziplist中就好了；
当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小没有超过限制，那么就转而插入到相邻的那个quicklist链表节点的ziplist中；
当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小也超过限制，这时需要新创建一个quicklist链表节点插入。
对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。</p></li> <li><p>quicklistSetOptions用于设置配置参数</p></li></ul></li></ul> <h3 id="skiplist"><a href="#skiplist" class="header-anchor">#</a> skiplist</h3> <ul><li><p>概述</p> <ul><li><p>有序链表-&gt;多层链表-&gt;skiplist</p> <p>有序链表, O(n)顺序查找
多层链表: 每相邻两个节点增加一个指针, 指向下下个节点, 可以以两倍速度查找, 再依次增加指针, 可以达到logn.问题在于多层链表的层数结构固定, 新增删除需要维护很多节点O(n)
跳跃表: 对层数不做固定, 随机生成, 这样新增或删除只需要维护自身节点O(1), 查找效率能有O(logn)</p> <ul><li><p>层数伪随机</p> <p>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。
如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。
节点最大的层数不允许超过一个最大值，记为MaxLevel。
redis中, 这两个参数为
p = 1/4
MaxLevel = 32
平均指针1.33, 平均时间复杂度log(n)</p></li> <li><p>skiplist算法性能分析(见博客)</p></li> <li><p>skiplist和平衡树, 哈希表</p> <ul><li><ol><li>范围查找, 哈希表弱, 平衡树复杂, skiplist最快</li></ol></li></ul></li></ul></li></ul></li></ul> <ol start="2"><li><p>插入和删除, 平衡树复杂, skiplist简单</p></li> <li><p>内存占用, skiplist占优</p></li> <li><p>查找, 哈希表最优</p></li> <li><p>算法实现难度, skiplist易于平衡树</p> <ul><li><p>sorted set / zset</p> <ul><li>数据较少-ziplist; 数据较多-dict+skiplist</li></ul></li> <li><p>对skiplist做改造, 允许重复, 计算排名..</p></li> <li><p>作为ziplist时, 查找为顺序查找</p></li></ul></li></ol> <ul><li><p>结构</p> <ul><li><p>zskiplistNode</p> <ul><li><p>robj sds编码</p></li> <li><p>score 分数</p></li> <li><p>backward</p></li> <li><p>level[] 存放各层</p> <ul><li><p>forward 指针</p></li> <li><p>span 指针跨越多少节点, 计算排名</p> <ul><li>查找数据时不断累加span, 可以获得排名</li> <li>按排名查找时只要累加span使其不超过目标值</li></ul></li></ul></li></ul></li> <li><p>zskiplist</p> <ul><li>head和tail</li> <li>length 链表长度</li> <li>level 层数最大值</li></ul></li> <li><p>zset</p> <ul><li>dict + zskiplist</li></ul></li></ul></li> <li><p>操作</p> <ul><li><p>满足之一会转成zset
元素个数, val长度</p> <ul><li>zset-max-ziplist-entries 128</li> <li>zset-max-ziplist-value 64</li></ul></li></ul></li></ul> <h3 id="intset"><a href="#intset" class="header-anchor">#</a> intset</h3> <ul><li><p>概述</p> <ul><li><p>set结构数据较少intset, 数据较多用dict实现
若添加了非int的直接转为dict实现</p> <ul><li>set-max-intset-entries
集合元素个数</li></ul></li> <li><p>intset是一个由整数组成的有序集合, 通过二分查找确认是否存在</p> <p>便于在上面进行二分查找，用于快速地判断一个元素是否属于这个集合。
它在内存分配上与ziplist有些类似
对于大整数和小整数（按绝对值）采取了不同的编码，尽量优化内存</p></li></ul></li> <li><p>结构</p> <ul><li><p>encoding 数据编码</p> <p>表示intset中的每个数据元素用几个字节来存储
INTSET_ENC_INT16表示2个字节
INTSET_ENC_INT32表示4个字节
INTSET_ENC_INT64表示8个字节</p> <ul><li>会随着数据的添加而改变</li></ul></li> <li><p>length 元素个数</p></li> <li><p>contents[] 柔性数组, 数据元素</p> <p>数组的总长度等于encoding * length</p></li></ul></li> <li><p>操作</p> <ul><li><p>intsetFind</p> <ul><li><p>_intsetValueEncoding 查找val的数据编码</p></li> <li><p>若在数据范围之内, 调用intsetSearch二分查找</p> <p>intsetSearch是对于二分查找算法的一个实现，它大致分为三个部分：
特殊处理intset为空的情况。
特殊处理两个边界情况：当要查找的value比最后一个元素还要大或者比第一个元素还要小的时候。实际上，这两部分的特殊处理，在二分查找中并不是必须的，但它们在这里提供了特殊情况下快速失败的可能。
真正执行二分查找过程。注意：如果最后没找到，插入位置在min指定的位置。</p></li></ul></li> <li><p>intsetAdd</p> <ul><li>查编码, 比当前编码大直接升级编码并插入</li> <li>二分查找, 如果没找到进行内存扩展(数据拷贝+插入)</li></ul></li> <li><p>并交差集</p> <ul><li><p>sinterGenericCommand 交集</p> <p>检查各个集合，对于不存在的集合当做空集来处理。一旦出现空集，最终的交集就是空集。
对各个集合按照元素个数由少到多进行排序。这个排序有利于后面计算的时候从最小的集合开始，需要处理的元素个数较少。
对排序后第一个集合（也就是最小集合）进行遍历，对于它的每一个元素，依次在后面的所有集合中进行查找。只有在所有集合中都能找到的元素，才加入到最后的结果集合中。</p></li> <li><p>sunionDiffGenericCommand</p> <ul><li><p>并集</p> <p>计算并集最简单，只需要遍历所有集合，将每一个元素都添加到最后的结果集合中。向集合中添加元素会自动去重</p></li> <li><p>差集</p> <p>计算差集有两种可能的算法，它们的时间复杂度有所区别。
第一种算法：
对第一个集合进行遍历，对于它的每一个元素，依次在后面的所有集合中进行查找。只有在所有集合中都找不到的元素，才加入到最后的结果集合中。</p> <p>这种算法的时间复杂度为O(N*M)，其中N是第一个集合的元素个数，M是集合数目。
第二种算法：
将第一个集合的所有元素都加入到一个中间集合中。
遍历后面所有的集合，对于碰到的每一个元素，从中间集合中删掉它。
最后中间集合剩下的元素就构成了差集。
这种算法的时间复杂度为O(N)，其中N是所有集合的元素个数总和。</p> <p>在计算差集的开始部分，会先分别估算一下两种算法预期的时间复杂度，然后选择复杂度低的算法来进行运算。还有两点需要注意：
在一定程度上优先选择第一种算法，因为它涉及到的操作比较少，只用添加，而第二种算法要先添加再删除。
如果选择了第一种算法，那么在执行该算法之前，Redis的实现中对于第二个集合之后的所有集合，按照元素个数由多到少进行了排序。这个排序有利于以更大的概率查找到元素，从而更快地结束查找。</p></li></ul></li></ul></li></ul></li></ul> <h2 id="redis工作模型"><a href="#redis工作模型" class="header-anchor">#</a> redis工作模型</h2> <h3 id="单线程worker-免去加锁的过程"><a href="#单线程worker-免去加锁的过程" class="header-anchor">#</a> 单线程worker, 免去加锁的过程</h3> <ul><li>简化了数据结构和算法的实现</li></ul> <h3 id="使用epoll进行io通信"><a href="#使用epoll进行io通信" class="header-anchor">#</a> 使用epoll进行IO通信</h3> <ul><li>异步IO和pipeline等机制来实现高速的并发访问</li></ul> <h2 id="redis持久化"><a href="#redis持久化" class="header-anchor">#</a> redis持久化</h2> <h3 id="rdb"><a href="#rdb" class="header-anchor">#</a> RDB</h3> <ul><li><p>RedisDB快照</p> <ul><li>生成整个Redis的快照, save阻塞不提供服务, bgsave子线程非阻塞, copyonwrite机制</li></ul></li></ul> <h3 id="aof"><a href="#aof" class="header-anchor">#</a> AOF</h3> <ul><li><p>AppendOnlyFile日志</p> <ul><li>将redis的操作记录在文件中, fsync由操作系统保存</li></ul></li> <li><p>重写</p> <ul><li>解决AOF日志的无限增加, 合并命令</li> <li>重写的两个参数:
1.当AOF文件大小超过了上次重写的文件大小的百分之多少时进行重写
2.文件大小超过多少才允许重写</li></ul></li></ul> <h3 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h3> <ul><li><ol><li>AOF</li></ol></li></ul> <h2 id="redis过期淘汰机制"><a href="#redis过期淘汰机制" class="header-anchor">#</a> redis过期淘汰机制</h2> <h3 id="volatile-表示在过期时间的key中做选择"><a href="#volatile-表示在过期时间的key中做选择" class="header-anchor">#</a> volatile: 表示在过期时间的key中做选择</h3> <p>allkeys: 在所有key中做选择
lru 移除最久未使用的
random 完全随机
ttl 选择最先过期的</p> <ul><li>volatile-lru</li> <li>volatile-ttl</li> <li>volatile-random</li> <li>allkeys-lru</li> <li>allkeys-random</li></ul> <h3 id="noeviction"><a href="#noeviction" class="header-anchor">#</a> noeviction</h3> <ul><li>不移除任何数据,返回一个写错误</li></ul> <h3 id="_100-要求解释lru和lfu的实现-区别"><a href="#_100-要求解释lru和lfu的实现-区别" class="header-anchor">#</a> 100%要求解释lru和lfu的实现, 区别</h3> <h3 id="redis的过期策略"><a href="#redis的过期策略" class="header-anchor">#</a> redis的过期策略</h3> <ul><li>定期删除</li> <li>懒删除</li> <li>1.首先遍历每个db进行定期删除,按照策略删除一部分key,保证过程中不占用太多资源
2.访问key时顺便查看过期时间,如果过期直接删除</li> <li>具体流程是,随机抽样(expire字典表中)一些(10到20)key,过期的key在抽样中如果超过25%,进行下一轮抽样和删除,直到低于25%</li></ul> <h2 id="redis分布式集群的常见形式"><a href="#redis分布式集群的常见形式" class="header-anchor">#</a> redis分布式集群的常见形式</h2> <h2 id="分布式锁"><a href="#分布式锁" class="header-anchor">#</a> 分布式锁</h2> <h2 id="缓存击穿"><a href="#缓存击穿" class="header-anchor">#</a> 缓存击穿</h2> <h2 id="缓存雪崩"><a href="#缓存雪崩" class="header-anchor">#</a> 缓存雪崩</h2> <h2 id="缓存一致性"><a href="#缓存一致性" class="header-anchor">#</a> 缓存一致性</h2> <h2 id="常见问题"><a href="#常见问题" class="header-anchor">#</a> 常见问题</h2> <h3 id="redis性能为什么高"><a href="#redis性能为什么高" class="header-anchor">#</a> redis性能为什么高?</h3> <h3 id="单线程的redis如何利用多核cpu机器"><a href="#单线程的redis如何利用多核cpu机器" class="header-anchor">#</a> 单线程的redis如何利用多核cpu机器？</h3> <h3 id="redis的缓存淘汰策略"><a href="#redis的缓存淘汰策略" class="header-anchor">#</a> redis的缓存淘汰策略？</h3> <h3 id="redis如何持久化数据"><a href="#redis如何持久化数据" class="header-anchor">#</a> redis如何持久化数据？</h3> <h3 id="redis有哪几种数据结构"><a href="#redis有哪几种数据结构" class="header-anchor">#</a> redis有哪几种数据结构？</h3> <h3 id="redis集群有哪几种形式"><a href="#redis集群有哪几种形式" class="header-anchor">#</a> redis集群有哪几种形式？</h3> <h3 id="有海量key和value都比较小的数据-在redis中如何存储才更省内存"><a href="#有海量key和value都比较小的数据-在redis中如何存储才更省内存" class="header-anchor">#</a> 有海量key和value都比较小的数据，在redis中如何存储才更省内存？</h3> <h3 id="如何保证redis和db中的数据一致性"><a href="#如何保证redis和db中的数据一致性" class="header-anchor">#</a> 如何保证redis和DB中的数据一致性？</h3> <h3 id="如何解决缓存穿透和缓存雪崩"><a href="#如何解决缓存穿透和缓存雪崩" class="header-anchor">#</a> 如何解决缓存穿透和缓存雪崩？</h3> <h3 id="如何用redis实现分布式锁"><a href="#如何用redis实现分布式锁" class="header-anchor">#</a> 如何用redis实现分布式锁？</h3> <h3 id="redis对比memcached"><a href="#redis对比memcached" class="header-anchor">#</a> redis对比memcached</h3> <p>1.计算向数据移动
2.mem的value没有类型概念,一般存json格式的字符串, redis可以存各种类型,并且每种类型提供了一系列操作api
3.Redis可以持久化</p> <h3 id="redis为什么用skiplist而不用平衡树"><a href="#redis为什么用skiplist而不用平衡树" class="header-anchor">#</a> Redis为什么用skiplist而不用平衡树</h3> <ol><li>内存占用小, 比起b树</li> <li>范围查找快</li> <li>易于实现</li></ol></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">6/18/2021, 6:53:51 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.42575a28.js" defer></script><script src="/assets/js/2.0d7d09b8.js" defer></script><script src="/assets/js/42.60b85cdf.js" defer></script>
  </body>
</html>
