<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Kafka | SUCKED BloG</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/logo.ico">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.35bcedcf.css" as="style"><link rel="preload" href="/assets/js/app.42575a28.js" as="script"><link rel="preload" href="/assets/js/2.0d7d09b8.js" as="script"><link rel="preload" href="/assets/js/44.786fc51f.js" as="script"><link rel="prefetch" href="/assets/js/10.1a30ebe5.js"><link rel="prefetch" href="/assets/js/100.022f696a.js"><link rel="prefetch" href="/assets/js/101.06eb0acb.js"><link rel="prefetch" href="/assets/js/102.e944c220.js"><link rel="prefetch" href="/assets/js/103.45b9da9a.js"><link rel="prefetch" href="/assets/js/104.cf53f5d1.js"><link rel="prefetch" href="/assets/js/105.200d7fe5.js"><link rel="prefetch" href="/assets/js/106.a0cc3502.js"><link rel="prefetch" href="/assets/js/107.4a71d17e.js"><link rel="prefetch" href="/assets/js/108.d7a39a75.js"><link rel="prefetch" href="/assets/js/109.35619cf9.js"><link rel="prefetch" href="/assets/js/11.f78ae8b3.js"><link rel="prefetch" href="/assets/js/110.f667d72e.js"><link rel="prefetch" href="/assets/js/111.de83ce6f.js"><link rel="prefetch" href="/assets/js/112.417d40bf.js"><link rel="prefetch" href="/assets/js/113.0f26c1ca.js"><link rel="prefetch" href="/assets/js/114.c7014acb.js"><link rel="prefetch" href="/assets/js/115.b502c0f1.js"><link rel="prefetch" href="/assets/js/116.10fb230e.js"><link rel="prefetch" href="/assets/js/117.f7cb9e2a.js"><link rel="prefetch" href="/assets/js/118.978d3075.js"><link rel="prefetch" href="/assets/js/119.09272191.js"><link rel="prefetch" href="/assets/js/12.140aa2af.js"><link rel="prefetch" href="/assets/js/120.32b5dbd7.js"><link rel="prefetch" href="/assets/js/121.8d618bbb.js"><link rel="prefetch" href="/assets/js/122.dcd4190d.js"><link rel="prefetch" href="/assets/js/123.2ee061d1.js"><link rel="prefetch" href="/assets/js/124.5a3760a7.js"><link rel="prefetch" href="/assets/js/125.a874a4bc.js"><link rel="prefetch" href="/assets/js/126.c6c6b7e6.js"><link rel="prefetch" href="/assets/js/127.38c35051.js"><link rel="prefetch" href="/assets/js/128.8d775ac8.js"><link rel="prefetch" href="/assets/js/129.6100ddb1.js"><link rel="prefetch" href="/assets/js/13.b2a6e590.js"><link rel="prefetch" href="/assets/js/130.9a83da2a.js"><link rel="prefetch" href="/assets/js/131.22de7670.js"><link rel="prefetch" href="/assets/js/132.f88798bf.js"><link rel="prefetch" href="/assets/js/133.925bbfed.js"><link rel="prefetch" href="/assets/js/134.481fad71.js"><link rel="prefetch" href="/assets/js/135.c3efb09b.js"><link rel="prefetch" href="/assets/js/136.758c447a.js"><link rel="prefetch" href="/assets/js/137.dcde1032.js"><link rel="prefetch" href="/assets/js/138.616a346b.js"><link rel="prefetch" href="/assets/js/139.b58dd07f.js"><link rel="prefetch" href="/assets/js/14.15374560.js"><link rel="prefetch" href="/assets/js/140.62b4c7ea.js"><link rel="prefetch" href="/assets/js/15.ffd155fa.js"><link rel="prefetch" href="/assets/js/16.feb1b022.js"><link rel="prefetch" href="/assets/js/17.6d491eb6.js"><link rel="prefetch" href="/assets/js/18.03ddaa95.js"><link rel="prefetch" href="/assets/js/19.021bbcc8.js"><link rel="prefetch" href="/assets/js/20.8aa708b0.js"><link rel="prefetch" href="/assets/js/21.59d7a21e.js"><link rel="prefetch" href="/assets/js/22.21597439.js"><link rel="prefetch" href="/assets/js/23.77303f0b.js"><link rel="prefetch" href="/assets/js/24.0789ed5b.js"><link rel="prefetch" href="/assets/js/25.244a12a8.js"><link rel="prefetch" href="/assets/js/26.a6ee95e4.js"><link rel="prefetch" href="/assets/js/27.9e0f0e9d.js"><link rel="prefetch" href="/assets/js/28.189031c5.js"><link rel="prefetch" href="/assets/js/29.b3100d33.js"><link rel="prefetch" href="/assets/js/3.2a5d4cd5.js"><link rel="prefetch" href="/assets/js/30.fe8fe8c0.js"><link rel="prefetch" href="/assets/js/31.86fec3f7.js"><link rel="prefetch" href="/assets/js/32.24cac061.js"><link rel="prefetch" href="/assets/js/33.f1db2ed0.js"><link rel="prefetch" href="/assets/js/34.c220692f.js"><link rel="prefetch" href="/assets/js/35.9e7b4779.js"><link rel="prefetch" href="/assets/js/36.0cb1d1bc.js"><link rel="prefetch" href="/assets/js/37.7d1fcf79.js"><link rel="prefetch" href="/assets/js/38.bc9bc4b3.js"><link rel="prefetch" href="/assets/js/39.10801a2a.js"><link rel="prefetch" href="/assets/js/4.b4d9a5aa.js"><link rel="prefetch" href="/assets/js/40.c980543d.js"><link rel="prefetch" href="/assets/js/41.3f4581d8.js"><link rel="prefetch" href="/assets/js/42.60b85cdf.js"><link rel="prefetch" href="/assets/js/43.1338528d.js"><link rel="prefetch" href="/assets/js/45.d65f6744.js"><link rel="prefetch" href="/assets/js/46.543c2b26.js"><link rel="prefetch" href="/assets/js/47.59f19ed2.js"><link rel="prefetch" href="/assets/js/48.60de6b25.js"><link rel="prefetch" href="/assets/js/49.f3df62ef.js"><link rel="prefetch" href="/assets/js/5.013522c1.js"><link rel="prefetch" href="/assets/js/50.fd9871d6.js"><link rel="prefetch" href="/assets/js/51.1fb1863e.js"><link rel="prefetch" href="/assets/js/52.c06ce3f3.js"><link rel="prefetch" href="/assets/js/53.a3d55203.js"><link rel="prefetch" href="/assets/js/54.89ac64bc.js"><link rel="prefetch" href="/assets/js/55.ccf38d1e.js"><link rel="prefetch" href="/assets/js/56.ffb8595b.js"><link rel="prefetch" href="/assets/js/57.5f1bd695.js"><link rel="prefetch" href="/assets/js/58.7463616d.js"><link rel="prefetch" href="/assets/js/59.ea4eb5dd.js"><link rel="prefetch" href="/assets/js/6.72ad7c85.js"><link rel="prefetch" href="/assets/js/60.a2add219.js"><link rel="prefetch" href="/assets/js/61.3eae0362.js"><link rel="prefetch" href="/assets/js/62.801d1658.js"><link rel="prefetch" href="/assets/js/63.b47a17bb.js"><link rel="prefetch" href="/assets/js/64.d5e2bdea.js"><link rel="prefetch" href="/assets/js/65.24d540f4.js"><link rel="prefetch" href="/assets/js/66.09a1ae52.js"><link rel="prefetch" href="/assets/js/67.75bd38e7.js"><link rel="prefetch" href="/assets/js/68.1fe6956e.js"><link rel="prefetch" href="/assets/js/69.d3306c2d.js"><link rel="prefetch" href="/assets/js/7.60760bb7.js"><link rel="prefetch" href="/assets/js/70.95aa4503.js"><link rel="prefetch" href="/assets/js/71.7065ebf0.js"><link rel="prefetch" href="/assets/js/72.55ae5081.js"><link rel="prefetch" href="/assets/js/73.c7624eee.js"><link rel="prefetch" href="/assets/js/74.63bcc7bd.js"><link rel="prefetch" href="/assets/js/75.e2731e20.js"><link rel="prefetch" href="/assets/js/76.1711af80.js"><link rel="prefetch" href="/assets/js/77.f1c4e2d3.js"><link rel="prefetch" href="/assets/js/78.900bc856.js"><link rel="prefetch" href="/assets/js/79.a1b8c47b.js"><link rel="prefetch" href="/assets/js/8.0c261cf2.js"><link rel="prefetch" href="/assets/js/80.7cf435bf.js"><link rel="prefetch" href="/assets/js/81.fa33b2af.js"><link rel="prefetch" href="/assets/js/82.cdabd386.js"><link rel="prefetch" href="/assets/js/83.879fc50c.js"><link rel="prefetch" href="/assets/js/84.7e460788.js"><link rel="prefetch" href="/assets/js/85.339356d5.js"><link rel="prefetch" href="/assets/js/86.d526418c.js"><link rel="prefetch" href="/assets/js/87.12877e38.js"><link rel="prefetch" href="/assets/js/88.d5a7d193.js"><link rel="prefetch" href="/assets/js/89.2f4a62c2.js"><link rel="prefetch" href="/assets/js/9.50eda380.js"><link rel="prefetch" href="/assets/js/90.6d83f5bf.js"><link rel="prefetch" href="/assets/js/91.f3364825.js"><link rel="prefetch" href="/assets/js/92.158fcc7a.js"><link rel="prefetch" href="/assets/js/93.0c4e5f88.js"><link rel="prefetch" href="/assets/js/94.c5725f80.js"><link rel="prefetch" href="/assets/js/95.dc61d501.js"><link rel="prefetch" href="/assets/js/96.3a598fc5.js"><link rel="prefetch" href="/assets/js/97.712aa8be.js"><link rel="prefetch" href="/assets/js/98.e757fe7a.js"><link rel="prefetch" href="/assets/js/99.1418024a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35bcedcf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">SUCKED BloG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/other/index.html" class="nav-link">
  index
</a></div><div class="nav-item"><a href="/question/index.html" class="nav-link">
  question
</a></div><div class="nav-item"><a href="/audition/index.html" class="nav-link">
  audition
</a></div><div class="nav-item"><a href="/point/index.html" class="nav-link">
  point
</a></div><div class="nav-item"><a href="/work/index.html" class="nav-link">
  work
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="url" class="dropdown-title"><span class="title">url</span> <span class="arrow down"></span></button> <button type="button" aria-label="url" class="mobile-dropdown-title"><span class="title">url</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/other/config.html" class="nav-link">
  其他
</a></li><li class="dropdown-item"><!----> <a href="https://git.code.tencent.com/u/nampy" target="_blank" rel="noopener noreferrer" class="nav-link external">
  腾讯工蜂
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/willwxt" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="http://nbcb.icu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  导航首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/other/index.html" class="nav-link">
  index
</a></div><div class="nav-item"><a href="/question/index.html" class="nav-link">
  question
</a></div><div class="nav-item"><a href="/audition/index.html" class="nav-link">
  audition
</a></div><div class="nav-item"><a href="/point/index.html" class="nav-link">
  point
</a></div><div class="nav-item"><a href="/work/index.html" class="nav-link">
  work
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="url" class="dropdown-title"><span class="title">url</span> <span class="arrow down"></span></button> <button type="button" aria-label="url" class="mobile-dropdown-title"><span class="title">url</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/other/config.html" class="nav-link">
  其他
</a></li><li class="dropdown-item"><!----> <a href="https://git.code.tencent.com/u/nampy" target="_blank" rel="noopener noreferrer" class="nav-link external">
  腾讯工蜂
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/willwxt" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="http://nbcb.icu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  导航首页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Kafka</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/point/05message/kafka.html#_01-kafka基本信息" class="sidebar-link">01.kafka基本信息</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/point/05message/kafka.html#_02-kafka生产者" class="sidebar-link">02.kafka生产者</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#生产者客户端" class="sidebar-link">生产者客户端</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#原理分析" class="sidebar-link">原理分析</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#生产者参数" class="sidebar-link">生产者参数</a></li></ul></li><li><a href="/point/05message/kafka.html#_03-kafka消费者" class="sidebar-link">03.kafka消费者</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#消费者和消费组" class="sidebar-link">消费者和消费组</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#消费者客户端" class="sidebar-link">消费者客户端</a></li></ul></li><li><a href="/point/05message/kafka.html#_04-主题和分区" class="sidebar-link">04.主题和分区</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#主题管理" class="sidebar-link">主题管理</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#kafkaadminclient" class="sidebar-link">KafkaAdminClient</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#分区管理" class="sidebar-link">分区管理</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#如何选择合适的分区数" class="sidebar-link">如何选择合适的分区数</a></li></ul></li><li><a href="/point/05message/kafka.html#_05-kafka日志存储" class="sidebar-link">05.kafka日志存储</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#文件目录格式布局" class="sidebar-link">文件目录格式布局</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#日志格式的演变" class="sidebar-link">日志格式的演变</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#日志索引" class="sidebar-link">日志索引</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#日志清理" class="sidebar-link">日志清理</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#磁盘存储" class="sidebar-link">磁盘存储</a></li></ul></li><li><a href="/point/05message/kafka.html#_06-kafka服务端" class="sidebar-link">06.kafka服务端</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#协议设计" class="sidebar-link">协议设计</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#时间轮-timingwheel" class="sidebar-link">时间轮 TimingWheel</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#延时操作" class="sidebar-link">延时操作</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#控制器" class="sidebar-link">控制器</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#参数" class="sidebar-link">参数</a></li></ul></li><li><a href="/point/05message/kafka.html#_07-kafka客户端" class="sidebar-link">07.kafka客户端</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#分区分配策略" class="sidebar-link">分区分配策略</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#消费者协调器与组协调器" class="sidebar-link">消费者协调器与组协调器</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#consumer-offsets剖析" class="sidebar-link">_consumeroffsets剖析</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#事务" class="sidebar-link">事务</a></li></ul></li><li><a href="/point/05message/kafka.html#_08-kafka可靠性" class="sidebar-link">08.kafka可靠性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#副本剖析" class="sidebar-link">副本剖析</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#日志同步机制" class="sidebar-link">日志同步机制</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#可靠性分析" class="sidebar-link">可靠性分析</a></li></ul></li><li><a href="/point/05message/kafka.html#_09-kafka应用" class="sidebar-link">09.kafka应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#命令行工具" class="sidebar-link">命令行工具</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#kafka-connect" class="sidebar-link">kafka connect</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#kafka-mirror-maker" class="sidebar-link">kafka mirror maker</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#kafka-streams" class="sidebar-link">kafka streams</a></li></ul></li><li><a href="/point/05message/kafka.html#_10-kafka监控" class="sidebar-link">10.kafka监控</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/point/05message/kafka.html#_11-高级应用" class="sidebar-link">11.高级应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#过期时间ttl" class="sidebar-link">过期时间TTL</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#延时队列" class="sidebar-link">延时队列</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#死信队列和重试队列" class="sidebar-link">死信队列和重试队列</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#消息路由" class="sidebar-link">消息路由</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#消息轨迹" class="sidebar-link">消息轨迹</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#消息审计" class="sidebar-link">消息审计</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#消息代理" class="sidebar-link">消息代理</a></li><li class="sidebar-sub-header"><a href="/point/05message/kafka.html#消息中间件选型" class="sidebar-link">消息中间件选型</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="kafka"><a href="#kafka" class="header-anchor">#</a> Kafka</h1> <p><a href="https://xie.infoq.cn/article/8b753e8f20eca9404e45c33ad" target="_blank" rel="noopener noreferrer">参考脑图<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_01-kafka基本信息"><a href="#_01-kafka基本信息" class="header-anchor">#</a> 01.kafka基本信息</h2> <p><strong>kafka概述</strong>: 由Scala语言开发, 基于zookeeper的多分区多副本的分布式消息系统; 目前kafka定位为一个分布式流式处理平台, 具有高吞吐, 可持久化, 可水平扩容, 支持流数据处理等特性</p> <p><strong>特点</strong></p> <ol><li>消息系统本身具有的特点: 解耦, 流量削峰, 异步通信, 缓冲, 冗余存储; 提供消息顺序性, 回溯消费等特性</li> <li>消息持久化, 可作为长期数据存储</li> <li>流式处理平台: 提供可靠数据来源, 提供完整的流式处理类库 (窗口, 连接, 变换, 聚合等操作)</li></ol> <h4 id="kafka体系结构"><a href="#kafka体系结构" class="header-anchor">#</a> kafka体系结构</h4> <p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcubHVvemhpeXVuLmNvbS9ibG9nMTY5NDliZDYyNzlkZjEwNi5wbmc?x-oss-process=image/format,png" alt="kafka structure"></p> <h4 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h4> <ul><li>producer: 生产者, 发送消息给服务器, 根据分区规则, 将消息存到具体分区</li> <li>consumer: 消费者, 使用pull模式拉取消息, 并保存offset</li> <li>broker: 服务器, 可以认为是kafka一个服务实例</li> <li>zookeeper: 存储kafka每个服务实例(或者说kafka集群)的元数据信息, 负责数据管理, 选举等</li></ul> <h4 id="特殊概念"><a href="#特殊概念" class="header-anchor">#</a> 特殊概念</h4> <ul><li>Topic 主题: 是一个逻辑概念, 消息会以主题进行归类
<ul><li>生产者会将消息发到指定主题, 而消费者负责订阅主题进行消费</li></ul></li> <li>Partition 分区: 一个分区只能属于一个主题(主题分区), 真正流转消息的单位
<ul><li>分区在存储层面可以理解为追加日志文件</li> <li>同一个主题下的不同分区包含不同的消息</li> <li>不同消息在分区中持有唯一的偏移量offset, 用于保证消息顺序性, 但是offset并不跨区; kafka保证的是分区中有序, 不保证主题中有序</li></ul></li></ul> <h4 id="分区副本"><a href="#分区副本" class="header-anchor">#</a> 分区副本</h4> <p>分区是多副本机制的(类似ES), 是主从模式, 主负责读写, 从负责备份/参与竞选;</p> <ul><li>AR (Assigned Replics) 所有副本统称 (AR = ISR + OSR)</li> <li>ISR (In-Sync) 保持一定程度同步的副本集合 (有资格选举)</li> <li>OSR (Out-of-Sync) 同步滞后过多的副本集合 (无资格)</li> <li>HW (High Watermark 高水位) 特定的offset, 消费者只能pull到HW之前的消息!</li> <li>LEO (Log End Offset) 下一条待写入消息的offset</li> <li>以上概念为了权衡性能和一致性</li></ul> <p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcubHVvemhpeXVuLmNvbS9ibG9nMTY5NDljZGY3Yzc3ZWVhZS5wbmc?x-oss-process=image/format,png" alt="hw-leo"></p> <h4 id="主从同步-isr与hw-leo"><a href="#主从同步-isr与hw-leo" class="header-anchor">#</a> 主从同步, ISR与HW,LEO</h4> <ol><li>新增两条消息</li> <li>leader 完成写操作, 但是follower还未同步, 此时HW和初始状态一直, 只能消费0~2</li> <li>follower未同步完全, 但是已经可以消费0~3了!</li> <li>最终同步完毕, 0~4都可以消费</li></ol> <p><img src="http://image.honeypps.com/images/papers/2019/114.png" alt="2"></p> <p><img src="http://image.honeypps.com/images/papers/2019/115.png" alt="3"></p> <p><img src="https://static.studytime.xin/article/2020/11/16043177624510.jpg" alt="4"></p> <p><img src="http://image.honeypps.com/images/papers/2019/116.png" alt="5"></p> <h2 id="_02-kafka生产者"><a href="#_02-kafka生产者" class="header-anchor">#</a> 02.kafka生产者</h2> <h3 id="生产者客户端"><a href="#生产者客户端" class="header-anchor">#</a> 生产者客户端</h3> <h3 id="原理分析"><a href="#原理分析" class="header-anchor">#</a> 原理分析</h3> <p>发送方式, 序列化器, 分区器, 拦截器</p> <h4 id="必备参数"><a href="#必备参数" class="header-anchor">#</a> 必备参数</h4> <ol><li>bootstrap.servers  服务器地址列表</li> <li>key.serializer  指定序列化方式</li> <li>value.serializer</li></ol> <h4 id="基本操作"><a href="#基本操作" class="header-anchor">#</a> 基本操作</h4> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//发送消息: </span>
<span class="token comment">//发后即忘, </span>
producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">record</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//同步</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RecordMetadata</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">record</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//同步阻塞等待</span>
<span class="token comment">//异步传入callback, 推荐</span>
producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">record</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="序列化器"><a href="#序列化器" class="header-anchor">#</a> 序列化器</h4> <p>StringSerializer源码: 默认UTF-8编码, 简单的将string转换为字节数组</p> <p>当我们想要通讯一个自定义对象, 可以自定义序列化器, 将对象转为字节数组</p> <h4 id="分区器"><a href="#分区器" class="header-anchor">#</a> 分区器</h4> <p>非必需, 只有record中没有partition字段, 才需要分区器计算分区号</p> <h4 id="生产者拦截器"><a href="#生产者拦截器" class="header-anchor">#</a> 生产者拦截器</h4> <p>在发送消息对消息做处理, 过滤, 修改内容等</p> <h4 id="生产者客户端整体架构"><a href="#生产者客户端整体架构" class="header-anchor">#</a> 生产者客户端整体架构</h4> <ol><li>主线程: 创建消息message - interceptor拦截器 - serializer序列化器 - partitioner分区器</li> <li>存入RecordAccumulator(消息收集器, 以便批量发送) , 这里已经分区存储了, 最大化网络资源, 但会增加延时</li> <li>Sender: 封装成request, 缓存到InFlightRequests, 这里已经是分节点存储了, 提交, 等待kafka服务器响应</li></ol> <p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcubHVvemhpeXVuLmNvbS9ibG9nMTY5NDlkZDVhODViNWZkZi5wbmc?x-oss-process=image/format,png" alt=""></p> <ol start="4"><li>InFlightRequests将已发送还未回复数据最少的节点视为负载最小节点</li> <li>元数据: kafka只需要配置一部分节点, 可以获取所有节点信息, 通过这些元数据信息找到消息需要发送到的目标节点</li></ol> <h3 id="生产者参数"><a href="#生产者参数" class="header-anchor">#</a> 生产者参数</h3> <div class="language-properties line-numbers-mode"><pre class="language-properties"><code><span class="token attr-name">acks</span><span class="token punctuation">:</span> <span class="token attr-value">指定分区中必须有多少个副本收到这条消息, 才认为这条消息成功写入</span>
<span class="token comment"># 默认1, 只要leader写入, 可选0(不需要服务端响应), -1(需要ISR所有副本写入成功)</span>

<span class="token attr-name">max.request.size</span> <span class="token punctuation">:</span> <span class="token attr-value">限制生产者客户端发送的消息最大值</span>
<span class="token attr-name">retries</span> <span class="token attr-value">, retry.backoff.ms : 重试次数 (默认0不重试) , 重试间隔ms</span>
<span class="token attr-name">compression.type</span> <span class="token punctuation">:</span> <span class="token attr-value">压缩方式</span>
<span class="token attr-name">connections.max.idle.ms</span> <span class="token punctuation">:</span> <span class="token attr-value">关闭闲置的连接超时时间</span>
linger.ms
<span class="token attr-name">receive.buffer.bytes</span> 
request.timeout.ms
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_03-kafka消费者"><a href="#_03-kafka消费者" class="header-anchor">#</a> 03.kafka消费者</h2> <p>订阅, 反序列化, 位移提交, 再均衡, 消费者拦截器, 多线程使用, 消费者客户端配置</p> <h3 id="消费者和消费组"><a href="#消费者和消费组" class="header-anchor">#</a> 消费者和消费组</h3> <ol><li>topic只有一个消费组: 点对点</li> <li>topic有多个消费组: Pub/Sub订阅</li> <li>消费组可以通过增加组内消费者来提升整组的消费能力, 可也能消费者过多</li></ol> <p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcubHVvemhpeXVuLmNvbS9ibG9nMTY5NGVjOTZhMDg3OWY3Yi5wbmc?x-oss-process=image/format,png" alt="c-group"></p> <p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcubHVvemhpeXVuLmNvbS9ibG9nMTZhYTY0MGU5YWY4OWZmMy5wbmc?x-oss-process=image/format,png" alt="kuozhan"></p> <h3 id="消费者客户端"><a href="#消费者客户端" class="header-anchor">#</a> 消费者客户端</h3> <ol><li>配置参数, 订阅主题, 拉取消息, 消费, 提交消费位移, 关闭消费者实例</li></ol> <h4 id="消费客户端必输参数"><a href="#消费客户端必输参数" class="header-anchor">#</a> 消费客户端必输参数</h4> <ol><li>bootstrap.servers 与生产者同理</li> <li>group.id 消费组, 上面已经解释, 必填</li> <li>key.deserializer 和 value.deserializer 同理</li></ol> <h4 id="订阅主题与分区"><a href="#订阅主题与分区" class="header-anchor">#</a> 订阅主题与分区</h4> <p>以下一共三种状态, 消费者只能选择使用一种</p> <ul><li>一个消费者可以订阅一个(主题名相同)或多个主题(正则) subscribe()</li> <li>还可以订阅一个主题的特定分区 assign()</li></ul> <p>自动再均衡功能: subscribe() 订阅主题时, 具有消费者自动 <strong>再均衡</strong> 功能</p> <h4 id="反序列化"><a href="#反序列化" class="header-anchor">#</a> 反序列化</h4> <p>不推荐使用自定义反序列化器, 示例使用Protostuff做序列化</p> <h4 id="消费消息"><a href="#消费消息" class="header-anchor">#</a> 消费消息</h4> <ol><li>kafka的消费是一个不断调用poll()轮询拉取消费
<ul><li>poll还具有更多复杂功能: 消费位移, 消费协调器, 选举, 分区分配分发, 再均衡, 心跳......</li></ul></li> <li>取回的ConsumerRecord存储很多信息
<ul><li>主题, 所属分区, 分区偏移量, 创建时间和追加到日志的时间...</li></ul></li></ol> <h4 id="位移提交"><a href="#位移提交" class="header-anchor">#</a> 位移提交</h4> <ol><li>将对每个分区消费位移记录下来(持久化), ①记录消费位置, ②新消费者加入时能够得到消费位移</li> <li>老版本的kafka中, 这个消费位移存在zookeeper中, 新版kafka存在__consumer_offsets主题中
<ul><li>双下划线开头的主题一般作为kafka的内部主题</li></ul></li> <li>具体是, 将(lastConsumedOffset)加1后作为当前消费位移, 提交给kafka
<ul><li>场景: 当前poll了 x+2 至 x+7 的偏移量, 在消费到x+5时发生故障</li> <li><strong>重复消费</strong>: 先消费, 消费完毕后再提交消费; 故障恢复后重复消费x+2至x+4</li> <li><strong>消息丢失</strong>: 先提交消费位移, 再消费; x+5至x+7消息将不会被消费</li> <li>实际情况还有更复杂的case</li></ul></li> <li>默认情况下, 消费者每隔5秒将拉取到每个分区中的消息位移进行提交
<ul><li>开始消费, 在自动提交前崩溃, 恢复后重复消费</li> <li>当处理线程崩溃, 而自动提交线程正常, 导致消息丢失</li></ul></li> <li>关闭自动提交(开启手动提交)
<ul><li>普通提交, 提交所有分区的消费位移</li> <li>每次消费维度提交位移 (性能低)</li> <li>分区维度进行提交位移</li> <li>同步提交和异步提交</li> <li>提交失败(CommitFailException等), 捕获异常做针对性处理</li> <li>再均衡把关</li></ul></li></ol> <h4 id="控制或关闭消费"><a href="#控制或关闭消费" class="header-anchor">#</a> 控制或关闭消费</h4> <h4 id="指定位移消费"><a href="#指定位移消费" class="header-anchor">#</a> 指定位移消费</h4> <p><code>auto.offset.reset</code> 配置项指定默认读取消息位置 (当新的消费组建立时, 或其他情况下查找不到所记录的消费位移)</p> <p><code>seek()</code> 方法: 从指定位置读取消息的能力</p> <h4 id="再均衡"><a href="#再均衡" class="header-anchor">#</a> 再均衡</h4> <ol><li>概述: 分区所属权从一个消费者转移到另一个消费者</li> <li>高可用, 伸缩性</li> <li>再均衡发生期间, 消费组内无法读取消息</li> <li>发生再均衡有可能导致消息的重复消费</li> <li>避免不必要的再均衡发生</li></ol> <h4 id="消费者拦截器"><a href="#消费者拦截器" class="header-anchor">#</a> 消费者拦截器</h4> <p>在消费消息或是提交消费位移时进行一些定制化操作</p> <ol><li>自定义拦截器实现消息TTL过期时间的功能</li></ol> <h4 id="多线程实现"><a href="#多线程实现" class="header-anchor">#</a> 多线程实现</h4> <ol><li>KafkaProducer是线程安全的, KafkaConsumer不是线程安全的</li> <li>KafkaConsumer有acquire()方法, 检测是否只有一个线程操作</li> <li>第一种: 多线程下, 一个线程对应一个KafkaConsumer实例, 一个线程消费一个或多个分区</li> <li>第二种(不推荐): 多个线程同时消费一个分区, 通过assign和seek方法实现</li> <li>第三种: 认为瓶颈是消息处理而不是消息接收, 可以让一个线程做接收, 然后用多线程的方式进行消费; 性能提升, 但是消息消费顺序更难保证了</li></ol> <h4 id="重要的消费者参数"><a href="#重要的消费者参数" class="header-anchor">#</a> 重要的消费者参数</h4> <div class="language-properties line-numbers-mode"><pre class="language-properties"><code><span class="token attr-name">fetch.min.bytes</span> <span class="token punctuation">=</span> <span class="token attr-value">一次poll()拉取的最小数据量</span>
<span class="token attr-name">fetch.max.bytes</span> <span class="token punctuation">=</span> <span class="token attr-value">最大数据量(但不是绝对的最大值)</span>
<span class="token attr-name">fetch.max.wait.ms</span> <span class="token punctuation">=</span> <span class="token attr-value">等待时间, 默认500ms</span>
<span class="token attr-name">max.partition.fetch.bytes</span> <span class="token punctuation">=</span> <span class="token attr-value">配置每个分区里返回给Consumer的最大数据量(默认1MB)</span>
<span class="token attr-name">max.poll.records</span> <span class="token punctuation">=</span> <span class="token attr-value">一次poll拉取的最大消息数量(默认500)</span>
<span class="token attr-name">connections.max.idle.ms</span> <span class="token punctuation">=</span> <span class="token attr-value">多久之后关闭闲置的连接(默认9分钟)</span>
<span class="token attr-name">exclude.internal.topics</span> <span class="token attr-value">= </span>
<span class="token attr-name">receive.buffer.bytes</span> <span class="token attr-value">= </span>
<span class="token attr-name">send.buffer.bytes</span> <span class="token attr-value">= </span>
<span class="token attr-name">request.timeout.ms</span> <span class="token attr-value">= </span>
<span class="token attr-name">metadata.max.age.ms</span> <span class="token attr-value">= </span>
<span class="token attr-name">reconnect.backoff.ms</span> <span class="token punctuation">=</span> <span class="token attr-value">重新连接的冷却时间, 避免频繁连接主机, 默认50ms</span>
<span class="token attr-name">retry.backoff.ms</span> <span class="token attr-value">= </span>
<span class="token attr-name">isolation.level</span> <span class="token punctuation">=</span> <span class="token attr-value">消费者事务隔离级别, RU和RC可选, 分别可以读到HW和LSO</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="_04-主题和分区"><a href="#_04-主题和分区" class="header-anchor">#</a> 04.主题和分区</h2> <h3 id="主题管理"><a href="#主题管理" class="header-anchor">#</a> 主题管理</h3> <h4 id="创建主题"><a href="#创建主题" class="header-anchor">#</a> 创建主题</h4> <ol><li>生产者向一个尚未创建的主题发送消息, 默认创建主题(1个分区, 1个副本)</li> <li>推荐: 把自动创建主题关闭, 通过kafka-topic.sh脚本来创建主题</li> <li>一个主题会由多个分区组成, 一个分区可能由多个副本(日志)组成</li></ol> <p><img src="https://img2018.cnblogs.com/blog/1204119/201911/1204119-20191122000040480-372639560.png" alt="wulijiegou"></p> <h4 id="主题操作api"><a href="#主题操作api" class="header-anchor">#</a> 主题操作API</h4> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token comment">#主题的 增删改查, 配置管理</span>
<span class="token comment">#查看主题信息</span>
kafka-topics.sh --zookeeper <span class="token number">172.17</span>.0.1:2181/kafka --describe -topic tokafeidou	
<span class="token comment">#创建主题kafeidou, 指定1副本, 1分区, 一些配置参数</span>
kafka-topics.sh zookeeper localhost:2181/kafka <span class="token punctuation">\</span>
--create --topic kafeidou <span class="token punctuation">\</span>
--replication-factor <span class="token number">1</span> <span class="token punctuation">\</span>
--partitions <span class="token number">1</span> <span class="token punctuation">\</span>
--config cleanup.policy<span class="token operator">=</span>compact <span class="token punctuation">\</span>
--config max.message.bytes<span class="token operator">=</span>lOOOO
<span class="token comment">#指定过broker机架信息的话, 会将分区/副本尽量分配到不同机架broker.rack</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="副本分配策略"><a href="#副本分配策略" class="header-anchor">#</a> 副本分配策略</h4> <h4 id="配置管理"><a href="#配置管理" class="header-anchor">#</a> 配置管理</h4> <h4 id="主题端参数"><a href="#主题端参数" class="header-anchor">#</a> 主题端参数</h4> <h3 id="kafkaadminclient"><a href="#kafkaadminclient" class="header-anchor">#</a> KafkaAdminClient</h3> <p>管理broker, 配置AccessControlList, 管理主题</p> <h3 id="分区管理"><a href="#分区管理" class="header-anchor">#</a> 分区管理</h3> <h4 id="优先副本的选举"><a href="#优先副本的选举" class="header-anchor">#</a> 优先副本的选举</h4> <ul><li>均匀分布的分区副本, 当一个broker挂掉后, 在其中为leader副本的分区进行选举, 从而保证可用</li> <li>在恢复可用的过程中, leader会一直向始终正常的节点迁移, 导致负载失衡</li> <li><strong>优先副本/分区自动平衡</strong>: 定时任务计算每个broker的节点不平衡率, 超过阈值触发优先副本选举</li> <li>生产情况不推荐开启自动平衡, 推荐手动执行分区平衡</li> <li>很消耗资源, 提供小批量(部分分区)的优先副本选举</li></ul> <h4 id="分区重分配"><a href="#分区重分配" class="header-anchor">#</a> 分区重分配</h4> <ul><li>一个节点宕机下线, 并不会把节点上的数据转交给其他节点</li> <li>一个新节点加入, 之前的主题分区不会自动分配到新节点, 只有新创建的才会, 导致不均衡</li> <li><strong>分区重分配</strong>: 使用脚本对分区副本再次进行合理的分配 (数据迁移: 数据同步后删除旧副本)</li> <li>对集群性能有很大影响, 占用网络和磁盘资源, 可以降低重分配粒度, 小批次执行</li></ul> <h4 id="复制限流"><a href="#复制限流" class="header-anchor">#</a> 复制限流</h4> <p>对副本间的复制流量加以限制来保证重分配期间服务不受太大影响</p> <h4 id="修改副本因子-副本数"><a href="#修改副本因子-副本数" class="header-anchor">#</a> 修改副本因子(副本数)</h4> <p>扩容/缩容</p> <h3 id="如何选择合适的分区数"><a href="#如何选择合适的分区数" class="header-anchor">#</a> 如何选择合适的分区数</h3> <p>根据实际业务场景, 软硬件条件, 负载情况来做具体考量</p> <h4 id="性能测试工具"><a href="#性能测试工具" class="header-anchor">#</a> 性能测试工具</h4> <p>并不是分区越多性能越好</p> <h4 id="分区数上限"><a href="#分区数上限" class="header-anchor">#</a> 分区数上限</h4> <p>Too many open files 常见的linux系统错误, 通常为文件描述符不足</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token builtin class-name">ulimit</span> -n	<span class="token comment">#查看文件描述符, 还有参数是 -S(软) 和 -H(硬)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="考量因素-总结"><a href="#考量因素-总结" class="header-anchor">#</a> 考量因素 &amp; 总结</h4> <h2 id="_05-kafka日志存储"><a href="#_05-kafka日志存储" class="header-anchor">#</a> 05.kafka日志存储</h2> <h3 id="文件目录格式布局"><a href="#文件目录格式布局" class="header-anchor">#</a> 文件目录格式布局</h3> <p><img src="https://img2018.cnblogs.com/blog/1204119/201911/1204119-20191122000040480-372639560.png" alt="wulijiegou"></p> <ol><li>防止Log过大, 又引入了日志分段(LogSegment);</li> <li>事实上, Log是文件夹, LogSegment对应磁盘上的一个日志文件和两个索引文件</li> <li>Log对应一个命名为 <code>topic-partition</code> 的文件夹</li> <li>文件均以偏移量命名: 00000000000000000000.log</li></ol> <h3 id="日志格式的演变"><a href="#日志格式的演变" class="header-anchor">#</a> 日志格式的演变</h3> <h3 id="日志索引"><a href="#日志索引" class="header-anchor">#</a> 日志索引</h3> <ol><li>偏移量索引</li> <li>时间戳索引</li></ol> <h3 id="日志清理"><a href="#日志清理" class="header-anchor">#</a> 日志清理</h3> <ol><li>日志删除
<ul><li>基于时间(默认7天), 基于日志大小(默认Log文件1G), 基于日志起始偏移量(删除logStartOffset之前的)的日志保留策略</li></ul></li> <li>日志压缩</li></ol> <h3 id="磁盘存储"><a href="#磁盘存储" class="header-anchor">#</a> 磁盘存储</h3> <ul><li>磁盘顺序IO和随机IO性能差6000倍, 磁盘顺序IO比内存随机IO还要快</li> <li>kafka在设计的时候采用文件追加的方式来写入消息</li></ul> <h4 id="页缓存pagecache"><a href="#页缓存pagecache" class="header-anchor">#</a> 页缓存pagecache</h4> <ol><li>页缓存是操作系统实现的一种主要的磁盘缓存, 用来减少对磁盘IO的操作</li> <li>流程, 类似redis缓存层:
<ol><li>读取: 先查询目标page是否在pagecache中, 有就直接返回; 否则读取磁盘并存入页缓存, 再将数据返回</li> <li>写入: 先写入pagecache中并标记为脏页, 最后在合适的时间(根据OS配置)写入磁盘</li> <li><code>vm.dirty_background_ratio</code> 当脏页数量达到系统内存的百分多少时触发flush回写进程</li></ol></li> <li>常识: Java对象内存开销非常大, 是真实数据的数倍, 空间利用率低下, 所以kafka大量使用直接内存(页缓存), 同时也提供同步刷盘fsync功能保证可靠性(不建议使用, 请用多副本来保障)</li> <li>使用内存时, 请禁用swap分区以避免内存交换</li></ol> <h4 id="磁盘io流程"><a href="#磁盘io流程" class="header-anchor">#</a> 磁盘IO流程</h4> <p>不同API调用场景:</p> <ul><li>用户调用标准C库进行IO操作: 应用程序buffer &gt;&gt; C库标准IObuffer &gt;&gt; 文件系统页缓存 &gt;&gt; 通过文件系统到磁盘</li> <li>用户调用文件IO: 应用程序buffer &gt;&gt; 文件系统页缓存 &gt;&gt; 通过具体文件系统到磁盘</li> <li>用户打开文件时使用O_DIRECT: 绕过页缓存直接读写磁盘</li> <li>用户使用类似dd工具, 并使用direct参数, 绕过系统cache和文件系统, 直接写磁盘</li></ul> <p><img src="https://img2020.cnblogs.com/blog/1393475/202006/1393475-20200618160454583-229079948.png" alt="disk-io-process"></p> <ol><li>写操作 (异步): 用户调用fwrite把数据写入C标准IObuffer即返回成功; IObuffer会将多次小数据量合并写入页缓存; 内核pdflush不断检测脏页并写回磁盘</li> <li>读操作 (同步): 用户调用fread读C库标准IObuffer, 读页缓存, 发起IO请求同步数据到页缓存和IObuffer, 最后返回;</li> <li>IO请求处理: 通用快根据IO请求构造一个或多个bio结构提交到调度层; 调度器将bio结构进行排序和合并, 尽量满足顺序读;</li></ol> <p>针对不同应用场景, 可选不同IO调度策略</p> <ol><li>NOOP算法(No Operation): 最简单的FIFO, 加上相邻IO合并</li> <li>CFQ算法(Completely Fair Queuing): 按照IO请求的地址进行排序, 大致是按照顺序消费
<ul><li>是默认的磁盘调度算法, 目的是减少磁盘旋转次数, 增加SAS盘吞吐量</li> <li>但是IO并非有序, 先来的请求可能一直得不到执行, 造成饥饿</li></ul></li> <li>DEADLINE: 在CFQ的基础上, 解决了IO饥饿的极端情况
<ul><li>除了CFQ线程, 额外增加读IO队列 和 写IO队列</li></ul></li> <li>ANTICIPATORY: 对顺序读做优化, 适合随机IO和顺序IO混合的场景
<ul><li>在DEADLINE基础上为每个读IO设置了6ms等待时间, 期间内收到相邻位置IO, 则立即满足</li></ul></li></ol> <p>测试后选择适合业务的IO调度策略; 文件系统推荐使用 EXT4 或 XFS</p> <h4 id="零拷贝"><a href="#零拷贝" class="header-anchor">#</a> 零拷贝</h4> <p><a href="https://torgor.github.io/2020/04/01/zero-copy/" target="_blank" rel="noopener noreferrer">可以参考的零拷贝文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>概念: 将数据直接从磁盘文件复制到网卡设备中, 不需要经由应用程序之手; 大大提高应用程序性能, 减少内核与用户态之间的上下文切换</li> <li>Linux中, 零拷贝依赖于 sendfile() 方法实现; 对应Java语言中的 FileChannel.transferTo()</li></ul> <p>普通拷贝: 读取文件, 再用socket发送出去</p> <ol><li>将磁盘文件读取到操作系统内核read buffer</li> <li>将内核缓冲区数据copy到application应用程序的buffer</li> <li>将application应用程序buffer中的数据 copy到内核socket buffer</li> <li>将socket buffer的数据copy到网卡, 由网卡进行网络传输</li></ol> <p><img src="https://pic4.zhimg.com/80/v2-07f829c7a070c3444b1d8c99d4afd1bb_720w.jpg" alt="非零拷贝"></p> <p><strong>零拷贝</strong>: 指的是没有经过CPU拷贝; 内核态下没有拷贝;</p> <ol><li>将磁盘文件读取到操作系统内核read buffer</li> <li>只有数据位置, 数据长度等信息加载到 socket buffer中</li> <li>DMA引擎直接将数据从内核的 read buffer 中传递到网卡</li></ol> <p><img src="https://torgor.github.io/styles/images/zerocopy/zero-copy.jpeg" alt="zero-copy"></p> <h2 id="_06-kafka服务端"><a href="#_06-kafka服务端" class="header-anchor">#</a> 06.kafka服务端</h2> <h3 id="协议设计"><a href="#协议设计" class="header-anchor">#</a> 协议设计</h3> <h3 id="时间轮-timingwheel"><a href="#时间轮-timingwheel" class="header-anchor">#</a> 时间轮 TimingWheel</h3> <p>在增删时比jdk自带时间组件有更优的时间复杂度 O(1), 具体实现...</p> <h3 id="延时操作"><a href="#延时操作" class="header-anchor">#</a> 延时操作</h3> <p>kafka中很多地方使用延时操作, 比如消息全同步下, 等leader写入完毕后, 启动延时操作同步followers</p> <h3 id="控制器"><a href="#控制器" class="header-anchor">#</a> 控制器</h3> <p>kafka集群中有一个broker会被选举为控制器(kafka controller)</p> <ol><li>负责管理整个集群中所有分区和副本的状态;</li> <li>当检测到某个分区的leader出现故障, 由控制器负责为该分区选举新的leader</li> <li>当检测到某个分区的ISR集合发生变化, 由控制器负责通知所有broker更新其元数据信息</li></ol> <h4 id="控制器的选举与异常恢复"><a href="#控制器的选举与异常恢复" class="header-anchor">#</a> 控制器的选举与异常恢复</h4> <p>kafka中的控制器选举工作依赖于zookeeper, 成功选举后会在zk中创建 /controller 临时节点</p> <ol><li>broker启动时, 回去尝试读取该 /controller 节点, 只有节点存在并且数据正常, 表示已有控制器</li> <li>如果节点不存在或者数据异常, 那么broker会尝试去创建 /controller 节点, 只有创建成功的broker成为控制器</li></ol> <p>此外还有一个 /controller_epoch 持久节点, 用于记录控制器发生变更的次数, 或者说控制器的纪元</p> <ul><li>kafka用纪元来保证kafka中控制器的唯一性: 纪元是根据控制器当选顺序递增的, 每个控制器交互请求都会带上epoch, 如果小于纪元说明该请求已过期, 如果大于纪元说明有新的控制器当选了;</li></ul> <p>旧版kafka没有控制器概念, 严重依赖zk, 每个broker会在zk上建立大量的监听器来管理分区和副本状态; 引入控制器后, 只有控制器相关的少量监听器注册到zk上, 减少zk依赖;</p> <h4 id="分区leader的选举"><a href="#分区leader的选举" class="header-anchor">#</a> 分区leader的选举</h4> <ol><li>当创建分区或分区上线(leader下线): 以OfflinePartitionLeaderElectionStrategy作为选举策略
<ul><li>该策略的思路是按照 AR 集合中的副本顺序查找第一个存活的并且在ISR中的副本</li></ul></li> <li>分区重分配: ReassignPartitionLeaderElectionStrategy策略
<ul><li>从重分配的AR列表中找到第一个存活且在ISR中的副本</li></ul></li> <li>优先副本选举: PreferredReplicaPartitionLeaderElectionStrategy
<ul><li>直接将优先副本设置为leader</li></ul></li> <li>节点优雅关闭: ControlleredShutdownPartitionElectionStrategy
<ul><li>从AR中找到第一个存活且在ISR中同时确保这个副本不在被关闭的节点上</li></ul></li></ol> <h4 id="优雅关闭kafka"><a href="#优雅关闭kafka" class="header-anchor">#</a> 优雅关闭kafka</h4> <h3 id="参数"><a href="#参数" class="header-anchor">#</a> 参数</h3> <p>broker.id 和 booststrap.servers</p> <h4 id="服务端重要参数"><a href="#服务端重要参数" class="header-anchor">#</a> 服务端重要参数</h4> <div class="language-properties line-numbers-mode"><pre class="language-properties"><code><span class="token attr-name">auto.create.topics.enable</span> <span class="token punctuation">=</span> <span class="token attr-value">是否开启自动创建主题</span>
<span class="token attr-name">auto.leader.rebalance.enable</span> <span class="token punctuation">=</span> <span class="token attr-value">是否leader自动再均衡</span>
<span class="token attr-name">background.threads</span> <span class="token punctuation">=</span> <span class="token attr-value">后台任务线程数</span>
...
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_07-kafka客户端"><a href="#_07-kafka客户端" class="header-anchor">#</a> 07.kafka客户端</h2> <p>深入客户端底层原理</p> <h3 id="分区分配策略"><a href="#分区分配策略" class="header-anchor">#</a> 分区分配策略</h3> <p>kafka提供了消费者与订阅主题之间的分区分配策略</p> <h4 id="rangeassignor"><a href="#rangeassignor" class="header-anchor">#</a> RangeAssignor</h4> <p>按照消费者总数和分区总数进行整除运算来获得一个跨度, 根据跨度进行平均分配, 保证分区尽可能均匀地分配给消费者</p> <h4 id="roundrobinassignor"><a href="#roundrobinassignor" class="header-anchor">#</a> RoundRobinAssignor</h4> <p>将消费组内: 所有消费者, 所有订阅的主题分区进行排序后, 把分区依次轮询分配给消费者</p> <h4 id="stickyassignor"><a href="#stickyassignor" class="header-anchor">#</a> StickyAssignor</h4> <p>目的: 1.分配尽可能均匀, 2尽可能与上次分配保持相同</p> <h4 id="自定义分区分配策略"><a href="#自定义分区分配策略" class="header-anchor">#</a> 自定义分区分配策略</h4> <p>实现 org.apache.kafka.clients.consumer.internals.PartitionAssignor 接口</p> <h3 id="消费者协调器与组协调器"><a href="#消费者协调器与组协调器" class="header-anchor">#</a> 消费者协调器与组协调器</h3> <p>旧版kafka使用zk的监听器实现协调功能的</p> <ol><li>羊群效应 Herd Effect: zk中一个被监听的节点变化, 大量的Watcher通知发送到客户端, 导致期间其他操作延迟</li> <li>脑裂问题 Split Brain: 消费者再均衡操作时每个消费者都与zk进行通信以判断消费者或broker的变化情况, 由于zk本身问题, 同一时刻状态可能不一致</li></ol> <p>GroupCoordinator和 ConsumerCoordinator的重要职责就是负责执行消费者再均衡的操作</p> <p>详细...</p> <h3 id="consumer-offsets剖析"><a href="#consumer-offsets剖析" class="header-anchor">#</a> __consumer_offsets剖析</h3> <p>位移提交的内容最终保存在 <code>__consumer_offsets</code> 主题中</p> <h3 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h3> <h4 id="消息传输保障"><a href="#消息传输保障" class="header-anchor">#</a> 消息传输保障</h4> <p>一般而言, 消息传输保障有三级</p> <ol><li>at most once: 最多一次, 消息可能会丢失, 但绝不会重复</li> <li>at least once: 最少一次, 消息不会丢失, 可能重复</li> <li>exactly once: 恰好一次, 消息不会丢失也不会重复</li></ol> <ul><li>kafka生产者发送消息: at least once, 一旦消息提交到日志文件, 这条消息就不会丢失; 如果通信中断, 生产者无法判断是否已经提交, 但是可以进行多次重试;</li> <li>kafka消费者消费: 根据提交消费位移和消费业务的执行顺序而定
<ul><li>先提交位移: 可能消息丢失</li> <li>后提交位移: 消息重复</li></ul></li></ul> <h4 id="幂等"><a href="#幂等" class="header-anchor">#</a> 幂等</h4> <p>概述: 对接口的多次调用所产生的结果和调用一次等效</p> <div class="language-properties line-numbers-mode"><pre class="language-properties"><code><span class="token attr-name">enable.idempotence</span> <span class="token punctuation">=</span> <span class="token attr-value">设置为true即可开启幂等性功能, 避免重试造成重复写入消息 &gt;&gt; 针对生产者</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol><li>为每个生产者分配PID, broker端维护PID和分区的序列号, 只有序列递增的消息才会被接收</li> <li>只能保证单个生产者的单个分区中的幂等性</li></ol> <h4 id="事务-2"><a href="#事务-2" class="header-anchor">#</a> 事务</h4> <ul><li>事务可以保证对多个分区<strong>写入操作的原子性</strong>, 不存在部分成功部分失败;</li> <li>使用场景: consume-transform-produce模式下, 应用先消费某个主题的消息, 处理后生成消息写入另一个主题
<ul><li>kafka可以保证这些操作全部成功或全部失败</li></ul></li> <li>但是对消费者而言, 事务能够保证的语义相对偏弱</li> <li><code>isolation.level</code> 消费端应用对未commit消息 的可见性</li></ul> <h2 id="_08-kafka可靠性"><a href="#_08-kafka可靠性" class="header-anchor">#</a> 08.kafka可靠性</h2> <p>如何保证kafka多副本机制之间的一致性, 可靠性</p> <h3 id="副本剖析"><a href="#副本剖析" class="header-anchor">#</a> 副本剖析</h3> <p>副本: 分布式系统对数据和服务提供的一种冗余方式</p> <h4 id="失效副本"><a href="#失效副本" class="header-anchor">#</a> 失效副本</h4> <p>正常情况下, 所有副本都处于ISR集合中, 可能会有异常情况发生导致副本处于失效状态(follower频繁FGC, IO阻塞)</p> <h4 id="isr伸缩"><a href="#isr伸缩" class="header-anchor">#</a> ISR伸缩</h4> <p>定时任务检查ISR副本中是否存在失效副本, 检查follower的LEO是否追上leader的HW</p> <h4 id="通过hw和leo同步副本-leader-epoch保证leader切换时数据一致"><a href="#通过hw和leo同步副本-leader-epoch保证leader切换时数据一致" class="header-anchor">#</a> 通过HW和LEO同步副本, Leader Epoch保证leader切换时数据一致</h4> <h4 id="为什么不支持读写分离"><a href="#为什么不支持读写分离" class="header-anchor">#</a> 为什么不支持读写分离</h4> <p>主写从读是由于设计上的缺陷而形成的权宜之计 (不如分区)</p> <h3 id="日志同步机制"><a href="#日志同步机制" class="header-anchor">#</a> 日志同步机制</h3> <ul><li>少数服从多数(Quorum模型): Raft, Zab
<ul><li>在更新数据时需要多数follower回复同步成功才响应客户端成功, 大量节点会导致性能下降</li> <li>常用于共享集群配置, 少用于主流数据存储</li></ul></li> <li>kafka中, 也需要ISR中的副本都确认同步之后才认为提交, 不过选举策略更简单</li> <li>优势在于少数服从多数需要半数以上节点确认, 在容忍同样节点数量失败的情况下, 使用ISR可以降低需要的总节点数</li> <li>劣势是ISR无法绕开最慢副本的确认信息</li></ul> <h3 id="可靠性分析"><a href="#可靠性分析" class="header-anchor">#</a> 可靠性分析</h3> <ol><li>使用几个9来衡量可靠性</li> <li>kafka一般配置3副本即可, 银行5副本</li> <li>如果配置机架信息, 需要考虑机架整体宕机风险</li> <li>生产者客户端参数 acks = -1(副本同步完成), 可以提高消息可靠性</li> <li>一般的网络异常可以通过配置生产者客户端 retries 进行重发 ... 以及很多可靠性相关配置参数</li></ol> <h2 id="_09-kafka应用"><a href="#_09-kafka应用" class="header-anchor">#</a> 09.kafka应用</h2> <h3 id="命令行工具"><a href="#命令行工具" class="header-anchor">#</a> 命令行工具</h3> <h3 id="kafka-connect"><a href="#kafka-connect" class="header-anchor">#</a> kafka connect</h3> <h3 id="kafka-mirror-maker"><a href="#kafka-mirror-maker" class="header-anchor">#</a> kafka mirror maker</h3> <h3 id="kafka-streams"><a href="#kafka-streams" class="header-anchor">#</a> kafka streams</h3> <h2 id="_10-kafka监控"><a href="#_10-kafka监控" class="header-anchor">#</a> 10.kafka监控</h2> <p>任何软件都需要监控, 增强整体服务的鲁棒性, 及时发现问题, 预防&amp;告警</p> <h4 id="状态指标"><a href="#状态指标" class="header-anchor">#</a> 状态指标</h4> <h4 id="消费滞后"><a href="#消费滞后" class="header-anchor">#</a> 消费滞后</h4> <p>消息堆积: 通过监控来避免磁盘爆满, 日志清除</p> <p>消费滞后量(Lag): 等于高水位减去最近一次的消费位移</p> <h4 id="同步失效分区"><a href="#同步失效分区" class="header-anchor">#</a> 同步失效分区</h4> <h4 id="监控模块"><a href="#监控模块" class="header-anchor">#</a> 监控模块</h4> <h2 id="_11-高级应用"><a href="#_11-高级应用" class="header-anchor">#</a> 11.高级应用</h2> <h3 id="过期时间ttl"><a href="#过期时间ttl" class="header-anchor">#</a> 过期时间TTL</h3> <p>达到一定时间后的消息, 会被丢弃</p> <p>拦截器(ConsumerInterceptor)实现, 可以配合死信队列</p> <h3 id="延时队列"><a href="#延时队列" class="header-anchor">#</a> 延时队列</h3> <p>消息发送后, 需要等待一定时间后消费者才能获取/消费这个消息</p> <ol><li>通过内部主题实现, 分布创建延迟固定时间的主题, 使用单独服务进行延时的暂存, 然后转发到真实的主题</li> <li>改造kafka服务端, 自定义延时协议, 基于文件的单层时间轮</li></ol> <h3 id="死信队列和重试队列"><a href="#死信队列和重试队列" class="header-anchor">#</a> 死信队列和重试队列</h3> <p>私信队列: 定义对死信的需求, 哪些消息需要存入死信队列, 存放则只需要一个主题</p> <p>重试队列: 消息消费失败时重新进入队列并附加延时</p> <h3 id="消息路由"><a href="#消息路由" class="header-anchor">#</a> 消息路由</h3> <p>为了兼容RabbitMQ的设计, 可以用拦截器实现, 不推荐使用</p> <h3 id="消息轨迹"><a href="#消息轨迹" class="header-anchor">#</a> 消息轨迹</h3> <p>链路跟踪</p> <h3 id="消息审计"><a href="#消息审计" class="header-anchor">#</a> 消息审计</h3> <p>根据消息过程中</p> <h3 id="消息代理"><a href="#消息代理" class="header-anchor">#</a> 消息代理</h3> <p>kafka REST proxy: 就是一客户端, 提供RESTful接口, 供不同语言的客户端调用</p> <h3 id="消息中间件选型"><a href="#消息中间件选型" class="header-anchor">#</a> 消息中间件选型</h3> <ol><li>ActiveMQ: Apache出品, Java编写, JMS规范</li> <li>RabbitMQ: Erlang语言实现</li> <li>RocketMQ: 阿里开源</li></ol> <h4 id="选型要点"><a href="#选型要点" class="header-anchor">#</a> 选型要点</h4> <h4 id="_1-功能维度"><a href="#_1-功能维度" class="header-anchor">#</a> 1.功能维度</h4> <table><thead><tr><th>功能项</th> <th>Kafka2.0</th> <th>RabbitMQ3.6.10</th></tr></thead> <tbody><tr><td>优先级队列</td> <td>❌ 可以改造支持</td> <td>✔</td></tr> <tr><td>延时队列</td> <td>❌ 可以改造支持</td> <td>✔</td></tr> <tr><td>死信队列</td> <td>❌ 可以改造支持</td> <td>✔</td></tr> <tr><td>重试队列</td> <td>❌ 可以改造支持</td> <td>❌ 可以封装延时队列实现</td></tr> <tr><td>消费模式</td> <td>拉模式</td> <td>推+拉模式</td></tr> <tr><td>广播消费</td> <td>✔</td> <td>✔</td></tr> <tr><td>回溯消费</td> <td>✔</td> <td>❌</td></tr> <tr><td>消息堆积</td> <td>✔</td> <td>✔ 堆积效率比kafka低</td></tr> <tr><td>持久化</td> <td>✔</td> <td>✔</td></tr> <tr><td>消息轨迹</td> <td>❌ 可以改造支持</td> <td>✔</td></tr> <tr><td>消息审计</td> <td>❌</td> <td>❌</td></tr> <tr><td>消息过滤</td> <td>客户端级别支持</td> <td>❌ 可改造支持</td></tr> <tr><td>多租户</td> <td>✔</td> <td>✔</td></tr> <tr><td>多协议支持</td> <td>❌只自定义协议</td> <td>AMQP实现,支持多种协议</td></tr> <tr><td>跨语言支持</td> <td>✔ 多语言客户端</td> <td>✔ 多语言客户端</td></tr> <tr><td>流量控制</td> <td>✔</td> <td>✔</td></tr> <tr><td>消息顺序性</td> <td>单分区的顺序性</td> <td>❌</td></tr> <tr><td>安全机制</td> <td>✔</td> <td>✔</td></tr> <tr><td>幂等性</td> <td>单个生产者单分区幂等</td> <td>❌</td></tr> <tr><td>事务性消息</td> <td>✔</td> <td>✔</td></tr></tbody></table> <h4 id="_2-性能维度"><a href="#_2-性能维度" class="header-anchor">#</a> 2.性能维度</h4> <p>kafka单机QPS十万级~百万级</p> <h4 id="_3-可靠性和可用性"><a href="#_3-可靠性和可用性" class="header-anchor">#</a> 3.可靠性和可用性</h4> <p>通常用几个9衡量; kafka使用类PacificA的一致性协议, RabbitMQ使用全量镜像;</p> <h4 id="_4-运维管理"><a href="#_4-运维管理" class="header-anchor">#</a> 4.运维管理</h4> <p>监控管理系统, 都不错</p> <h4 id="_5-社区-生态"><a href="#_5-社区-生态" class="header-anchor">#</a> 5.社区&amp;生态</h4> <p>Java社区更活跃</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">6/28/2021, 6:07:36 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.42575a28.js" defer></script><script src="/assets/js/2.0d7d09b8.js" defer></script><script src="/assets/js/44.786fc51f.js" defer></script>
  </body>
</html>
