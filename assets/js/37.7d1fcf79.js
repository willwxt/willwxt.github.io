(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{391:function(a,t,e){"use strict";e.r(t);var r=e(45),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"spring核心"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring核心"}},[a._v("#")]),a._v(" Spring核心")]),a._v(" "),e("h2",{attrs:{id:"概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),e("ul",[e("li",[a._v("Spring为了简化企业级开发, 实现/替代EJB; (通过配置管理JavaBean依赖关系, 事务管理)")]),a._v(" "),e("li",[a._v("EJB : 企业级JavaBean, 在服务器领域使用JavaBean, 基于分布式事务, 技术复杂, 被轻量级的Spring干废")])]),a._v(" "),e("h3",{attrs:{id:"spring提供的基础功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring提供的基础功能"}},[a._v("#")]),a._v(" Spring提供的基础功能")]),a._v(" "),e("h4",{attrs:{id:"核心容器-ioc-和-aop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心容器-ioc-和-aop"}},[a._v("#")]),a._v(" 核心容器/IoC 和 AOP")]),a._v(" "),e("p",[a._v("实现组件: "),e("font",{attrs:{color:"11CC00"}},[a._v("spring-core , spring-bean , spring-context")])],1),a._v(" "),e("ul",[e("li",[e("p",[a._v("spring-core 和 spring-bean主要实现了IOC/DI功能")]),a._v(" "),e("ul",[e("li",[a._v("提供 "),e("font",{attrs:{color:"11CC00"}},[a._v("BeanFactory")]),a._v(" , 我们可以不再编程去实现单例模式")],1)])]),a._v(" "),e("li",[e("p",[a._v("spring-context 提供一个框架式的对象访问方式, 重点接口 "),e("font",{attrs:{color:"11CC00"}},[a._v("ApplicationContext")])],1)]),a._v(" "),e("li",[e("p",[a._v("spring-expression 提供强大的语言表达式")])]),a._v(" "),e("li",[e("p",[a._v("spring-aop 模块提供了面向切面的编程实现")]),a._v(" "),e("ul",[e("li",[a._v("允许我们定义方法的拦截点/切入点, 以便解耦应该被分离的功能实现")])])]),a._v(" "),e("li",[e("p",[a._v("spring-aspect 模块, 提供与AspectJ集成")])]),a._v(" "),e("li",[e("p",[a._v("spring-instrument 模块提供了类植入支持, 类加载器的实现, 可以应用在特定的应用服务器中 (比如tomcat)")]),a._v(" "),e("ul",[e("li",[a._v("spring-instrument-tomcat 模块包含支持 Tomcat 的植入代理")])])])]),a._v(" "),e("h4",{attrs:{id:"数据集成-访问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据集成-访问"}},[a._v("#")]),a._v(" 数据集成 / 访问")]),a._v(" "),e("p",[a._v("由JDBC, ORM, OXM, JMS和事务模块组成")]),a._v(" "),e("ul",[e("li",[a._v("spring-jdbc 提供了JDBC抽象层, 消除繁琐的JDBC以及各数据库厂商的适配编码")]),a._v(" "),e("li",[a._v("spring-tx 提供声明式事务")]),a._v(" "),e("li",[a._v("spring-orm 提供集成 "),e("font",{attrs:{color:"11CC00"}},[a._v("对象关系映射")]),a._v(" 框架(比如mybatis, JPA)的能力")],1),a._v(" "),e("li",[a._v("spring-oxm 提供对象和XML的映射")]),a._v(" "),e("li",[a._v("spring-jms 用于生产和消费消息, 集成了spring-messaging")])]),a._v(" "),e("h4",{attrs:{id:"web"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#web"}},[a._v("#")]),a._v(" Web")]),a._v(" "),e("p",[a._v("由 "),e("font",{attrs:{color:"11CC00"}},[a._v("spring-web, spring-webmvc, spring-websocket")]),a._v(" 模块组成")],1),a._v(" "),e("ul",[e("li",[a._v("spring-web 提供基本的面向web的集成功能, 比如多部分文件上传功能, 提供Servlet维度的IOC容器")]),a._v(" "),e("li",[a._v("spring-mvc 用于web应用的 MVC 模型")])]),a._v(" "),e("h4",{attrs:{id:"日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#日志"}},[a._v("#")]),a._v(" 日志")]),a._v(" "),e("ul",[e("li",[a._v("日志是spring唯一强制性的外部依赖, 因为spring整合了很多工具, spring希望统一日志配置")]),a._v(" "),e("li",[a._v("spring默认使用 commons-logging, 官网也提供了替换 SLF4J 的方法")])]),a._v(" "),e("h2",{attrs:{id:"ioc容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ioc容器"}},[a._v("#")]),a._v(" IoC容器")]),a._v(" "),e("h3",{attrs:{id:"容器介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器介绍"}},[a._v("#")]),a._v(" 容器介绍")]),a._v(" "),e("ul",[e("li",[e("font",{attrs:{color:"11CC00"}},[a._v("IoC控制反转")]),a._v(" "),e("a",{attrs:{href:"https://github.com/DocsHome/spring-docs/blob/master/pages/core/IoC-container.md",target:"_blank",rel:"noopener noreferrer"}},[a._v("IoC容器官方文档翻译"),e("OutboundLink")],1),a._v("  (控制: 资源的获取方式,分为主动式和被动式)\n"),e("ul",[e("li",[a._v("描述对象定义和依赖的过程, 原来是先依次创建对象中的所有依赖, 再创建对象; 现在是对象先实例化, 再将依赖注入; 这个过程是反向的; 又称DI依赖注入;")])])],1),a._v(" "),e("li",[e("font",{attrs:{color:"11CC00"}},[a._v("DI依赖注入")]),a._v(" "),e("ul",[e("li",[a._v("当容器发现一个类运行时需要依赖, 会通过反射把容器中的bean注入到该类中")])])],1),a._v(" "),e("li",[e("font",{attrs:{color:"11CC00"}},[a._v("BeanFactory")]),a._v(" 提供配置等基本功能, 可以管理任何对象; "),e("font",{attrs:{color:"11CC00"}},[a._v("ApplicationContext")]),a._v(" 在其基础上添加了更多企业功能")],1),a._v(" "),e("li",[e("font",{attrs:{color:"11CC00"}},[a._v("bean对象")]),a._v(" , 构成应用的骨架, IOC容器管理的主要对象")],1)]),a._v(" "),e("h4",{attrs:{id:"容器概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器概述"}},[a._v("#")]),a._v(" 容器概述")]),a._v(" "),e("p",[a._v("ApplicationContext是IOC容器的代表, 负责实例化, 配置, 组装bean")]),a._v(" "),e("p",[a._v("Spring提供了读取xml配置文件的实现类 "),e("code",[a._v("ClassPathXmlApplicationContext")]),a._v(" , 还支持Java配置")]),a._v(" "),e("p",[a._v("xml配置文件中配置bean数据")]),a._v(" "),e("div",{staticClass:"language-xml line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-xml"}},[e("code",[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("bean")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("id")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')]),a._v("..."),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')])]),a._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("class")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')]),a._v("..."),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("\x3c!--唯一id和指定全类名->\n    \x3c!-- collaborators and configuration for this bean go here --\x3e")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("bean")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("p",[a._v("每条 "),e("code",[a._v("<bean/>")]),a._v(" 数据在容器内部表示为 "),e("code",[a._v("BeanDefinition")]),a._v(" 对象")]),a._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//实例化IoC容器 xml配置文件版")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ApplicationContext")]),a._v(" context "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ClassPathXmlApplicationContext")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[a._v('"daos.xml"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//此外还可以用 groovy 配置bean, Java类配置bean")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("h3",{attrs:{id:"bean概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bean概述"}},[a._v("#")]),a._v(" Bean概述")]),a._v(" "),e("p",[a._v("无论xml还是其他配置方法, 每个bean在IoC容器中以 "),e("font",{attrs:{color:"11CC00"}},[a._v("BeanDefinition")]),a._v(" 对象形式存在, 并包含:")],1),a._v(" "),e("ul",[e("li",[a._v("限定包类名")]),a._v(" "),e("li",[a._v("bean配置项: 作用域, 生命周期回调函数")]),a._v(" "),e("li",[a._v("bean需要引用的其他依赖关系")]),a._v(" "),e("li",[a._v("其他配置: 用于对象的创建")])]),a._v(" "),e("h4",{attrs:{id:"bean的命名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bean的命名"}},[a._v("#")]),a._v(" bean的命名")]),a._v(" "),e("ul",[e("li",[a._v("一般来说使用id和name足够, 而且name可以定义多个")]),a._v(" "),e("li",[a._v("别名 Alias : 可以取个别名, 好兼容别处设置")])]),a._v(" "),e("h4",{attrs:{id:"bean实例化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bean实例化"}},[a._v("#")]),a._v(" bean实例化")]),a._v(" "),e("ol",[e("li",[a._v("通常反射调用构造方法创建bean, 和new差不多")]),a._v(" "),e("li",[a._v("通过工厂方法创建bean\n"),e("ul",[e("li",[a._v("可以通过静态工厂方法创建bean")]),a._v(" "),e("li",[a._v("可以通过实例工厂+普通方法创建bean")])])])]),a._v(" "),e("h3",{attrs:{id:"依赖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#依赖"}},[a._v("#")]),a._v(" 依赖")]),a._v(" "),e("p",[a._v("一般情况下bean都需要互相依赖, 协同工作")]),a._v(" "),e("ol",[e("li",[a._v("基于构造函数的依赖注入\n"),e("ol",[e("li",[a._v("在xml配置的bean中使用构造器参数")])])]),a._v(" "),e("li",[a._v("基于Setter方法的注入\n"),e("ol",[e("li",[a._v("在xml配置中使用properties")])])]),a._v(" "),e("li",[a._v("引用其他bean: ref 元素")]),a._v(" "),e("li",[a._v("集合, list")]),a._v(" "),e("li",[a._v("null, 空字符串")])]),a._v(" "),e("h4",{attrs:{id:"depends-on属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#depends-on属性"}},[a._v("#")]),a._v(" depends-on属性")]),a._v(" "),e("p",[a._v("显式强制初始化, 指定初始化时间依赖性")]),a._v(" "),e("h4",{attrs:{id:"懒加载bean"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#懒加载bean"}},[a._v("#")]),a._v(" 懒加载bean")]),a._v(" "),e("p",[a._v("lazy-init 属性")]),a._v(" "),e("h4",{attrs:{id:"自动装配"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自动装配"}},[a._v("#")]),a._v(" 自动装配")]),a._v(" "),e("p",[a._v("Spring让ApplicationContext自动解析这些关联关系")]),a._v(" "),e("ol",[e("li",[a._v("明显减少指定属性和构造函数")]),a._v(" "),e("li",[a._v("易于开发, 方便开发")]),a._v(" "),e("li",[a._v("容易出现歧义")])]),a._v(" "),e("h4",{attrs:{id:"方法注入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法注入"}},[a._v("#")]),a._v(" 方法注入")]),a._v(" "),e("p",[a._v("单例A想要每次调用多实例B时候使用")]),a._v(" "),e("h3",{attrs:{id:"bean作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bean作用域"}},[a._v("#")]),a._v(" Bean作用域")]),a._v(" "),e("ul",[e("li",[a._v("singleton\t单例, 唯一实例")]),a._v(" "),e("li",[a._v("prototype   多个实例")]),a._v(" "),e("li",[a._v("基于Web的ApplicationContext才能使用的作用域\n"),e("ul",[e("li",[a._v("request         单个http请求")]),a._v(" "),e("li",[a._v("session          http session生命周期")]),a._v(" "),e("li",[a._v("application    servlet context生命周期")]),a._v(" "),e("li",[a._v("websocket     websocket生命周期")])])])]),a._v(" "),e("h4",{attrs:{id:"singleton单例作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#singleton单例作用域"}},[a._v("#")]),a._v(" singleton单例作用域")]),a._v(" "),e("p",[a._v("Spring的单例作用域是以容器为前提")]),a._v(" "),e("h4",{attrs:{id:"prototype原型作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#prototype原型作用域"}},[a._v("#")]),a._v(" prototype原型作用域")]),a._v(" "),e("p",[a._v("每次被注入, 或者调用getBean() 都会得到全新的实例")]),a._v(" "),e("h3",{attrs:{id:"自定义bean的特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自定义bean的特性"}},[a._v("#")]),a._v(" 自定义Bean的特性")]),a._v(" "),e("p",[a._v("Spring提供了很多可用于自定义bean的特性")]),a._v(" "),e("h4",{attrs:{id:"生命周期回调"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期回调"}},[a._v("#")]),a._v(" 生命周期回调")]),a._v(" "),e("ol",[e("li",[e("code",[a._v("InitializingBean")]),a._v(" 和 "),e("code",[a._v("DisposableBean")]),a._v(" , bean初始化和销毁时执行, 不推荐使用")]),a._v(" "),e("li",[e("code",[a._v("@PostConstruct")]),a._v(" 和 "),e("code",[a._v("@PreDestroy")]),a._v(" JSR-250规范, 不会耦合到spring的特定接口, 推荐使用, 通常是最佳实践")]),a._v(" "),e("li",[e("code",[a._v("init-method")]),a._v(" 和 "),e("code",[a._v("destroy-method")])]),a._v(" "),e("li",[e("code",[a._v("BeanPostProcessor")]),a._v(" 容器扩展点")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("调用顺序 @PostConstruct - InitializingBean - init-method\n销毁也是同样顺序\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("p",[a._v("LifeCycle , LifecycleProcessor , SmartLifecycle , Phased")]),a._v(" "),e("h4",{attrs:{id:"applicationcontextaware-和-beannameaware"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#applicationcontextaware-和-beannameaware"}},[a._v("#")]),a._v(" ApplicationContextAware 和 BeanNameAware")]),a._v(" "),e("p",[e("strong",[a._v("ApplicationContextAware")]),a._v(": 当IoC创建了该接口的实现bean, 会 "),e("font",{attrs:{color:"11CC00"}},[a._v("为该实例提供IoC")]),a._v(" 自身的引用, 这样bean可以操作IoC, 比如常用的 "),e("font",{attrs:{color:"11CC00"}},[a._v("ConfigurableApplicationContext")])],1),a._v(" "),e("p",[e("strong",[a._v("BeanNameAware")]),a._v("  该接口实现类会在该bean属性配置完毕之后, 初始化回调之前, 调用setBeanName方法")]),a._v(" "),e("h4",{attrs:{id:"其他的aware接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其他的aware接口"}},[a._v("#")]),a._v(" 其他的Aware接口")]),a._v(" "),e("blockquote",[e("p",[a._v("进度报告 "),e("a",{attrs:{href:"https://github.com/DocsHome/spring-docs/blob/master/pages/core/IoC-container.md#beans-factory-autowire-candidate",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://github.com/DocsHome/spring-docs/blob/master/pages/core/IoC-container.md#beans-factory-autowire-candidate"),e("OutboundLink")],1)]),a._v(" "),e("p",[a._v("1.7. bean定义的继承")])]),a._v(" "),e("h4",{attrs:{id:"其他-aware-接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其他-aware-接口"}},[a._v("#")]),a._v(" 其他 Aware 接口")]),a._v(" "),e("h4",{attrs:{id:"bean生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bean生命周期"}},[a._v("#")]),a._v(" bean生命周期")]),a._v(" "),e("p",[a._v("支持JSR-250规范的回调, 对于Spring生命周期回调则需要实现 "),e("font",{attrs:{color:"11CC00"}},[a._v("InitializingBean, DisposableBean, Lifecycle, BeanFactoryAware, BeanNameAware, MessageSourceAware")]),a._v(" 这些接口")],1),a._v(" "),e("ul",[e("li",[a._v("bean 作用域 @Scope")]),a._v(" "),e("li",[a._v("bean 命名/别名, 描述")])]),a._v(" "),e("h4",{attrs:{id:"configuration使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#configuration使用"}},[a._v("#")]),a._v(" Configuration使用")]),a._v(" "),e("h4",{attrs:{id:"profiles环境抽象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#profiles环境抽象"}},[a._v("#")]),a._v(" Profiles环境抽象")]),a._v(" "),e("h4",{attrs:{id:"applicationcontext的额外功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#applicationcontext的额外功能"}},[a._v("#")]),a._v(" ApplicationContext的额外功能")]),a._v(" "),e("p",[a._v("标准事件和自定义事件")]),a._v(" "),e("ul",[e("li",[a._v("ApplicationListener 实现类部署到上下文中, 每次有ApplicationEvent发布到上下文中, Listener都会收到通知")])]),a._v(" "),e("h1",{attrs:{id:"msb课程内容"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#msb课程内容"}},[a._v("#")]),a._v(" msb课程内容")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/DocsHome",target:"_blank",rel:"noopener noreferrer"}},[a._v("翻译网站"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("a",{attrs:{href:"https://repo.spring.io/release/",target:"_blank",rel:"noopener noreferrer"}},[a._v("spring的jar包的下载地址"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("a",{attrs:{href:"https://repo.spring.io/release/org/springframework/spring/5.2.8.RELEASE/",target:"_blank",rel:"noopener noreferrer"}},[a._v("spring framework"),e("OutboundLink")],1),a._v(" dist(jar包) doc(文档)")]),a._v(" "),e("p",[a._v("有60+ jar包, 模块化, 可以只使用部分, 按需导入jar包")]),a._v(" "),e("p",[a._v("spring 八个模块, 需要导入的jar包")]),a._v(" "),e("p",[a._v("创建普通项目, 导入jar包, 编写spring的配置文件, 使用spring的入口: ApplicationContext 接口 拥有两个实现, 项目路径 和 当前文件系统路径 尝试IOC注入")]),a._v(" "),e("p",[a._v("测试出 IOC 注入的对象默认是什么时候创建的? 在容器创建完成之前就创建完成了")]),a._v(" "),e("h2",{attrs:{id:"第三节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三节"}},[a._v("#")]),a._v(" 第三节")]),a._v(" "),e("p",[a._v("spring的作用域 单例(直接加载) 原型(懒加载) (req session 几乎不用)")]),a._v(" "),e("p",[a._v("利用工厂模式创建bean对象 xml配置")]),a._v(" "),e("p",[a._v("beanfactory 接口是Spring内部工厂的顶层规范 Spring的容器都是它的具体实现 里面有 getBean containsBean 等方法")]),a._v(" "),e("p",[a._v("factorybean 接口定义了能生产或修饰对象生成的工厂Bean规范, 使用这个接口可以 自定义自己的工厂, 然后将这个bean 交给spring的IOC容器管理 , 是spring创建bean方式的一种补充(自定义) 都是懒加载")]),a._v(" "),e("p",[a._v("可以设置spring容器 在bean生命周期初始化, 销毁的方法 , 调用关闭IOC容器方法")]),a._v(" "),e("p",[a._v("BeanPostProcesser 对创建bean的过程进行增强 在初始化之前调用... 在初始化之后调用... springboot中大量使用了PostProcesser")]),a._v(" "),e("p",[a._v("spring 创建第三方对象(连接池..)")]),a._v(" "),e("p",[a._v("spring xml 中读取外部的配置文件 , 使用 spring xml 中的 context 命名空间 , value 中使用表达式, 需要注意表达式会读取到系统的环境变量")]),a._v(" "),e("p",[a._v("spring xml 自动装配 "),e("code",[a._v("autowire")]),a._v(" 属性 byName (依然对应set方法名) byType (所有地方对应class的对象都被装配了) constructor (比较复杂的装配先后顺序)")]),a._v(" "),e("p",[a._v("问题 为什么 byType 会加载环境变量 - map中的 Object 会被自动装备进环境变量")]),a._v(" "),e("p",[a._v("SpEL 的使用 spring express language")]),a._v(" "),e("p",[a._v("引入bean对象, bean对象的属性, 支持运算符操作, 调用静态方法, 非静态方法")]),a._v(" "),e("h2",{attrs:{id:"第四节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第四节"}},[a._v("#")]),a._v(" 第四节")]),a._v(" "),e("p",[a._v("spring IOC 的注解使用")]),a._v(" "),e("p",[a._v("Junit 单元测试")]),a._v(" "),e("p",[a._v("@Component Controller Service Repository 修饰后都可以注册类")]),a._v(" "),e("p",[a._v("使用注解, spring容器 需要配置注解扫描路径 (xml 配置 注解配置 需要 context 命名空间)")]),a._v(" "),e("p",[a._v("使用注解, 没有指定id , 默认按类名来指定(首字母小写)")]),a._v(" "),e("p",[a._v("@Scope 注解")]),a._v(" "),e("p",[a._v("context 配置扫描路径可以按规则排除或包括 @ComponentScan注解")]),a._v(" "),e("p",[a._v("@Autowired 启用自动装配/注入 (注入对应class 也就是默认使用byType, type重复了再 byName, 反正又是复杂的查找) - 修饰方法, 创建对象的时候方法会调用 , 方法参数自动传入 ;")]),a._v(" "),e("p",[a._v("@Qualifier 当注入具有相同类型时候 , 指定注入对象的 class 名")]),a._v(" "),e("p",[a._v("@Autowired vs @Resource 相同的功能, 区别 , spring提供和jdk提供 , 先按照类型/先按照名称 查找并自动装配")]),a._v(" "),e("p",[a._v("泛型依赖注入 byName, byType 之后, 再通过泛型查找 , 通过抽取泛型, 实现装配功能")]),a._v(" "),e("h2",{attrs:{id:"第五节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第五节"}},[a._v("#")]),a._v(" 第五节")]),a._v(" "),e("p",[a._v("Spring AOP")]),a._v(" "),e("p",[a._v("思路: 加减乘除方法的操作前后打印日志")]),a._v(" "),e("p",[a._v("讲解了一些动态代理 Proxy.newProxyInstance , jdk包下的反射的劣势: 必须要实现接口")]),a._v(" "),e("p",[a._v("写了很多动态代理的代码, 结果 AOP 就可以轻松实现这个功能")]),a._v(" "),e("p",[a._v("AOP 概念, 面向切面编程概念, 横切面, 通知, 切面, 连接点, 切入点(连接点的子集), 复杂难懂...")]),a._v(" "),e("p",[a._v("AOP的通知类型概念, 应用场景, AOP的使用, 注解 @Aspect , xml配置")]),a._v(" "),e("p",[a._v("通知注解类型 @Before @After @AfterReturing @AfterThrowing @Around")]),a._v(" "),e("p",[a._v("只讲解了基本使用, 主要写切面类")]),a._v(" "),e("h2",{attrs:{id:"第六节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第六节"}},[a._v("#")]),a._v(" 第六节")]),a._v(" "),e("p",[a._v("把日志信息补全")]),a._v(" "),e("p",[a._v("spring 通过是否实现接口自动选择使用 jdk代理 或 cglib代理 , 两个代理的效率比较")]),a._v(" "),e("p",[a._v("之前的基本写法, 切入点表达式 / 最精确匹配 ,")]),a._v(" "),e("p",[a._v("而实际常用的 通配符表达式")]),a._v(" "),e("p",[a._v("(* 匹配字符, 匹配参数类型, 注意 "),e("code",[a._v("*")]),a._v(" 无法匹配多级的目录)")]),a._v(" "),e("p",[a._v("(.. 表达式 可以匹配多个, 比如多级路径, 多个参数) 通过这两个组合出很多通配符")]),a._v(" "),e("p",[a._v("(&& || ! 表达式 ...)")]),a._v(" "),e("p",[a._v('@AfterReturning("execution(* *(..)))") // 切所有..')]),a._v(" "),e("p",[a._v("从这个通配符可以知道, 我们写项目的时候, 类名需要起的规范, 以便于通配符的匹配")]),a._v(" "),e("p",[a._v("通知的政策执行顺序 政策执行: before - after - afterreTurning  异常结束: before - after - afterThrowing")]),a._v(" "),e("p",[a._v("JoinPoint - AOP方法的参数 - 用于获取方法的信息, 方法参数的信息 getArgs")]),a._v(" "),e("p",[a._v("注解中的参数, 注解中配置返回值 Returning 异常 Throwing  参数 argNames, 并对应参数列表中的定义名字")]),a._v(" "),e("p",[a._v("通知方法的参数要求比较高, 其他的方法签名没有影响")]),a._v(" "),e("p",[a._v("多个匹配表达式相同, 抽象共用 @Pointcut 注解, 定义没有返回值的空方法(声明方法), 添加注解, 直接调用该方法名")]),a._v(" "),e("p",[a._v("@Around 使用 , 需要传入特殊的参数 , 自定义能力更强的一种代理方式 , 可以调用原方法, 可以修改调用结果了")]),a._v(" "),e("p",[a._v("环绕通知优先于普通通知, 执行的顺序是 : 环绕前置 - before - 环绕后置 - 环绕返回 - after - afterReturning/afterThrowing")]),a._v(" "),e("p",[a._v("当多个切面类作用同个方法的顺序, 默认按照切面类的首字母进行字典排序, 也可以注解@Order 指定顺序, 越小优先")]),a._v(" "),e("p",[a._v("声明式事务, @Transaction  事务管理器 TransactionManager")]),a._v(" "),e("h2",{attrs:{id:"第七节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第七节"}},[a._v("#")]),a._v(" 第七节")]),a._v(" "),e("p",[a._v("使用 spring xml 的 aop 命名空间配置方式 代替上节课的 aop 注解方式 包括声明切面, 通配符, 通知方法 ...")]),a._v(" "),e("p",[a._v("JDBC Template 玩玩就好, 没人用")]),a._v(" "),e("p",[a._v("使用jdbcTemplate 进行数据库操作, 增删改 查 , sqlDate是utilDate的子集")]),a._v(" "),e("p",[a._v("数据库事务自动提交 "),e("code",[a._v("select @@autocommit")]),a._v(" 代码默认不开启事务是由数据库控制, 1是自动提交事务")]),a._v(" "),e("p",[a._v("spring 支持编程式事务(自己写代码), 声明式事务(使用AOP) 两种")]),a._v(" "),e("p",[a._v("事务 - 题外话 , 跨行转账 - 多个系统间的分布式事务")]),a._v(" "),e("p",[a._v("使用 spring 自带的事务管理器 springxml 中需要使用 tx 命名空间 , 开启基于注解的事务管理配置")]),a._v(" "),e("p",[a._v("@Transactional 注解, 会对方法中对应操作进行整体的提交或回滚")]),a._v(" "),e("p",[a._v("事务和 try catch 的使用")]),a._v(" "),e("p",[a._v("声明式事务的几个参数 , 传播特性 , 隔离级别 , 超时时间, noRollBackFor, RollBackFor , readonly")]),a._v(" "),e("p",[a._v("spring事务的传播特性  传播特性使用 注解参数 和 xml参数 进行配置")]),a._v(" "),e("p",[a._v("NESTED 在于嵌套事务受外层事务影响")]),a._v(" "),e("p",[a._v("外层调用使用AOP, 传播特性, 内层调用是使用普通事务, 区别在于是否使用了 (对象点方法) , 直接调用的AOP无法生成代理代码")]),a._v(" "),e("p",[a._v("xml参数 AOP 事务建议")]),a._v(" "),e("p",[a._v("源码 - 从面试题作为切入点进行讲解")]),a._v(" "),e("p",[a._v("dubug , 没有写构造方法, 其实是调用了父类的构造方法")]),a._v(" "),e("p",[a._v("创建配置类, 加入系统环境变量, 读取xml文件, 解析表达式,")]),a._v(" "),e("p",[a._v("各种观察者模式 , 解析xml标签")]),a._v(" "),e("h2",{attrs:{id:"第八节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第八节"}},[a._v("#")]),a._v(" 第八节")]),a._v(" "),e("p",[a._v("继续看源码")]),a._v(" "),e("p",[a._v("创建BeanFactory , 忽略一些 aware , 创建好默认的DefaultListableBeanFactory")]),a._v(" "),e("p",[a._v("Reader 读取 xml")]),a._v(" "),e("p",[a._v("HandlerResolver - 处理xml的命名空间")]),a._v(" "),e("p",[a._v("ParseDelegate - 定义标签属性值")]),a._v(" "),e("p",[a._v("通过命名空间解析xml, 通过判断 bean 或者 自定义的命名空间 , 使用对应的 Handler 进行解析处理")]),a._v(" "),e("p",[a._v("读取解析 component-scan 这条配置 , 读取classpath下的class, 读取注解 ..")]),a._v(" "),e("p",[a._v("读取解析 bean 标签 , 获取 id , name , 判断唯一 , 获取class , scope 等所有属性 , 解析子标签")]),a._v(" "),e("p",[a._v("将信息放进DefaultListableBeanFactory维护的map中")]),a._v(" "),e("p",[a._v("AnnotationConfigUtils 默认给map中赋值了一些参数")]),a._v(" "),e("p",[a._v("初始化对象 , 解析spring EL , 对象进行增强 ApplicationContextAwareProcessor")]),a._v(" "),e("h2",{attrs:{id:"第九节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第九节"}},[a._v("#")]),a._v(" 第九节")]),a._v(" "),e("p",[a._v("invokeBeanFactoryPostProcessors 调用beanFactory的增强方法 , 解析 Processor")]),a._v(" "),e("p",[a._v("解析注解, 处理注解")]),a._v(" "),e("p",[a._v("finishBeanFactoryInitialization 生成Bean")]),a._v(" "),e("p",[a._v("earlySingletonExposure 循环引用问题")]),a._v(" "),e("h2",{attrs:{id:"第十节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第十节"}},[a._v("#")]),a._v(" 第十节")]),a._v(" "),e("p",[a._v("jdk 动态代理源码")])])}),[],!1,null,null,null);t.default=s.exports}}]);