(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{414:function(v,_,l){"use strict";l.r(_);var a=l(45),t=Object(a.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"进阶"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#进阶"}},[v._v("#")]),v._v(" 进阶")]),v._v(" "),l("h2",{attrs:{id:"基础"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[v._v("#")]),v._v(" 基础")]),v._v(" "),l("h3",{attrs:{id:"最差时间复杂度"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#最差时间复杂度"}},[v._v("#")]),v._v(" 最差时间复杂度")]),v._v(" "),l("p",[v._v("额外空间复杂度")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("时间复杂度相等时判断算法的优劣\n--拼常数项 (放弃理论分析, 生成随机数据测试)")]),v._v(" "),l("ul",[l("li",[v._v("插入排序好于冒泡排序")])])]),v._v(" "),l("li",[l("p",[v._v("常见时间复杂度排序")]),v._v(" "),l("ul",[l("li",[v._v("O(1) O(logN) O(N) O(NlogN) O(N^2) O(N^K) O(2^N) O(K^N) O(N!)")])])])]),v._v(" "),l("h3",{attrs:{id:"最优解"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#最优解"}},[v._v("#")]),v._v(" 最优解:")]),v._v(" "),l("p",[v._v("保证时间复杂度尽可能低同时空间复杂度低\n但: 不包括常数时间优化")]),v._v(" "),l("h3",{attrs:{id:"二分法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#二分法"}},[v._v("#")]),v._v(" 二分法")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("必要条件: 只要能正确构建左右两侧的淘汰逻辑")])]),v._v(" "),l("li",[l("p",[v._v("思路: 砍掉一半\n注意: 边界处理")])]),v._v(" "),l("li",[l("p",[v._v("题目")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("有序列表查询")]),v._v(" "),l("ul",[l("li",[v._v("L + ((R - L) >> 2)\n等价于(L+R)/2 且避免溢出")])])]),v._v(" "),l("li",[l("p",[v._v("满足>=n的最小位置")])]),v._v(" "),l("li",[l("p",[v._v("局部最小值")])])])])]),v._v(" "),l("h3",{attrs:{id:"位运算"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#位运算"}},[v._v("#")]),v._v(" 位运算")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("异或运算(无进位相加)")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("性质\n0 ^ N = N\nN ^ N = 0\n满足交换律和结合律")])]),v._v(" "),l("li",[l("p",[v._v("不用额外变量交换两个数 (通过交换律解释)")])]),v._v(" "),l("li",[l("p",[v._v("只一个数出现了奇数次, 其他都是偶数次")]),v._v(" "),l("ul",[l("li",[v._v("答案为所有数异或的结果")])])]),v._v(" "),l("li",[l("p",[v._v("提取int类型数的最右侧的1 (二进制)")]),v._v(" "),l("ul",[l("li",[v._v("a & (-a)")])])]),v._v(" "),l("li",[l("p",[v._v("两个数出现了奇数次, 找到这两个数")]),v._v(" "),l("ul",[l("li",[v._v("最终异或结果为 a ^ b\n结果肯定不为0, 那么取最右侧出现的位置\n通过这个位置为 0 或 1 , 将原数组分为两类数据\n结果: 通过该位置状态来异或到两个数据中")])])]),v._v(" "),l("li",[l("p",[v._v("有一种数出现K次, 其他数都出现了M次\nM > 1, K < M")]),v._v(" "),l("ul",[l("li",[v._v("创建int[32], 每位存储所有数对应二进制位数的出现次数")])])])])])]),v._v(" "),l("h3",{attrs:{id:"链表"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("翻转单链表/双向链表")])]),v._v(" "),l("li",[l("p",[v._v("删除指定元素(可能换头)")]),v._v(" "),l("ul",[l("li",[v._v("head先来到第一个不需要被删除的位置, 再后续")])])])]),v._v(" "),l("h3",{attrs:{id:"栈和队列"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#栈和队列"}},[v._v("#")]),v._v(" 栈和队列")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("用双向链表实现")])]),v._v(" "),l("li",[l("p",[v._v("用数组实现")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("栈 - 数组+位置")])]),v._v(" "),l("li",[l("p",[v._v("队列 - 循环数组")]),v._v(" "),l("ul",[l("li",[v._v("begin指向开始, end指向结尾\nsize控制是否可以增加")])])])])]),v._v(" "),l("li",[l("p",[v._v("实现特殊的栈, 额外返回栈中最小值")]),v._v(" "),l("ul",[l("li",[v._v("数据栈 + 最小栈; 同步记录")])])]),v._v(" "),l("li",[l("p",[v._v("用栈实现队列")]),v._v(" "),l("ul",[l("li",[v._v("push栈 + pop栈\npush栈必须一次性倒完\npop栈必须拿完才能倒数据\n封装倒数据函数 f()")])])]),v._v(" "),l("li",[l("p",[v._v("用队列实现栈")]),v._v(" "),l("ul",[l("li",[v._v("两个队列来回倒, 每次留最后一位返回\n来回倒通过互换引用指向轻松实现")])])]),v._v(" "),l("li",[l("p",[v._v("图中用栈实现宽度优先, 队列实现深度优先")])])]),v._v(" "),l("h3",{attrs:{id:"递归"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[v._v("#")]),v._v(" 递归")]),v._v(" "),l("ul",[l("li",[v._v("都可以改为非递归")]),v._v(" "),l("li",[v._v("master公式估计时间复杂度")])]),v._v(" "),l("h3",{attrs:{id:"哈希表和有序表"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#哈希表和有序表"}},[v._v("#")]),v._v(" 哈希表和有序表")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("Hash表")]),v._v(" "),l("ul",[l("li",[v._v("key要仔细区分按值传递和按引用传递")])])]),v._v(" "),l("li",[l("p",[v._v("有序表(接口)")])])]),v._v(" "),l("h3",{attrs:{id:"归并排序"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#归并排序"}},[v._v("#")]),v._v(" 归并排序")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("递归")]),v._v(" "),l("ul",[l("li",[v._v("取中点, 左边有序, 右边有序, 最后merge")]),v._v(" "),l("li",[v._v("merge : 简单的合并有序表")])])]),v._v(" "),l("li",[l("p",[v._v("迭代 : 通过2次方的步长进行循环调整")]),v._v(" "),l("ul",[l("li",[v._v("注意: 边界处理, 步长溢出")])])]),v._v(" "),l("li",[l("p",[v._v("求小和(总和)问题")]),v._v(" "),l("ul",[l("li",[v._v("一边merge, 一遍求小和出现的次数, 不断累加")])])]),v._v(" "),l("li",[l("p",[v._v("求所有逆序对问题")])]),v._v(" "),l("li",[l("p",[v._v("大于两倍问题")])]),v._v(" "),l("li",[l("p",[v._v("返回arr中, 累加和在[a, b]区间内的所有子数组")]),v._v(" "),l("ul",[l("li",[v._v("前置知识: 前缀和数组")]),v._v(" "),l("li",[v._v("首先转化为:\n求以对应下标n结尾的符合条件子数组\n其次转化为:\n因为(前缀和数组), 故0-n前缀和已知, 记为sum\n条件: (sum) - (x前缀和) ∈ [a, b] 区间, 等价于\n(x前缀和) ∈ [sum-b, sum-a] 求 x")]),v._v(" "),l("li",[v._v("使用merge sort, 求下标n右侧有多少位置达标")]),v._v(" "),l("li",[v._v("merge过程中一定是顺序的, 使用滑动窗口(双指针)")])])])]),v._v(" "),l("h3",{attrs:{id:"快速排序"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#快速排序"}},[v._v("#")]),v._v(" 快速排序")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("荷兰旗问题")]),v._v(" "),l("ul",[l("li",[v._v("给定x, 重构无序数组为:")])])])]),v._v(" "),l("ol",[l("li",[l("p",[v._v("小于等于x | 大于x")])]),v._v(" "),l("li",[l("p",[v._v("小于x | 等于x | 大于x")]),v._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",[l("code",[v._v(" - 一个区域: 小于等于区域\n - 两个区域: 小于区域, 大于区域\n - 根据情况扩张区域 / 移动下标\n")])])])])]),v._v(" "),l("ul",[l("li",[l("p",[v._v("快速排序1.0 (基于1)")])]),v._v(" "),l("li",[l("p",[v._v("快速排序2.0 (基于2)")]),v._v(" "),l("ul",[l("li",[v._v("以R划分, 递归调用partition(荷兰旗)")])])]),v._v(" "),l("li",[l("p",[v._v("快速排序3.0 随机快排")]),v._v(" "),l("ul",[l("li",[v._v("与2.0区别在于\n随机选择一个数放在R位置作为划分值")]),v._v(" "),l("li",[v._v("最优情况是划分值在中间, 最差情况是在两侧\n所以时间复杂度是概率期望 O(nlogn)\n空间复杂度是概率期望 O(logn)")]),v._v(" "),l("li",[v._v("迭代代码: 通过栈存放partition范围实现")])])])]),v._v(" "),l("h3",{attrs:{id:"比较器"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#比较器"}},[v._v("#")]),v._v(" 比较器")]),v._v(" "),l("ul",[l("li",[v._v("但条件, 多条件")])]),v._v(" "),l("h2",{attrs:{id:"分支主题-2"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#分支主题-2"}},[v._v("#")]),v._v(" 分支主题 2")]),v._v(" "),l("h2",{attrs:{id:"分支主题-3"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#分支主题-3"}},[v._v("#")]),v._v(" 分支主题 3")]),v._v(" "),l("p",[l("em",[v._v("XMind - Trial Version")])])])}),[],!1,null,null,null);_.default=t.exports}}]);