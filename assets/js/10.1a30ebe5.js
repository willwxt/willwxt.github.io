(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{369:function(a,t,e){"use strict";e.r(t);var s=e(45),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"_2021-04-19-阿里p6一面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2021-04-19-阿里p6一面"}},[a._v("#")]),a._v(" 2021-04-19 阿里P6一面")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/93471399",target:"_blank",rel:"noopener noreferrer"}},[a._v("题目来源"),e("OutboundLink")],1),a._v(" -- 阿里P6 一面 (主要偏java基础和底层，还有好多忘了)")]),a._v(" "),e("blockquote",[e("ol",[e("li",[a._v("Java中有哪些容器")]),a._v(" "),e("li",[a._v("类加载的双亲委派模型")]),a._v(" "),e("li",[a._v("hashmap , hashtable ,treemap区别")]),a._v(" "),e("li",[a._v("lock原理，AQS")]),a._v(" "),e("li",[a._v("了解哪些垃圾回收器和区别")]),a._v(" "),e("li",[a._v("创建线程池的参数")]),a._v(" "),e("li",[a._v("对于学习新技术自己的方法和步骤")])])]),a._v(" "),e("hr"),a._v(" "),e("h2",{attrs:{id:"java中有哪些容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java中有哪些容器"}},[a._v("#")]),a._v(" Java中有哪些容器")]),a._v(" "),e("p",[a._v("首先根据线程安全分为普通容器和并发容器, 当然还有java数组对象(这里略过)")]),a._v(" "),e("p",[a._v("我们可以根据java接口分为 "),e("code",[a._v("collection(包括list ,set ,queue)")]),a._v(" 和"),e("code",[a._v("map")]),a._v("  (按顺序开始聊, 首先是list, set直接和map一起)")]),a._v(" "),e("h4",{attrs:{id:"普通list"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#普通list"}},[a._v("#")]),a._v(" 普通list:")]),a._v(" "),e("p",[a._v("线性表(可以顺序读写), 通用实现为ArrayList和LinkedList")]),a._v(" "),e("h4",{attrs:{id:"arraylist"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#arraylist"}},[a._v("#")]),a._v(" ArrayList")]),a._v(" "),e("p",[a._v("使用数组实现, 数组(连续结构, 下标索引快, 频繁修改导致数组全拷贝)  各种操作可以视为常量级")]),a._v(" "),e("p",[a._v("背书: 初始容量10, 扩容过程(先将旧容量扩大50%, 与目标容量比较, 判断是否越界, 最后数组拷贝)")]),a._v(" "),e("h4",{attrs:{id:"linkedlist"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[a._v("#")]),a._v(" LinkedList")]),a._v(" "),e("p",[a._v("使用双向链表结构实现(头尾操作快, 索引慢, 添加删除快, 节点占用更多) 实现了队列/双向队列接口")]),a._v(" "),e("h4",{attrs:{id:"特殊的list"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特殊的list"}},[a._v("#")]),a._v(" 特殊的list")]),a._v(" "),e("p",[a._v("考虑线程安全的:")]),a._v(" "),e("ul",[e("li",[a._v("Vector 由synchronized保证线程安全")]),a._v(" "),e("li",[a._v("CopyOnWriteArrayList 写时复制, 由lock保证线程安全, 由两个数组保证效率")]),a._v(" "),e("li",[a._v("Collections.SynchronizedList 装饰者模式, 对主要方法进行包装, 非包装的方法不保证线程安全")])]),a._v(" "),e("p",[a._v("只读的 "),e("code",[a._v("Arrays.asList(Integer[]..)")]),a._v(" 以这种方式生成的list不允许增删")]),a._v(" "),e("h4",{attrs:{id:"普通的queue-deque都同理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#普通的queue-deque都同理"}},[a._v("#")]),a._v(" 普通的queue, deque都同理")]),a._v(" "),e("ul",[e("li",[a._v("普通的queue其实就LinkedList和ArrayDeque(数组实现), 只不过操作不同(offer, poll, peek), 一般都不支持null值")])]),a._v(" "),e("h4",{attrs:{id:"特殊的queue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特殊的queue"}},[a._v("#")]),a._v(" 特殊的queue")]),a._v(" "),e("ul",[e("li",[a._v("优先队列 PriorityQueue 堆排序实现")]),a._v(" "),e("li",[a._v("Collections的AsLIFOQueue (栈) (push, pop)")]),a._v(" "),e("li",[a._v("线程安全的 ConcurrentLinkedQueue")])]),a._v(" "),e("h4",{attrs:{id:"blockingqueue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#blockingqueue"}},[a._v("#")]),a._v(" blockingqueue")]),a._v(" "),e("p",[a._v("设计用于生产消费者队列, 线程安全, 对一些操作(插入, 删除, 检查), 拥有多种处理方式(抛出异常, 返回特殊值, 阻塞, 超时), 提供(take, put)")]),a._v(" "),e("ul",[e("li",[a._v("ArrayBlockingQueue: lock1+condition2(非空, 非满)实现, 可以指定int类型的队列长度, 同一把锁, 两个阻塞状态")]),a._v(" "),e("li",[a._v("LinkedBlokingQueue: lock2, condition2, take put两把锁(必要时还是两个一起锁的), 两个阻塞状态, 同样是int最大值的长度")]),a._v(" "),e("li",[a._v("DelayQueue 指定任务执行顺序, 按时间调度")]),a._v(" "),e("li",[a._v("SynchronousQueue 同步 生产者和消费者 的阻塞队列, 都需要阻塞等对方到...才能完成一次消费!")]),a._v(" "),e("li",[a._v("TransferQueue 增加了可以让生产者一直阻塞到消息消费完成的功能")]),a._v(" "),e("li",[a._v("其他: 往下拓展到lock, aqs实现, 向上是线程池, deque就跳过了")])]),a._v(" "),e("h4",{attrs:{id:"map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[a._v("#")]),a._v(" Map")]),a._v(" "),e("p",[a._v("保存键值对, key不可重复; 它提供了三个集合视图(key, value, entry); 一般不使用可变对象作为key, 因为对象属性变化可能导致equals不同")]),a._v(" "),e("h4",{attrs:{id:"hashmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" HashMap")]),a._v(" "),e("blockquote",[e("p",[a._v("扩展: 1.7和1.8的区别, put流程讲下, 哈希冲突, hashcode(), 与其他map的比较...")])]),a._v(" "),e("h2",{attrs:{id:"hashmap-hashtable-treemap区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-hashtable-treemap区别"}},[a._v("#")]),a._v(" hashmap , hashtable ,treemap区别")]),a._v(" "),e("h2",{attrs:{id:"lock原理-aqs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lock原理-aqs"}},[a._v("#")]),a._v(" lock原理，AQS")]),a._v(" "),e("p",[a._v("AbstractQueuedSynchronizer")]),a._v(" "),e("p",[a._v("ReentrantLock")]),a._v(" "),e("h2",{attrs:{id:"创建线程池的参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建线程池的参数"}},[a._v("#")]),a._v(" 创建线程池的参数")]),a._v(" "),e("h2",{attrs:{id:"了解哪些垃圾回收器和区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#了解哪些垃圾回收器和区别"}},[a._v("#")]),a._v(" 了解哪些垃圾回收器和区别")]),a._v(" "),e("h2",{attrs:{id:"类加载的双亲委派模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类加载的双亲委派模型"}},[a._v("#")]),a._v(" 类加载的双亲委派模型")]),a._v(" "),e("h2",{attrs:{id:"对于学习新技术自己的方法和步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对于学习新技术自己的方法和步骤"}},[a._v("#")]),a._v(" 对于学习新技术自己的方法和步骤，")])])}),[],!1,null,null,null);t.default=r.exports}}]);