(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{376:function(v,_,e){"use strict";e.r(_);var o=e(45),l=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("做了一道线程题, A和B生产/消费, 为什么不用线程池?")]),v._v(" "),e("p",[v._v("父子线程之间的通讯类, 如何进行通信")]),v._v(" "),e("ol",[e("li",[v._v("等待通知")]),v._v(" "),e("li",[v._v("管道PipedWriter,  PipedOutputStream")]),v._v(" "),e("li",[v._v("InheritableThreadLocal")])]),v._v(" "),e("p",[v._v("线程池是否了解?")]),v._v(" "),e("ol",[e("li",[v._v("使用锁和其他同步框架")]),v._v(" "),e("li",[v._v("核心线程数 不会归还OS的线程")]),v._v(" "),e("li",[v._v("最大线程数 超出核心线程, 最大额外扩展的线程总数")]),v._v(" "),e("li",[v._v("生存时间 额外线程不使用的timeout后还给OS")]),v._v(" "),e("li",[v._v("时间单位")]),v._v(" "),e("li",[v._v("任务队列 各种BlockingQueue, 用来装任务, 不同的队列可以产生不同的线程池")]),v._v(" "),e("li",[v._v("线程工厂, 需要传ThreadFactory, 实现newThread()方法, 定义产生线程的方式, 可以定义线程名字, 线程组名字(用于jstack排查问题!) 定义守护线程, 优先级等")]),v._v(" "),e("li",[v._v("拒绝策略")]),v._v(" "),e("li",[v._v("首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。")]),v._v(" "),e("li",[v._v("如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。")]),v._v(" "),e("li",[v._v("如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。")]),v._v(" "),e("li",[v._v("如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。")]),v._v(" "),e("li",[v._v("如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。")])]),v._v(" "),e("p",[v._v("项目使用的技术? 责任链模式为什么不做成工作流? 类MVC(使用责任链)->ORACLE->REDIS->ROCKETMQ->外部通讯方式")]),v._v(" "),e("p",[v._v("mysql一共有哪些索引及其使用的数据结构, B+, HASH, 倒排索引/全文索引")]),v._v(" "),e("ol",[e("li",[v._v("倒排索引/innodb倒排索引: 原来是通过匹配字符串数据的子串, 倒排索引是通过计算数据中含有分词的数量进行反向索引(拥有这些分词的数据有哪些), 查询时将查询条件分词后根据索引查找含有查询分词的数据集合")])]),v._v(" "),e("p",[v._v("一致性hash, 如何解决hash倾斜")]),v._v(" "),e("ol",[e("li",[v._v("通过映射到哈希环上, 让节点均分哈希环的槽位, 实现负载均衡, 查询时根据hash算法计算出槽位后就可以到指定节点查询数据")]),v._v(" "),e("li",[v._v("虚拟节点, 将高负载部分分割, 一半以虚拟节点的形式映射到低负载节点")])]),v._v(" "),e("p",[v._v("Spring, IOC的生命周期")]),v._v(" "),e("ol",[e("li",[v._v("ApplicationContext调用refresh方法, 创建DefaultListableBeanFactory -> 根据配置循环创建bean对象(先查找,再创建)\n-> 进行属性填充populateBean -> 再进行其他初始化操作")])]),v._v(" "),e("p",[v._v("bean生命周期")]),v._v(" "),e("ol",[e("li",[v._v("实例化->填充属性->aware接口->BeanPostProcessor前置\n->初始化方法->BeanPostProcessor后置(aop实现处)\n->获取完整对象->销毁(DispoableBean和销毁方法)")])]),v._v(" "),e("p",[v._v("JAVA线上问题如何排查")])])}),[],!1,null,null,null);_.default=l.exports}}]);