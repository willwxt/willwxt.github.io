(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{409:function(t,a,s){"use strict";s.r(a);var r=s(45),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("README")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/point/09system/algorithm/xiaobai/"}},[t._v("小白")]),t._v(" "),s("RouterLink",{attrs:{to:"/point/09system/algorithm/jinjie/"}},[t._v("进阶")])],1),t._v(" "),s("h4",{attrs:{id:"常见常数时间的操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见常数时间的操作"}},[t._v("#")]),t._v(" 常见常数时间的操作")]),t._v(" "),s("ol",[s("li",[t._v("常见的算术运算（+、-、*、/、% 等）")]),t._v(" "),s("li",[t._v("常见的位运算（>>带符号、>>>不带符号、<<、|、&、^等）")]),t._v(" "),s("li",[t._v("赋值、比较、自增、自减操作等")]),t._v(" "),s("li",[t._v("数组寻址操作")])]),t._v(" "),s("h4",{attrs:{id:"分析时间复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分析时间复杂度"}},[t._v("#")]),t._v(" 分析时间复杂度")]),t._v(" "),s("ol",[s("li",[t._v("想分析一个算法流程的时间复杂度的前提, 是对该流程非常熟悉")]),t._v(" "),s("li",[t._v("一定要确保在拆分算法流程时, 拆分出来的所有行为都是常数时间的操作。这意味着你写算法时, 对自己的用过的每一个系统api, 都非常的熟悉。否则会影响你对时间复杂度的估算。")])]),t._v(" "),s("h4",{attrs:{id:"额外空间复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#额外空间复杂度"}},[t._v("#")]),t._v(" 额外空间复杂度")]),t._v(" "),s("p",[t._v("自己必须开辟的额外空间")]),t._v(" "),s("h4",{attrs:{id:"常数项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常数项"}},[t._v("#")]),t._v(" 常数项")]),t._v(" "),s("p",[t._v("跑大数测试比较算法优劣")]),t._v(" "),s("h4",{attrs:{id:"认识对数器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#认识对数器"}},[t._v("#")]),t._v(" 认识对数器")]),t._v(" "),s("h4",{attrs:{id:"二分法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二分法"}},[t._v("#")]),t._v(" 二分法")]),t._v(" "),s("blockquote",[s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" mid "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("L")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("R")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("L")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 避免溢出")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" mid "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("L")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("R")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 同理")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//n*2+1 等价于 (n<<1)|1")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("局部最小")])]),t._v(" "),s("h4",{attrs:{id:"异或"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异或"}},[t._v("#")]),t._v(" 异或")]),t._v(" "),s("p",[t._v("无进位相加")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("0 ^ N = N\nN ^ N = 0\n异或运算满足交换律和结合律\n异或两者是指向内存中同一个地址的变量会出错\nN & ((~N) + 1) 取最右侧的1\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("h2",{attrs:{id:"排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#排序"}},[t._v("#")]),t._v(" 排序")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://www.runoob.com/wp-content/uploads/2019/03/sort.png",alt:"排序算法"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png",alt:""}})]),t._v(" "),s("ol",[s("li",[t._v("平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。")]),t._v(" "),s("li",[t._v("线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序;")]),t._v(" "),s("li",[t._v("O(n1+§)) 排序, § 是介于 0 和 1 之间的常数。 希尔排序")]),t._v(" "),s("li",[t._v("线性阶 (O(n)) 排序 基数排序, 此外还有桶、箱排序。")])]),t._v(" "),s("p",[t._v("关于"),s("font",{attrs:{color:"007fff"}},[t._v("稳定性")]),t._v(" : 排序后 2 个相等键值的顺序和排序之前它们的顺序相同")],1),t._v(" "),s("ol",[s("li",[t._v("稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。")]),t._v(" "),s("li",[t._v("不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。")])]),t._v(" "),s("h3",{attrs:{id:"归并排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#归并排序"}},[t._v("#")]),t._v(" 归并排序")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif",alt:"归并排序"}})]),t._v(" "),s("h4",{attrs:{id:"递归解法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#递归解法"}},[t._v("#")]),t._v(" 递归解法")]),t._v(" "),s("ul",[s("li",[t._v("取中点, 左边有序, 右边有序, 最后merge")]),t._v(" "),s("li",[t._v("merge : 简单的合并有序表")])]),t._v(" "),s("h4",{attrs:{id:"迭代解法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#迭代解法"}},[t._v("#")]),t._v(" 迭代解法")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("通过2次方的步长进行循环调整")])]),t._v(" "),s("li",[s("p",[t._v("注意: 边界处理, 步长溢出")])])]),t._v(" "),s("h4",{attrs:{id:"扩展问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#扩展问题"}},[t._v("#")]),t._v(" 扩展问题")]),t._v(" "),s("h4",{attrs:{id:"求小和-总和-问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#求小和-总和-问题"}},[t._v("#")]),t._v(" 求小和(总和)问题")]),t._v(" "),s("ul",[s("li",[t._v("一边merge, 一遍求小和出现的次数, 不断累加")])]),t._v(" "),s("h4",{attrs:{id:"求所有逆序对问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#求所有逆序对问题"}},[t._v("#")]),t._v(" 求所有逆序对问题")]),t._v(" "),s("h4",{attrs:{id:"大于两倍问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#大于两倍问题"}},[t._v("#")]),t._v(" 大于两倍问题")]),t._v(" "),s("h4",{attrs:{id:"返回arr中-累加和在-a-b-区间内的所有子数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#返回arr中-累加和在-a-b-区间内的所有子数组"}},[t._v("#")]),t._v(" 返回arr中, 累加和在[a, b]区间内的所有子数组")]),t._v(" "),s("ul",[s("li",[t._v("前置知识: 前缀和数组")])]),t._v(" "),s("p",[t._v("首先转化为:")]),t._v(" "),s("ul",[s("li",[t._v("求以对应下标 n 结尾的符合条件子数组")])]),t._v(" "),s("p",[t._v("其次转化为:")]),t._v(" "),s("ul",[s("li",[t._v("因为(前缀和数组), 故F(n)前缀和已知, 记为sum\n"),s("ul",[s("li",[t._v("条件: (sum) - (x前缀和) ∈ [a, b] 区间,")]),t._v(" "),s("li",[t._v("等价于 (x前缀和) ∈ [sum-b, sum-a] 求 x")])])]),t._v(" "),s("li",[t._v("使用merge sort, 求下标n右侧有多少位置达标")]),t._v(" "),s("li",[t._v("merge过程中一定是顺序的, 使用滑动窗口(双指针)")])]),t._v(" "),s("h3",{attrs:{id:"快速排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#快速排序"}},[t._v("#")]),t._v(" 快速排序")]),t._v(" "),s("p",[t._v("对于大多数情况, 快排总是优于归并")]),t._v(" "),s("h4",{attrs:{id:"荷兰旗问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#荷兰旗问题"}},[t._v("#")]),t._v(" 荷兰旗问题")]),t._v(" "),s("p",[t._v("输入乱序排列的三色小球, 通过两两交换, 达到分组效果")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdn.net/20141208162716843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHVxdXRvZ2V0aGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center",alt:"荷兰旗"}})]),t._v(" "),s("ul",[s("li",[t._v("3个指针head, middle (指向头) ; tail (指向尾);  0表示红, 1表示白, 2表示蓝")]),t._v(" "),s("li",[t._v("middle指针所指元素为0时, 与head指针所指的元素交换, 而后middle++, head++")]),t._v(" "),s("li",[t._v("middle指针所指元素为1时, 不做任何交换（即球不动）, 而后middle++")]),t._v(" "),s("li",[t._v("middle指针所指元素为2时, 与tail指针所指的元素交换, 而后, middle指针不动, tail--")])]),t._v(" "),s("p",[t._v("给定x, 将无序数组重构为以下结构:      ① 小于等于x || 大于x\t② 小于x || 等于x || 大于x")]),t._v(" "),s("ul",[s("li",[t._v("设定区域, 并根据情况扩张区域 / 移动下标")]),t._v(" "),s("li",[t._v("①选择设定一个区域: 小于等于区域")]),t._v(" "),s("li",[t._v("②选择设定两个区域: 小于区域 和 大于区域")])]),t._v(" "),s("h4",{attrs:{id:"快速排序-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#快速排序-2"}},[t._v("#")]),t._v(" 快速排序")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("以pivot基准划分, 递归调用 partition (分区操作 , (荷兰旗))")]),t._v(" "),s("ul",[s("li",[t._v("快速排序1.0 (基于①")]),t._v(" "),s("li",[t._v("快速排序2.0 (基于②")])])]),t._v(" "),s("li",[s("p",[t._v("快速排序3.0 随机快排")]),t._v(" "),s("ul",[s("li",[t._v("与2.0区别在于:  随机选择一个数作为基准")]),t._v(" "),s("li",[t._v("最优情况是划分值在中间, 最差情况是在两侧\n"),s("ul",[s("li",[t._v("所以时间复杂度是概率期望 O(nlogn)")]),t._v(" "),s("li",[t._v("空间复杂度是概率期望 O(logn)")])])]),t._v(" "),s("li",[t._v("迭代代码: 通过栈存放partition范围实现")])])])]),t._v(" "),s("h3",{attrs:{id:"堆排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆排序"}},[t._v("#")]),t._v(" 堆排序")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("创建一个堆 H[0……n-1]")])]),t._v(" "),s("li",[s("p",[t._v("先把最大的数浮到堆顶 (升序, 小顶堆), 将目前这个堆称为h1")]),t._v(" "),s("ul",[s("li",[t._v("此处浮到堆顶, 只需要检查所有非叶子节点")])]),t._v(" "),s("ol",[s("li",[t._v("把h1堆首和堆尾互换, 此时堆尾肯定是最大值, 队尾元素可以固定, 不再考虑")]),t._v(" "),s("li",[t._v("将堆的尺寸缩小 1 作为新的堆 h1, 调整顶端数据, 让堆顶的元素再次作为最大值\n"),s("ul",[s("li",[t._v("此处调整, 只需要将堆顶的向下沉到大小合适的位置即可")])])]),t._v(" "),s("li",[t._v("重复1和2; 直到 h1 只剩1个元素")])])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif",alt:""}})])])}),[],!1,null,null,null);a.default=v.exports}}]);