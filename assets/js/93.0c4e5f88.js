(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{449:function(e,t,n){"use strict";n.r(t);var a=n(45),l=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("0.基础\n硬件设备之间都需要通过IO进行通讯\nVFS 虚拟文件系统,linux把所有资源抽象为文件(包括io) 所有文件具有唯一inode文件id\npagecache页缓存(4k), 修改后dirty页的主动保存或自动写入策略/数据丢失\nFD文件描述符 拥有seek指针可以读取pagecache")]),e._v(" "),n("p",[e._v("linux其他知识: df挂载设备, ln链接, dd块设备 lsof显示进程打开哪些文件\npipeline 管道 父子进程 变量 指令块/代码块 系统调用 重定向操作符 proc目录\n中断 处理器对外开放的实时受控接口, 处理高优先级/突发事件,\nint 0x80中断, 用于切换用户态和内核态\ncpu mmu 虚拟地址和物理地址的转换 ; 缺页: 当程序运行过程中需要更多的内存,产生缺页异常,需要cpu再分配内存\n运行相同的程序,共享使用pagecache,可以只占用一份空间,比如相同文件被不同进程读到内存中使用相同位置的pagecache\nnetstat -natp 查看网络连接和占用的端口\ntcpdump -nn -i eth0 port 9090 开监听抓取数据包\nlsof -p <进程号> 查看某个进程已经打开的文件状态")]),e._v(" "),n("ol",[n("li",[e._v("文件IO\npagecache 是内核维护的中间层,减少硬件IO,优先使用内存提速,却产生可靠性问题\n如果你把redis或mysql的持久化规则设置为跟随操作系统的话,当你突然断电的时候,你会丢失很多数据\n在现在的分布式系统当中,不应该追求单点数据存储的强一致性")])]),e._v(" "),n("p",[e._v("FileOutputStream 和 BufferedOutputStream\n普通流系统调用(write)更多, Buffer是等数据足够8kB的时候再进行一次系统调用\nFileOutputStream 每次都进行系统调用 经历用户态-内核态切换\nBufferedOutputStream 系统调用单位次数更少")]),e._v(" "),n("p",[e._v("ByteBuffer 可以分配堆内/堆外(内外针对jvm而言,但还是在java进程的堆中) (内存IO)\nByteBuffer.allocateDirect(1024);\nBuffer: 本质上是数组,具有四个主要属性: Capacity容量,Limit限制,Pos位置,Mark标记; 读时pos在0,limit在size; 写时pos在size,limit在cap;")]),e._v(" "),n("p",[e._v("RandomAccessFile 的seek操作 文件IO 也是先写进pagecache\nFileChannel raf.getChannel();拿到RAF的FileChannel通道,获得MappedByteBuffer,可以直接操作映射的pagecache\nchannel: 封装了对数据源的操作(fd或socket), 可以使用Buffer对其读写, 封装了异步操作, Scatter / Gather;")]),e._v(" "),n("p",[e._v("DataInputStream 从二进制流中读取字节,并根据所有Java基本类型数据进行重构\nInputStream OutputStream 是字节流的抽象类\nReader Writer 是字符流的抽象类\nInputStreamReader OutputStreamWriter 字节流和字符流的桥梁,适配器模式\nPrintWriter 可以打印多种java数据类型,按照平台编码将字符串转换为字节,调用write写出")]),e._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[e._v("网络IO")])]),e._v(" "),n("p",[e._v("socket 是OS对tcp连接的抽象,通过调用socket的api可以进行tcp操作包括 bind listen accept\nsocket 是一个四元组 CIP CPORT SIP SPORT 内核级,数据包可以通过这个四元组识别唯一的连接,只要保持四元祖的唯一性,可以在同个端口开启多个连接\n文件描述符再对socket进行抽象,应用是通过操作文件描述符进行通信")]),e._v(" "),n("p",[e._v('TCP 面向连接的可靠的传输协议-三次握手-双方在内核开辟资源-用这两个资源代表这个连接\n一些socket的参数:\nbacklog 参数: 核心允许再开的TCP连接数,之后的不再回复确认包\n窗口机制 缓冲区 MTU(网卡可以看到,发送包的总大小) MSS(包体大小)\n如果需要发送比较大量的数据(一次发送很多包),但是每个包都要来回接受"我收到了"的通信,会浪费较多时间\n所以实现了一个窗口机制,可以连续发送一定数量的包, server按序处理\n但是如果server端的缓存满了, 之后发送的包就会丢失\nnodelay: 是否delay(优化) 开启的话直接发送, 关闭的话攒到一定数量的包再发送\nOOB: 先发一个包,只有一个值\nkeepalive: 确认资源/连接是否还存在,心跳')]),e._v(" "),n("p",[e._v("开启server端, 监听端口. 当有客户端请求连接, 经过三次握手建立连接(此时socket已建立连接ESTABLISHED,但是没有对应的线程). 客户端编写内容,回车发送,服务端并没有开辟线程去处理客户端发送内容,此时监控发现服务端和客户端的交互已经完成,数据存在服务端buffer(还未消费). 服务端开启线程再去处理,此时socket才分配了对应的线程,并且缓存的数据被消费")]),e._v(" "),n("p",[e._v("服务端80端口接收客户端连接之后,是否需要为客户端的连接分配一个随机端口号? 不需要\n客户端A开了很多连接占满了自己的65535个端口号,是否还能与另一个服务端建立连接? 可以")]),e._v(" "),n("ol",[n("li",[e._v("BIO NIO AIO IO模型\n完全阻塞模型 BIO 调用时直接阻塞,需要等待数据/事件返回才能继续运行\n非阻塞IO NIO 调用时不需要阻塞等待,直接返回(如果没有数据/事件返回-1),所以我们需要不断轮询\n多路复用IO\nselect: 调用并传入监视的fd集合,内核处理后函数返回所有fd,通过遍历fd来找到就绪的fd;存在fd数量限制\npoll: 参数中使用pollfd包装fd进行调用;和select相同的处理流程,同样需要遍历fd来找到就绪的fd,区别在于没有fd的数量限制\nepoll: 开启epoll并wait(专门阻塞等待事件返回),向epoll注册所有需要监听的fd,每当发生事件epoll会通知应用程序,比起poll减少fd的来回赋值和大量无效的fd集合轮询\nSIGIO: 比起epoll,不需要阻塞等待,通过SIGIO进行通知,但客户端还是需要处理事件\nasync io: 比起epoll,不需要收到事件再去处理,内核直接通过回调把事件处理完毕")])]),e._v(" "),n("p",[e._v("C10K问题 一台服务器C维持10k连接\n使用BIO建立连接很慢, 一秒仅能建立4个连接: 1.accept阻塞调用耗费资源 2.抛出线程耗费资源 ; 所以引入NIO\nNIO两个代表Non-block IO 和 New IO, 使用NIO每秒能建立大约50个连接,\n区别在于: BIO会阻塞,需要用不同线程来处理socket的accept和buffer的read两种阻塞; 而NIO是在同一个线程中,不断进行accept和read的嵌套循环,而不会阻塞\nC10K 报错超出文件描述符的数量 too many open file\nNIO的特点: 可以通过一个线程,处理N个IO;\n问题: 虽然线程减少,但存在大量无效的read调用, 需要用户态内核态切换, 浪费资源\n解决: 多路复用器\nepoll_create 在内核中开辟一块空间，用来放红黑树 ; epoll_ctl 记录fd并关注它的哪些事件 ; epoll_wait 在等待从红黑树复制过来的一个链表 ;")]),e._v(" "),n("p",[e._v("同步和异步, 主要关注消息通讯机制\n同步: 应用自己读写内容,或者说是需要等到调用结束之后再完成别的事情,而异步则不再需要关注调用结果如何\n异步: 由内核完成IO的读写,写到进程的一个buffer区域,看起来我们的应用程序没有访问IO,只是访问buffer")]),e._v(" "),n("p",[e._v("阻塞和非阻塞, 主要关注程序等待调用结果的状态\n阻塞: 线程挂起等待拿到返回值; 非阻塞: 线程继续执行,通过不断检查来获得返回结果")]),e._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[e._v("响应式编程Reactive Netty")])])])}),[],!1,null,null,null);t.default=l.exports}}]);