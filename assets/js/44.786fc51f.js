(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{399:function(a,t,s){"use strict";s.r(t);var r=s(45),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"kafka"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kafka"}},[a._v("#")]),a._v(" Kafka")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://xie.infoq.cn/article/8b753e8f20eca9404e45c33ad",target:"_blank",rel:"noopener noreferrer"}},[a._v("参考脑图"),s("OutboundLink")],1)]),a._v(" "),s("h2",{attrs:{id:"_01-kafka基本信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_01-kafka基本信息"}},[a._v("#")]),a._v(" 01.kafka基本信息")]),a._v(" "),s("p",[s("strong",[a._v("kafka概述")]),a._v(": 由Scala语言开发, 基于zookeeper的多分区多副本的分布式消息系统; 目前kafka定位为一个分布式流式处理平台, 具有高吞吐, 可持久化, 可水平扩容, 支持流数据处理等特性")]),a._v(" "),s("p",[s("strong",[a._v("特点")])]),a._v(" "),s("ol",[s("li",[a._v("消息系统本身具有的特点: 解耦, 流量削峰, 异步通信, 缓冲, 冗余存储; 提供消息顺序性, 回溯消费等特性")]),a._v(" "),s("li",[a._v("消息持久化, 可作为长期数据存储")]),a._v(" "),s("li",[a._v("流式处理平台: 提供可靠数据来源, 提供完整的流式处理类库 (窗口, 连接, 变换, 聚合等操作)")])]),a._v(" "),s("h4",{attrs:{id:"kafka体系结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kafka体系结构"}},[a._v("#")]),a._v(" kafka体系结构")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcubHVvemhpeXVuLmNvbS9ibG9nMTY5NDliZDYyNzlkZjEwNi5wbmc?x-oss-process=image/format,png",alt:"kafka structure"}})]),a._v(" "),s("h4",{attrs:{id:"基本概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[a._v("#")]),a._v(" 基本概念")]),a._v(" "),s("ul",[s("li",[a._v("producer: 生产者, 发送消息给服务器, 根据分区规则, 将消息存到具体分区")]),a._v(" "),s("li",[a._v("consumer: 消费者, 使用pull模式拉取消息, 并保存offset")]),a._v(" "),s("li",[a._v("broker: 服务器, 可以认为是kafka一个服务实例")]),a._v(" "),s("li",[a._v("zookeeper: 存储kafka每个服务实例(或者说kafka集群)的元数据信息, 负责数据管理, 选举等")])]),a._v(" "),s("h4",{attrs:{id:"特殊概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特殊概念"}},[a._v("#")]),a._v(" 特殊概念")]),a._v(" "),s("ul",[s("li",[a._v("Topic 主题: 是一个逻辑概念, 消息会以主题进行归类\n"),s("ul",[s("li",[a._v("生产者会将消息发到指定主题, 而消费者负责订阅主题进行消费")])])]),a._v(" "),s("li",[a._v("Partition 分区: 一个分区只能属于一个主题(主题分区), 真正流转消息的单位\n"),s("ul",[s("li",[a._v("分区在存储层面可以理解为追加日志文件")]),a._v(" "),s("li",[a._v("同一个主题下的不同分区包含不同的消息")]),a._v(" "),s("li",[a._v("不同消息在分区中持有唯一的偏移量offset, 用于保证消息顺序性, 但是offset并不跨区; kafka保证的是分区中有序, 不保证主题中有序")])])])]),a._v(" "),s("h4",{attrs:{id:"分区副本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分区副本"}},[a._v("#")]),a._v(" 分区副本")]),a._v(" "),s("p",[a._v("分区是多副本机制的(类似ES), 是主从模式, 主负责读写, 从负责备份/参与竞选;")]),a._v(" "),s("ul",[s("li",[a._v("AR (Assigned Replics) 所有副本统称 (AR = ISR + OSR)")]),a._v(" "),s("li",[a._v("ISR (In-Sync) 保持一定程度同步的副本集合 (有资格选举)")]),a._v(" "),s("li",[a._v("OSR (Out-of-Sync) 同步滞后过多的副本集合 (无资格)")]),a._v(" "),s("li",[a._v("HW (High Watermark 高水位) 特定的offset, 消费者只能pull到HW之前的消息!")]),a._v(" "),s("li",[a._v("LEO (Log End Offset) 下一条待写入消息的offset")]),a._v(" "),s("li",[a._v("以上概念为了权衡性能和一致性")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcubHVvemhpeXVuLmNvbS9ibG9nMTY5NDljZGY3Yzc3ZWVhZS5wbmc?x-oss-process=image/format,png",alt:"hw-leo"}})]),a._v(" "),s("h4",{attrs:{id:"主从同步-isr与hw-leo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主从同步-isr与hw-leo"}},[a._v("#")]),a._v(" 主从同步, ISR与HW,LEO")]),a._v(" "),s("ol",[s("li",[a._v("新增两条消息")]),a._v(" "),s("li",[a._v("leader 完成写操作, 但是follower还未同步, 此时HW和初始状态一直, 只能消费0~2")]),a._v(" "),s("li",[a._v("follower未同步完全, 但是已经可以消费0~3了!")]),a._v(" "),s("li",[a._v("最终同步完毕, 0~4都可以消费")])]),a._v(" "),s("p",[s("img",{attrs:{src:"http://image.honeypps.com/images/papers/2019/114.png",alt:"2"}})]),a._v(" "),s("p",[s("img",{attrs:{src:"http://image.honeypps.com/images/papers/2019/115.png",alt:"3"}})]),a._v(" "),s("p",[s("img",{attrs:{src:"https://static.studytime.xin/article/2020/11/16043177624510.jpg",alt:"4"}})]),a._v(" "),s("p",[s("img",{attrs:{src:"http://image.honeypps.com/images/papers/2019/116.png",alt:"5"}})]),a._v(" "),s("h2",{attrs:{id:"_02-kafka生产者"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_02-kafka生产者"}},[a._v("#")]),a._v(" 02.kafka生产者")]),a._v(" "),s("h3",{attrs:{id:"生产者客户端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生产者客户端"}},[a._v("#")]),a._v(" 生产者客户端")]),a._v(" "),s("h3",{attrs:{id:"原理分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原理分析"}},[a._v("#")]),a._v(" 原理分析")]),a._v(" "),s("p",[a._v("发送方式, 序列化器, 分区器, 拦截器")]),a._v(" "),s("h4",{attrs:{id:"必备参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#必备参数"}},[a._v("#")]),a._v(" 必备参数")]),a._v(" "),s("ol",[s("li",[a._v("bootstrap.servers  服务器地址列表")]),a._v(" "),s("li",[a._v("key.serializer  指定序列化方式")]),a._v(" "),s("li",[a._v("value.serializer")])]),a._v(" "),s("h4",{attrs:{id:"基本操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本操作"}},[a._v("#")]),a._v(" 基本操作")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//发送消息: ")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//发后即忘, ")]),a._v("\nproducer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("send")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("record")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//同步")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Future")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("RecordMetadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" future "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" producer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("send")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("record")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nfuture"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//同步阻塞等待")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//异步传入callback, 推荐")]),a._v("\nproducer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("send")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("record")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" callback"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br")])]),s("h4",{attrs:{id:"序列化器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#序列化器"}},[a._v("#")]),a._v(" 序列化器")]),a._v(" "),s("p",[a._v("StringSerializer源码: 默认UTF-8编码, 简单的将string转换为字节数组")]),a._v(" "),s("p",[a._v("当我们想要通讯一个自定义对象, 可以自定义序列化器, 将对象转为字节数组")]),a._v(" "),s("h4",{attrs:{id:"分区器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分区器"}},[a._v("#")]),a._v(" 分区器")]),a._v(" "),s("p",[a._v("非必需, 只有record中没有partition字段, 才需要分区器计算分区号")]),a._v(" "),s("h4",{attrs:{id:"生产者拦截器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生产者拦截器"}},[a._v("#")]),a._v(" 生产者拦截器")]),a._v(" "),s("p",[a._v("在发送消息对消息做处理, 过滤, 修改内容等")]),a._v(" "),s("h4",{attrs:{id:"生产者客户端整体架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生产者客户端整体架构"}},[a._v("#")]),a._v(" 生产者客户端整体架构")]),a._v(" "),s("ol",[s("li",[a._v("主线程: 创建消息message - interceptor拦截器 - serializer序列化器 - partitioner分区器")]),a._v(" "),s("li",[a._v("存入RecordAccumulator(消息收集器, 以便批量发送) , 这里已经分区存储了, 最大化网络资源, 但会增加延时")]),a._v(" "),s("li",[a._v("Sender: 封装成request, 缓存到InFlightRequests, 这里已经是分节点存储了, 提交, 等待kafka服务器响应")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcubHVvemhpeXVuLmNvbS9ibG9nMTY5NDlkZDVhODViNWZkZi5wbmc?x-oss-process=image/format,png",alt:""}})]),a._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[a._v("InFlightRequests将已发送还未回复数据最少的节点视为负载最小节点")]),a._v(" "),s("li",[a._v("元数据: kafka只需要配置一部分节点, 可以获取所有节点信息, 通过这些元数据信息找到消息需要发送到的目标节点")])]),a._v(" "),s("h3",{attrs:{id:"生产者参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生产者参数"}},[a._v("#")]),a._v(" 生产者参数")]),a._v(" "),s("div",{staticClass:"language-properties line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-properties"}},[s("code",[s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("acks")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("指定分区中必须有多少个副本收到这条消息, 才认为这条消息成功写入")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 默认1, 只要leader写入, 可选0(不需要服务端响应), -1(需要ISR所有副本写入成功)")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("max.request.size")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("限制生产者客户端发送的消息最大值")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("retries")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v(", retry.backoff.ms : 重试次数 (默认0不重试) , 重试间隔ms")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("compression.type")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("压缩方式")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("connections.max.idle.ms")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("关闭闲置的连接超时时间")]),a._v("\nlinger.ms\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("receive.buffer.bytes")]),a._v(" \nrequest.timeout.ms\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br")])]),s("h2",{attrs:{id:"_03-kafka消费者"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_03-kafka消费者"}},[a._v("#")]),a._v(" 03.kafka消费者")]),a._v(" "),s("p",[a._v("订阅, 反序列化, 位移提交, 再均衡, 消费者拦截器, 多线程使用, 消费者客户端配置")]),a._v(" "),s("h3",{attrs:{id:"消费者和消费组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费者和消费组"}},[a._v("#")]),a._v(" 消费者和消费组")]),a._v(" "),s("ol",[s("li",[a._v("topic只有一个消费组: 点对点")]),a._v(" "),s("li",[a._v("topic有多个消费组: Pub/Sub订阅")]),a._v(" "),s("li",[a._v("消费组可以通过增加组内消费者来提升整组的消费能力, 可也能消费者过多")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcubHVvemhpeXVuLmNvbS9ibG9nMTY5NGVjOTZhMDg3OWY3Yi5wbmc?x-oss-process=image/format,png",alt:"c-group"}})]),a._v(" "),s("p",[s("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcubHVvemhpeXVuLmNvbS9ibG9nMTZhYTY0MGU5YWY4OWZmMy5wbmc?x-oss-process=image/format,png",alt:"kuozhan"}})]),a._v(" "),s("h3",{attrs:{id:"消费者客户端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费者客户端"}},[a._v("#")]),a._v(" 消费者客户端")]),a._v(" "),s("ol",[s("li",[a._v("配置参数, 订阅主题, 拉取消息, 消费, 提交消费位移, 关闭消费者实例")])]),a._v(" "),s("h4",{attrs:{id:"消费客户端必输参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费客户端必输参数"}},[a._v("#")]),a._v(" 消费客户端必输参数")]),a._v(" "),s("ol",[s("li",[a._v("bootstrap.servers 与生产者同理")]),a._v(" "),s("li",[a._v("group.id 消费组, 上面已经解释, 必填")]),a._v(" "),s("li",[a._v("key.deserializer 和 value.deserializer 同理")])]),a._v(" "),s("h4",{attrs:{id:"订阅主题与分区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#订阅主题与分区"}},[a._v("#")]),a._v(" 订阅主题与分区")]),a._v(" "),s("p",[a._v("以下一共三种状态, 消费者只能选择使用一种")]),a._v(" "),s("ul",[s("li",[a._v("一个消费者可以订阅一个(主题名相同)或多个主题(正则) subscribe()")]),a._v(" "),s("li",[a._v("还可以订阅一个主题的特定分区 assign()")])]),a._v(" "),s("p",[a._v("自动再均衡功能: subscribe() 订阅主题时, 具有消费者自动 "),s("strong",[a._v("再均衡")]),a._v(" 功能")]),a._v(" "),s("h4",{attrs:{id:"反序列化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#反序列化"}},[a._v("#")]),a._v(" 反序列化")]),a._v(" "),s("p",[a._v("不推荐使用自定义反序列化器, 示例使用Protostuff做序列化")]),a._v(" "),s("h4",{attrs:{id:"消费消息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费消息"}},[a._v("#")]),a._v(" 消费消息")]),a._v(" "),s("ol",[s("li",[a._v("kafka的消费是一个不断调用poll()轮询拉取消费\n"),s("ul",[s("li",[a._v("poll还具有更多复杂功能: 消费位移, 消费协调器, 选举, 分区分配分发, 再均衡, 心跳......")])])]),a._v(" "),s("li",[a._v("取回的ConsumerRecord存储很多信息\n"),s("ul",[s("li",[a._v("主题, 所属分区, 分区偏移量, 创建时间和追加到日志的时间...")])])])]),a._v(" "),s("h4",{attrs:{id:"位移提交"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#位移提交"}},[a._v("#")]),a._v(" 位移提交")]),a._v(" "),s("ol",[s("li",[a._v("将对每个分区消费位移记录下来(持久化), ①记录消费位置, ②新消费者加入时能够得到消费位移")]),a._v(" "),s("li",[a._v("老版本的kafka中, 这个消费位移存在zookeeper中, 新版kafka存在__consumer_offsets主题中\n"),s("ul",[s("li",[a._v("双下划线开头的主题一般作为kafka的内部主题")])])]),a._v(" "),s("li",[a._v("具体是, 将(lastConsumedOffset)加1后作为当前消费位移, 提交给kafka\n"),s("ul",[s("li",[a._v("场景: 当前poll了 x+2 至 x+7 的偏移量, 在消费到x+5时发生故障")]),a._v(" "),s("li",[s("strong",[a._v("重复消费")]),a._v(": 先消费, 消费完毕后再提交消费; 故障恢复后重复消费x+2至x+4")]),a._v(" "),s("li",[s("strong",[a._v("消息丢失")]),a._v(": 先提交消费位移, 再消费; x+5至x+7消息将不会被消费")]),a._v(" "),s("li",[a._v("实际情况还有更复杂的case")])])]),a._v(" "),s("li",[a._v("默认情况下, 消费者每隔5秒将拉取到每个分区中的消息位移进行提交\n"),s("ul",[s("li",[a._v("开始消费, 在自动提交前崩溃, 恢复后重复消费")]),a._v(" "),s("li",[a._v("当处理线程崩溃, 而自动提交线程正常, 导致消息丢失")])])]),a._v(" "),s("li",[a._v("关闭自动提交(开启手动提交)\n"),s("ul",[s("li",[a._v("普通提交, 提交所有分区的消费位移")]),a._v(" "),s("li",[a._v("每次消费维度提交位移 (性能低)")]),a._v(" "),s("li",[a._v("分区维度进行提交位移")]),a._v(" "),s("li",[a._v("同步提交和异步提交")]),a._v(" "),s("li",[a._v("提交失败(CommitFailException等), 捕获异常做针对性处理")]),a._v(" "),s("li",[a._v("再均衡把关")])])])]),a._v(" "),s("h4",{attrs:{id:"控制或关闭消费"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#控制或关闭消费"}},[a._v("#")]),a._v(" 控制或关闭消费")]),a._v(" "),s("h4",{attrs:{id:"指定位移消费"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#指定位移消费"}},[a._v("#")]),a._v(" 指定位移消费")]),a._v(" "),s("p",[s("code",[a._v("auto.offset.reset")]),a._v(" 配置项指定默认读取消息位置 (当新的消费组建立时, 或其他情况下查找不到所记录的消费位移)")]),a._v(" "),s("p",[s("code",[a._v("seek()")]),a._v(" 方法: 从指定位置读取消息的能力")]),a._v(" "),s("h4",{attrs:{id:"再均衡"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#再均衡"}},[a._v("#")]),a._v(" 再均衡")]),a._v(" "),s("ol",[s("li",[a._v("概述: 分区所属权从一个消费者转移到另一个消费者")]),a._v(" "),s("li",[a._v("高可用, 伸缩性")]),a._v(" "),s("li",[a._v("再均衡发生期间, 消费组内无法读取消息")]),a._v(" "),s("li",[a._v("发生再均衡有可能导致消息的重复消费")]),a._v(" "),s("li",[a._v("避免不必要的再均衡发生")])]),a._v(" "),s("h4",{attrs:{id:"消费者拦截器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费者拦截器"}},[a._v("#")]),a._v(" 消费者拦截器")]),a._v(" "),s("p",[a._v("在消费消息或是提交消费位移时进行一些定制化操作")]),a._v(" "),s("ol",[s("li",[a._v("自定义拦截器实现消息TTL过期时间的功能")])]),a._v(" "),s("h4",{attrs:{id:"多线程实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多线程实现"}},[a._v("#")]),a._v(" 多线程实现")]),a._v(" "),s("ol",[s("li",[a._v("KafkaProducer是线程安全的, KafkaConsumer不是线程安全的")]),a._v(" "),s("li",[a._v("KafkaConsumer有acquire()方法, 检测是否只有一个线程操作")]),a._v(" "),s("li",[a._v("第一种: 多线程下, 一个线程对应一个KafkaConsumer实例, 一个线程消费一个或多个分区")]),a._v(" "),s("li",[a._v("第二种(不推荐): 多个线程同时消费一个分区, 通过assign和seek方法实现")]),a._v(" "),s("li",[a._v("第三种: 认为瓶颈是消息处理而不是消息接收, 可以让一个线程做接收, 然后用多线程的方式进行消费; 性能提升, 但是消息消费顺序更难保证了")])]),a._v(" "),s("h4",{attrs:{id:"重要的消费者参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重要的消费者参数"}},[a._v("#")]),a._v(" 重要的消费者参数")]),a._v(" "),s("div",{staticClass:"language-properties line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-properties"}},[s("code",[s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("fetch.min.bytes")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("一次poll()拉取的最小数据量")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("fetch.max.bytes")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("最大数据量(但不是绝对的最大值)")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("fetch.max.wait.ms")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("等待时间, 默认500ms")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("max.partition.fetch.bytes")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("配置每个分区里返回给Consumer的最大数据量(默认1MB)")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("max.poll.records")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("一次poll拉取的最大消息数量(默认500)")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("connections.max.idle.ms")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("多久之后关闭闲置的连接(默认9分钟)")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("exclude.internal.topics")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("= ")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("receive.buffer.bytes")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("= ")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("send.buffer.bytes")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("= ")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("request.timeout.ms")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("= ")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("metadata.max.age.ms")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("= ")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("reconnect.backoff.ms")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("重新连接的冷却时间, 避免频繁连接主机, 默认50ms")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("retry.backoff.ms")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("= ")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("isolation.level")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("消费者事务隔离级别, RU和RC可选, 分别可以读到HW和LSO")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br")])]),s("h2",{attrs:{id:"_04-主题和分区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_04-主题和分区"}},[a._v("#")]),a._v(" 04.主题和分区")]),a._v(" "),s("h3",{attrs:{id:"主题管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主题管理"}},[a._v("#")]),a._v(" 主题管理")]),a._v(" "),s("h4",{attrs:{id:"创建主题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建主题"}},[a._v("#")]),a._v(" 创建主题")]),a._v(" "),s("ol",[s("li",[a._v("生产者向一个尚未创建的主题发送消息, 默认创建主题(1个分区, 1个副本)")]),a._v(" "),s("li",[a._v("推荐: 把自动创建主题关闭, 通过kafka-topic.sh脚本来创建主题")]),a._v(" "),s("li",[a._v("一个主题会由多个分区组成, 一个分区可能由多个副本(日志)组成")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img2018.cnblogs.com/blog/1204119/201911/1204119-20191122000040480-372639560.png",alt:"wulijiegou"}})]),a._v(" "),s("h4",{attrs:{id:"主题操作api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主题操作api"}},[a._v("#")]),a._v(" 主题操作API")]),a._v(" "),s("div",{staticClass:"language-sh line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#主题的 增删改查, 配置管理")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#查看主题信息")]),a._v("\nkafka-topics.sh --zookeeper "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("172.17")]),a._v(".0.1:2181/kafka --describe -topic tokafeidou\t\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#创建主题kafeidou, 指定1副本, 1分区, 一些配置参数")]),a._v("\nkafka-topics.sh zookeeper localhost:2181/kafka "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("\n--create --topic kafeidou "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("\n--replication-factor "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("\n--partitions "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("\n--config cleanup.policy"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("compact "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("\n--config max.message.bytes"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("lOOOO\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#指定过broker机架信息的话, 会将分区/副本尽量分配到不同机架broker.rack")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br")])]),s("h4",{attrs:{id:"副本分配策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#副本分配策略"}},[a._v("#")]),a._v(" 副本分配策略")]),a._v(" "),s("h4",{attrs:{id:"配置管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置管理"}},[a._v("#")]),a._v(" 配置管理")]),a._v(" "),s("h4",{attrs:{id:"主题端参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主题端参数"}},[a._v("#")]),a._v(" 主题端参数")]),a._v(" "),s("h3",{attrs:{id:"kafkaadminclient"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kafkaadminclient"}},[a._v("#")]),a._v(" KafkaAdminClient")]),a._v(" "),s("p",[a._v("管理broker, 配置AccessControlList, 管理主题")]),a._v(" "),s("h3",{attrs:{id:"分区管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分区管理"}},[a._v("#")]),a._v(" 分区管理")]),a._v(" "),s("h4",{attrs:{id:"优先副本的选举"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优先副本的选举"}},[a._v("#")]),a._v(" 优先副本的选举")]),a._v(" "),s("ul",[s("li",[a._v("均匀分布的分区副本, 当一个broker挂掉后, 在其中为leader副本的分区进行选举, 从而保证可用")]),a._v(" "),s("li",[a._v("在恢复可用的过程中, leader会一直向始终正常的节点迁移, 导致负载失衡")]),a._v(" "),s("li",[s("strong",[a._v("优先副本/分区自动平衡")]),a._v(": 定时任务计算每个broker的节点不平衡率, 超过阈值触发优先副本选举")]),a._v(" "),s("li",[a._v("生产情况不推荐开启自动平衡, 推荐手动执行分区平衡")]),a._v(" "),s("li",[a._v("很消耗资源, 提供小批量(部分分区)的优先副本选举")])]),a._v(" "),s("h4",{attrs:{id:"分区重分配"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分区重分配"}},[a._v("#")]),a._v(" 分区重分配")]),a._v(" "),s("ul",[s("li",[a._v("一个节点宕机下线, 并不会把节点上的数据转交给其他节点")]),a._v(" "),s("li",[a._v("一个新节点加入, 之前的主题分区不会自动分配到新节点, 只有新创建的才会, 导致不均衡")]),a._v(" "),s("li",[s("strong",[a._v("分区重分配")]),a._v(": 使用脚本对分区副本再次进行合理的分配 (数据迁移: 数据同步后删除旧副本)")]),a._v(" "),s("li",[a._v("对集群性能有很大影响, 占用网络和磁盘资源, 可以降低重分配粒度, 小批次执行")])]),a._v(" "),s("h4",{attrs:{id:"复制限流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#复制限流"}},[a._v("#")]),a._v(" 复制限流")]),a._v(" "),s("p",[a._v("对副本间的复制流量加以限制来保证重分配期间服务不受太大影响")]),a._v(" "),s("h4",{attrs:{id:"修改副本因子-副本数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#修改副本因子-副本数"}},[a._v("#")]),a._v(" 修改副本因子(副本数)")]),a._v(" "),s("p",[a._v("扩容/缩容")]),a._v(" "),s("h3",{attrs:{id:"如何选择合适的分区数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何选择合适的分区数"}},[a._v("#")]),a._v(" 如何选择合适的分区数")]),a._v(" "),s("p",[a._v("根据实际业务场景, 软硬件条件, 负载情况来做具体考量")]),a._v(" "),s("h4",{attrs:{id:"性能测试工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#性能测试工具"}},[a._v("#")]),a._v(" 性能测试工具")]),a._v(" "),s("p",[a._v("并不是分区越多性能越好")]),a._v(" "),s("h4",{attrs:{id:"分区数上限"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分区数上限"}},[a._v("#")]),a._v(" 分区数上限")]),a._v(" "),s("p",[a._v("Too many open files 常见的linux系统错误, 通常为文件描述符不足")]),a._v(" "),s("div",{staticClass:"language-sh line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("ulimit")]),a._v(" -n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#查看文件描述符, 还有参数是 -S(软) 和 -H(硬)")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("h4",{attrs:{id:"考量因素-总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#考量因素-总结"}},[a._v("#")]),a._v(" 考量因素 & 总结")]),a._v(" "),s("h2",{attrs:{id:"_05-kafka日志存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_05-kafka日志存储"}},[a._v("#")]),a._v(" 05.kafka日志存储")]),a._v(" "),s("h3",{attrs:{id:"文件目录格式布局"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文件目录格式布局"}},[a._v("#")]),a._v(" 文件目录格式布局")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img2018.cnblogs.com/blog/1204119/201911/1204119-20191122000040480-372639560.png",alt:"wulijiegou"}})]),a._v(" "),s("ol",[s("li",[a._v("防止Log过大, 又引入了日志分段(LogSegment);")]),a._v(" "),s("li",[a._v("事实上, Log是文件夹, LogSegment对应磁盘上的一个日志文件和两个索引文件")]),a._v(" "),s("li",[a._v("Log对应一个命名为 "),s("code",[a._v("topic-partition")]),a._v(" 的文件夹")]),a._v(" "),s("li",[a._v("文件均以偏移量命名: 00000000000000000000.log")])]),a._v(" "),s("h3",{attrs:{id:"日志格式的演变"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#日志格式的演变"}},[a._v("#")]),a._v(" 日志格式的演变")]),a._v(" "),s("h3",{attrs:{id:"日志索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#日志索引"}},[a._v("#")]),a._v(" 日志索引")]),a._v(" "),s("ol",[s("li",[a._v("偏移量索引")]),a._v(" "),s("li",[a._v("时间戳索引")])]),a._v(" "),s("h3",{attrs:{id:"日志清理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#日志清理"}},[a._v("#")]),a._v(" 日志清理")]),a._v(" "),s("ol",[s("li",[a._v("日志删除\n"),s("ul",[s("li",[a._v("基于时间(默认7天), 基于日志大小(默认Log文件1G), 基于日志起始偏移量(删除logStartOffset之前的)的日志保留策略")])])]),a._v(" "),s("li",[a._v("日志压缩")])]),a._v(" "),s("h3",{attrs:{id:"磁盘存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#磁盘存储"}},[a._v("#")]),a._v(" 磁盘存储")]),a._v(" "),s("ul",[s("li",[a._v("磁盘顺序IO和随机IO性能差6000倍, 磁盘顺序IO比内存随机IO还要快")]),a._v(" "),s("li",[a._v("kafka在设计的时候采用文件追加的方式来写入消息")])]),a._v(" "),s("h4",{attrs:{id:"页缓存pagecache"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#页缓存pagecache"}},[a._v("#")]),a._v(" 页缓存pagecache")]),a._v(" "),s("ol",[s("li",[a._v("页缓存是操作系统实现的一种主要的磁盘缓存, 用来减少对磁盘IO的操作")]),a._v(" "),s("li",[a._v("流程, 类似redis缓存层:\n"),s("ol",[s("li",[a._v("读取: 先查询目标page是否在pagecache中, 有就直接返回; 否则读取磁盘并存入页缓存, 再将数据返回")]),a._v(" "),s("li",[a._v("写入: 先写入pagecache中并标记为脏页, 最后在合适的时间(根据OS配置)写入磁盘")]),a._v(" "),s("li",[s("code",[a._v("vm.dirty_background_ratio")]),a._v(" 当脏页数量达到系统内存的百分多少时触发flush回写进程")])])]),a._v(" "),s("li",[a._v("常识: Java对象内存开销非常大, 是真实数据的数倍, 空间利用率低下, 所以kafka大量使用直接内存(页缓存), 同时也提供同步刷盘fsync功能保证可靠性(不建议使用, 请用多副本来保障)")]),a._v(" "),s("li",[a._v("使用内存时, 请禁用swap分区以避免内存交换")])]),a._v(" "),s("h4",{attrs:{id:"磁盘io流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#磁盘io流程"}},[a._v("#")]),a._v(" 磁盘IO流程")]),a._v(" "),s("p",[a._v("不同API调用场景:")]),a._v(" "),s("ul",[s("li",[a._v("用户调用标准C库进行IO操作: 应用程序buffer >> C库标准IObuffer >> 文件系统页缓存 >> 通过文件系统到磁盘")]),a._v(" "),s("li",[a._v("用户调用文件IO: 应用程序buffer >> 文件系统页缓存 >> 通过具体文件系统到磁盘")]),a._v(" "),s("li",[a._v("用户打开文件时使用O_DIRECT: 绕过页缓存直接读写磁盘")]),a._v(" "),s("li",[a._v("用户使用类似dd工具, 并使用direct参数, 绕过系统cache和文件系统, 直接写磁盘")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img2020.cnblogs.com/blog/1393475/202006/1393475-20200618160454583-229079948.png",alt:"disk-io-process"}})]),a._v(" "),s("ol",[s("li",[a._v("写操作 (异步): 用户调用fwrite把数据写入C标准IObuffer即返回成功; IObuffer会将多次小数据量合并写入页缓存; 内核pdflush不断检测脏页并写回磁盘")]),a._v(" "),s("li",[a._v("读操作 (同步): 用户调用fread读C库标准IObuffer, 读页缓存, 发起IO请求同步数据到页缓存和IObuffer, 最后返回;")]),a._v(" "),s("li",[a._v("IO请求处理: 通用快根据IO请求构造一个或多个bio结构提交到调度层; 调度器将bio结构进行排序和合并, 尽量满足顺序读;")])]),a._v(" "),s("p",[a._v("针对不同应用场景, 可选不同IO调度策略")]),a._v(" "),s("ol",[s("li",[a._v("NOOP算法(No Operation): 最简单的FIFO, 加上相邻IO合并")]),a._v(" "),s("li",[a._v("CFQ算法(Completely Fair Queuing): 按照IO请求的地址进行排序, 大致是按照顺序消费\n"),s("ul",[s("li",[a._v("是默认的磁盘调度算法, 目的是减少磁盘旋转次数, 增加SAS盘吞吐量")]),a._v(" "),s("li",[a._v("但是IO并非有序, 先来的请求可能一直得不到执行, 造成饥饿")])])]),a._v(" "),s("li",[a._v("DEADLINE: 在CFQ的基础上, 解决了IO饥饿的极端情况\n"),s("ul",[s("li",[a._v("除了CFQ线程, 额外增加读IO队列 和 写IO队列")])])]),a._v(" "),s("li",[a._v("ANTICIPATORY: 对顺序读做优化, 适合随机IO和顺序IO混合的场景\n"),s("ul",[s("li",[a._v("在DEADLINE基础上为每个读IO设置了6ms等待时间, 期间内收到相邻位置IO, 则立即满足")])])])]),a._v(" "),s("p",[a._v("测试后选择适合业务的IO调度策略; 文件系统推荐使用 EXT4 或 XFS")]),a._v(" "),s("h4",{attrs:{id:"零拷贝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#零拷贝"}},[a._v("#")]),a._v(" 零拷贝")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://torgor.github.io/2020/04/01/zero-copy/",target:"_blank",rel:"noopener noreferrer"}},[a._v("可以参考的零拷贝文档"),s("OutboundLink")],1)]),a._v(" "),s("ul",[s("li",[a._v("概念: 将数据直接从磁盘文件复制到网卡设备中, 不需要经由应用程序之手; 大大提高应用程序性能, 减少内核与用户态之间的上下文切换")]),a._v(" "),s("li",[a._v("Linux中, 零拷贝依赖于 sendfile() 方法实现; 对应Java语言中的 FileChannel.transferTo()")])]),a._v(" "),s("p",[a._v("普通拷贝: 读取文件, 再用socket发送出去")]),a._v(" "),s("ol",[s("li",[a._v("将磁盘文件读取到操作系统内核read buffer")]),a._v(" "),s("li",[a._v("将内核缓冲区数据copy到application应用程序的buffer")]),a._v(" "),s("li",[a._v("将application应用程序buffer中的数据 copy到内核socket buffer")]),a._v(" "),s("li",[a._v("将socket buffer的数据copy到网卡, 由网卡进行网络传输")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://pic4.zhimg.com/80/v2-07f829c7a070c3444b1d8c99d4afd1bb_720w.jpg",alt:"非零拷贝"}})]),a._v(" "),s("p",[s("strong",[a._v("零拷贝")]),a._v(": 指的是没有经过CPU拷贝; 内核态下没有拷贝;")]),a._v(" "),s("ol",[s("li",[a._v("将磁盘文件读取到操作系统内核read buffer")]),a._v(" "),s("li",[a._v("只有数据位置, 数据长度等信息加载到 socket buffer中")]),a._v(" "),s("li",[a._v("DMA引擎直接将数据从内核的 read buffer 中传递到网卡")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://torgor.github.io/styles/images/zerocopy/zero-copy.jpeg",alt:"zero-copy"}})]),a._v(" "),s("h2",{attrs:{id:"_06-kafka服务端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_06-kafka服务端"}},[a._v("#")]),a._v(" 06.kafka服务端")]),a._v(" "),s("h3",{attrs:{id:"协议设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协议设计"}},[a._v("#")]),a._v(" 协议设计")]),a._v(" "),s("h3",{attrs:{id:"时间轮-timingwheel"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间轮-timingwheel"}},[a._v("#")]),a._v(" 时间轮 TimingWheel")]),a._v(" "),s("p",[a._v("在增删时比jdk自带时间组件有更优的时间复杂度 O(1), 具体实现...")]),a._v(" "),s("h3",{attrs:{id:"延时操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#延时操作"}},[a._v("#")]),a._v(" 延时操作")]),a._v(" "),s("p",[a._v("kafka中很多地方使用延时操作, 比如消息全同步下, 等leader写入完毕后, 启动延时操作同步followers")]),a._v(" "),s("h3",{attrs:{id:"控制器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#控制器"}},[a._v("#")]),a._v(" 控制器")]),a._v(" "),s("p",[a._v("kafka集群中有一个broker会被选举为控制器(kafka controller)")]),a._v(" "),s("ol",[s("li",[a._v("负责管理整个集群中所有分区和副本的状态;")]),a._v(" "),s("li",[a._v("当检测到某个分区的leader出现故障, 由控制器负责为该分区选举新的leader")]),a._v(" "),s("li",[a._v("当检测到某个分区的ISR集合发生变化, 由控制器负责通知所有broker更新其元数据信息")])]),a._v(" "),s("h4",{attrs:{id:"控制器的选举与异常恢复"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#控制器的选举与异常恢复"}},[a._v("#")]),a._v(" 控制器的选举与异常恢复")]),a._v(" "),s("p",[a._v("kafka中的控制器选举工作依赖于zookeeper, 成功选举后会在zk中创建 /controller 临时节点")]),a._v(" "),s("ol",[s("li",[a._v("broker启动时, 回去尝试读取该 /controller 节点, 只有节点存在并且数据正常, 表示已有控制器")]),a._v(" "),s("li",[a._v("如果节点不存在或者数据异常, 那么broker会尝试去创建 /controller 节点, 只有创建成功的broker成为控制器")])]),a._v(" "),s("p",[a._v("此外还有一个 /controller_epoch 持久节点, 用于记录控制器发生变更的次数, 或者说控制器的纪元")]),a._v(" "),s("ul",[s("li",[a._v("kafka用纪元来保证kafka中控制器的唯一性: 纪元是根据控制器当选顺序递增的, 每个控制器交互请求都会带上epoch, 如果小于纪元说明该请求已过期, 如果大于纪元说明有新的控制器当选了;")])]),a._v(" "),s("p",[a._v("旧版kafka没有控制器概念, 严重依赖zk, 每个broker会在zk上建立大量的监听器来管理分区和副本状态; 引入控制器后, 只有控制器相关的少量监听器注册到zk上, 减少zk依赖;")]),a._v(" "),s("h4",{attrs:{id:"分区leader的选举"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分区leader的选举"}},[a._v("#")]),a._v(" 分区leader的选举")]),a._v(" "),s("ol",[s("li",[a._v("当创建分区或分区上线(leader下线): 以OfflinePartitionLeaderElectionStrategy作为选举策略\n"),s("ul",[s("li",[a._v("该策略的思路是按照 AR 集合中的副本顺序查找第一个存活的并且在ISR中的副本")])])]),a._v(" "),s("li",[a._v("分区重分配: ReassignPartitionLeaderElectionStrategy策略\n"),s("ul",[s("li",[a._v("从重分配的AR列表中找到第一个存活且在ISR中的副本")])])]),a._v(" "),s("li",[a._v("优先副本选举: PreferredReplicaPartitionLeaderElectionStrategy\n"),s("ul",[s("li",[a._v("直接将优先副本设置为leader")])])]),a._v(" "),s("li",[a._v("节点优雅关闭: ControlleredShutdownPartitionElectionStrategy\n"),s("ul",[s("li",[a._v("从AR中找到第一个存活且在ISR中同时确保这个副本不在被关闭的节点上")])])])]),a._v(" "),s("h4",{attrs:{id:"优雅关闭kafka"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优雅关闭kafka"}},[a._v("#")]),a._v(" 优雅关闭kafka")]),a._v(" "),s("h3",{attrs:{id:"参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参数"}},[a._v("#")]),a._v(" 参数")]),a._v(" "),s("p",[a._v("broker.id 和 booststrap.servers")]),a._v(" "),s("h4",{attrs:{id:"服务端重要参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务端重要参数"}},[a._v("#")]),a._v(" 服务端重要参数")]),a._v(" "),s("div",{staticClass:"language-properties line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-properties"}},[s("code",[s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("auto.create.topics.enable")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("是否开启自动创建主题")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("auto.leader.rebalance.enable")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("是否leader自动再均衡")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("background.threads")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("后台任务线程数")]),a._v("\n...\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("h2",{attrs:{id:"_07-kafka客户端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_07-kafka客户端"}},[a._v("#")]),a._v(" 07.kafka客户端")]),a._v(" "),s("p",[a._v("深入客户端底层原理")]),a._v(" "),s("h3",{attrs:{id:"分区分配策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分区分配策略"}},[a._v("#")]),a._v(" 分区分配策略")]),a._v(" "),s("p",[a._v("kafka提供了消费者与订阅主题之间的分区分配策略")]),a._v(" "),s("h4",{attrs:{id:"rangeassignor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rangeassignor"}},[a._v("#")]),a._v(" RangeAssignor")]),a._v(" "),s("p",[a._v("按照消费者总数和分区总数进行整除运算来获得一个跨度, 根据跨度进行平均分配, 保证分区尽可能均匀地分配给消费者")]),a._v(" "),s("h4",{attrs:{id:"roundrobinassignor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#roundrobinassignor"}},[a._v("#")]),a._v(" RoundRobinAssignor")]),a._v(" "),s("p",[a._v("将消费组内: 所有消费者, 所有订阅的主题分区进行排序后, 把分区依次轮询分配给消费者")]),a._v(" "),s("h4",{attrs:{id:"stickyassignor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stickyassignor"}},[a._v("#")]),a._v(" StickyAssignor")]),a._v(" "),s("p",[a._v("目的: 1.分配尽可能均匀, 2尽可能与上次分配保持相同")]),a._v(" "),s("h4",{attrs:{id:"自定义分区分配策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自定义分区分配策略"}},[a._v("#")]),a._v(" 自定义分区分配策略")]),a._v(" "),s("p",[a._v("实现 org.apache.kafka.clients.consumer.internals.PartitionAssignor 接口")]),a._v(" "),s("h3",{attrs:{id:"消费者协调器与组协调器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费者协调器与组协调器"}},[a._v("#")]),a._v(" 消费者协调器与组协调器")]),a._v(" "),s("p",[a._v("旧版kafka使用zk的监听器实现协调功能的")]),a._v(" "),s("ol",[s("li",[a._v("羊群效应 Herd Effect: zk中一个被监听的节点变化, 大量的Watcher通知发送到客户端, 导致期间其他操作延迟")]),a._v(" "),s("li",[a._v("脑裂问题 Split Brain: 消费者再均衡操作时每个消费者都与zk进行通信以判断消费者或broker的变化情况, 由于zk本身问题, 同一时刻状态可能不一致")])]),a._v(" "),s("p",[a._v("GroupCoordinator和 ConsumerCoordinator的重要职责就是负责执行消费者再均衡的操作")]),a._v(" "),s("p",[a._v("详细...")]),a._v(" "),s("h3",{attrs:{id:"consumer-offsets剖析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#consumer-offsets剖析"}},[a._v("#")]),a._v(" __consumer_offsets剖析")]),a._v(" "),s("p",[a._v("位移提交的内容最终保存在 "),s("code",[a._v("__consumer_offsets")]),a._v(" 主题中")]),a._v(" "),s("h3",{attrs:{id:"事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[a._v("#")]),a._v(" 事务")]),a._v(" "),s("h4",{attrs:{id:"消息传输保障"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息传输保障"}},[a._v("#")]),a._v(" 消息传输保障")]),a._v(" "),s("p",[a._v("一般而言, 消息传输保障有三级")]),a._v(" "),s("ol",[s("li",[a._v("at most once: 最多一次, 消息可能会丢失, 但绝不会重复")]),a._v(" "),s("li",[a._v("at least once: 最少一次, 消息不会丢失, 可能重复")]),a._v(" "),s("li",[a._v("exactly once: 恰好一次, 消息不会丢失也不会重复")])]),a._v(" "),s("ul",[s("li",[a._v("kafka生产者发送消息: at least once, 一旦消息提交到日志文件, 这条消息就不会丢失; 如果通信中断, 生产者无法判断是否已经提交, 但是可以进行多次重试;")]),a._v(" "),s("li",[a._v("kafka消费者消费: 根据提交消费位移和消费业务的执行顺序而定\n"),s("ul",[s("li",[a._v("先提交位移: 可能消息丢失")]),a._v(" "),s("li",[a._v("后提交位移: 消息重复")])])])]),a._v(" "),s("h4",{attrs:{id:"幂等"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#幂等"}},[a._v("#")]),a._v(" 幂等")]),a._v(" "),s("p",[a._v("概述: 对接口的多次调用所产生的结果和调用一次等效")]),a._v(" "),s("div",{staticClass:"language-properties line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-properties"}},[s("code",[s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("enable.idempotence")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("设置为true即可开启幂等性功能, 避免重试造成重复写入消息 >> 针对生产者")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("ol",[s("li",[a._v("为每个生产者分配PID, broker端维护PID和分区的序列号, 只有序列递增的消息才会被接收")]),a._v(" "),s("li",[a._v("只能保证单个生产者的单个分区中的幂等性")])]),a._v(" "),s("h4",{attrs:{id:"事务-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务-2"}},[a._v("#")]),a._v(" 事务")]),a._v(" "),s("ul",[s("li",[a._v("事务可以保证对多个分区"),s("strong",[a._v("写入操作的原子性")]),a._v(", 不存在部分成功部分失败;")]),a._v(" "),s("li",[a._v("使用场景: consume-transform-produce模式下, 应用先消费某个主题的消息, 处理后生成消息写入另一个主题\n"),s("ul",[s("li",[a._v("kafka可以保证这些操作全部成功或全部失败")])])]),a._v(" "),s("li",[a._v("但是对消费者而言, 事务能够保证的语义相对偏弱")]),a._v(" "),s("li",[s("code",[a._v("isolation.level")]),a._v(" 消费端应用对未commit消息 的可见性")])]),a._v(" "),s("h2",{attrs:{id:"_08-kafka可靠性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_08-kafka可靠性"}},[a._v("#")]),a._v(" 08.kafka可靠性")]),a._v(" "),s("p",[a._v("如何保证kafka多副本机制之间的一致性, 可靠性")]),a._v(" "),s("h3",{attrs:{id:"副本剖析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#副本剖析"}},[a._v("#")]),a._v(" 副本剖析")]),a._v(" "),s("p",[a._v("副本: 分布式系统对数据和服务提供的一种冗余方式")]),a._v(" "),s("h4",{attrs:{id:"失效副本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#失效副本"}},[a._v("#")]),a._v(" 失效副本")]),a._v(" "),s("p",[a._v("正常情况下, 所有副本都处于ISR集合中, 可能会有异常情况发生导致副本处于失效状态(follower频繁FGC, IO阻塞)")]),a._v(" "),s("h4",{attrs:{id:"isr伸缩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#isr伸缩"}},[a._v("#")]),a._v(" ISR伸缩")]),a._v(" "),s("p",[a._v("定时任务检查ISR副本中是否存在失效副本, 检查follower的LEO是否追上leader的HW")]),a._v(" "),s("h4",{attrs:{id:"通过hw和leo同步副本-leader-epoch保证leader切换时数据一致"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#通过hw和leo同步副本-leader-epoch保证leader切换时数据一致"}},[a._v("#")]),a._v(" 通过HW和LEO同步副本, Leader Epoch保证leader切换时数据一致")]),a._v(" "),s("h4",{attrs:{id:"为什么不支持读写分离"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么不支持读写分离"}},[a._v("#")]),a._v(" 为什么不支持读写分离")]),a._v(" "),s("p",[a._v("主写从读是由于设计上的缺陷而形成的权宜之计 (不如分区)")]),a._v(" "),s("h3",{attrs:{id:"日志同步机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#日志同步机制"}},[a._v("#")]),a._v(" 日志同步机制")]),a._v(" "),s("ul",[s("li",[a._v("少数服从多数(Quorum模型): Raft, Zab\n"),s("ul",[s("li",[a._v("在更新数据时需要多数follower回复同步成功才响应客户端成功, 大量节点会导致性能下降")]),a._v(" "),s("li",[a._v("常用于共享集群配置, 少用于主流数据存储")])])]),a._v(" "),s("li",[a._v("kafka中, 也需要ISR中的副本都确认同步之后才认为提交, 不过选举策略更简单")]),a._v(" "),s("li",[a._v("优势在于少数服从多数需要半数以上节点确认, 在容忍同样节点数量失败的情况下, 使用ISR可以降低需要的总节点数")]),a._v(" "),s("li",[a._v("劣势是ISR无法绕开最慢副本的确认信息")])]),a._v(" "),s("h3",{attrs:{id:"可靠性分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可靠性分析"}},[a._v("#")]),a._v(" 可靠性分析")]),a._v(" "),s("ol",[s("li",[a._v("使用几个9来衡量可靠性")]),a._v(" "),s("li",[a._v("kafka一般配置3副本即可, 银行5副本")]),a._v(" "),s("li",[a._v("如果配置机架信息, 需要考虑机架整体宕机风险")]),a._v(" "),s("li",[a._v("生产者客户端参数 acks = -1(副本同步完成), 可以提高消息可靠性")]),a._v(" "),s("li",[a._v("一般的网络异常可以通过配置生产者客户端 retries 进行重发 ... 以及很多可靠性相关配置参数")])]),a._v(" "),s("h2",{attrs:{id:"_09-kafka应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_09-kafka应用"}},[a._v("#")]),a._v(" 09.kafka应用")]),a._v(" "),s("h3",{attrs:{id:"命令行工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命令行工具"}},[a._v("#")]),a._v(" 命令行工具")]),a._v(" "),s("h3",{attrs:{id:"kafka-connect"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kafka-connect"}},[a._v("#")]),a._v(" kafka connect")]),a._v(" "),s("h3",{attrs:{id:"kafka-mirror-maker"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kafka-mirror-maker"}},[a._v("#")]),a._v(" kafka mirror maker")]),a._v(" "),s("h3",{attrs:{id:"kafka-streams"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kafka-streams"}},[a._v("#")]),a._v(" kafka streams")]),a._v(" "),s("h2",{attrs:{id:"_10-kafka监控"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-kafka监控"}},[a._v("#")]),a._v(" 10.kafka监控")]),a._v(" "),s("p",[a._v("任何软件都需要监控, 增强整体服务的鲁棒性, 及时发现问题, 预防&告警")]),a._v(" "),s("h4",{attrs:{id:"状态指标"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#状态指标"}},[a._v("#")]),a._v(" 状态指标")]),a._v(" "),s("h4",{attrs:{id:"消费滞后"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费滞后"}},[a._v("#")]),a._v(" 消费滞后")]),a._v(" "),s("p",[a._v("消息堆积: 通过监控来避免磁盘爆满, 日志清除")]),a._v(" "),s("p",[a._v("消费滞后量(Lag): 等于高水位减去最近一次的消费位移")]),a._v(" "),s("h4",{attrs:{id:"同步失效分区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同步失效分区"}},[a._v("#")]),a._v(" 同步失效分区")]),a._v(" "),s("h4",{attrs:{id:"监控模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#监控模块"}},[a._v("#")]),a._v(" 监控模块")]),a._v(" "),s("h2",{attrs:{id:"_11-高级应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-高级应用"}},[a._v("#")]),a._v(" 11.高级应用")]),a._v(" "),s("h3",{attrs:{id:"过期时间ttl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#过期时间ttl"}},[a._v("#")]),a._v(" 过期时间TTL")]),a._v(" "),s("p",[a._v("达到一定时间后的消息, 会被丢弃")]),a._v(" "),s("p",[a._v("拦截器(ConsumerInterceptor)实现, 可以配合死信队列")]),a._v(" "),s("h3",{attrs:{id:"延时队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#延时队列"}},[a._v("#")]),a._v(" 延时队列")]),a._v(" "),s("p",[a._v("消息发送后, 需要等待一定时间后消费者才能获取/消费这个消息")]),a._v(" "),s("ol",[s("li",[a._v("通过内部主题实现, 分布创建延迟固定时间的主题, 使用单独服务进行延时的暂存, 然后转发到真实的主题")]),a._v(" "),s("li",[a._v("改造kafka服务端, 自定义延时协议, 基于文件的单层时间轮")])]),a._v(" "),s("h3",{attrs:{id:"死信队列和重试队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#死信队列和重试队列"}},[a._v("#")]),a._v(" 死信队列和重试队列")]),a._v(" "),s("p",[a._v("私信队列: 定义对死信的需求, 哪些消息需要存入死信队列, 存放则只需要一个主题")]),a._v(" "),s("p",[a._v("重试队列: 消息消费失败时重新进入队列并附加延时")]),a._v(" "),s("h3",{attrs:{id:"消息路由"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息路由"}},[a._v("#")]),a._v(" 消息路由")]),a._v(" "),s("p",[a._v("为了兼容RabbitMQ的设计, 可以用拦截器实现, 不推荐使用")]),a._v(" "),s("h3",{attrs:{id:"消息轨迹"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息轨迹"}},[a._v("#")]),a._v(" 消息轨迹")]),a._v(" "),s("p",[a._v("链路跟踪")]),a._v(" "),s("h3",{attrs:{id:"消息审计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息审计"}},[a._v("#")]),a._v(" 消息审计")]),a._v(" "),s("p",[a._v("根据消息过程中")]),a._v(" "),s("h3",{attrs:{id:"消息代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息代理"}},[a._v("#")]),a._v(" 消息代理")]),a._v(" "),s("p",[a._v("kafka REST proxy: 就是一客户端, 提供RESTful接口, 供不同语言的客户端调用")]),a._v(" "),s("h3",{attrs:{id:"消息中间件选型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息中间件选型"}},[a._v("#")]),a._v(" 消息中间件选型")]),a._v(" "),s("ol",[s("li",[a._v("ActiveMQ: Apache出品, Java编写, JMS规范")]),a._v(" "),s("li",[a._v("RabbitMQ: Erlang语言实现")]),a._v(" "),s("li",[a._v("RocketMQ: 阿里开源")])]),a._v(" "),s("h4",{attrs:{id:"选型要点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#选型要点"}},[a._v("#")]),a._v(" 选型要点")]),a._v(" "),s("h4",{attrs:{id:"_1-功能维度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-功能维度"}},[a._v("#")]),a._v(" 1.功能维度")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("功能项")]),a._v(" "),s("th",[a._v("Kafka2.0")]),a._v(" "),s("th",[a._v("RabbitMQ3.6.10")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[a._v("优先级队列")]),a._v(" "),s("td",[a._v("❌ 可以改造支持")]),a._v(" "),s("td",[a._v("✔")])]),a._v(" "),s("tr",[s("td",[a._v("延时队列")]),a._v(" "),s("td",[a._v("❌ 可以改造支持")]),a._v(" "),s("td",[a._v("✔")])]),a._v(" "),s("tr",[s("td",[a._v("死信队列")]),a._v(" "),s("td",[a._v("❌ 可以改造支持")]),a._v(" "),s("td",[a._v("✔")])]),a._v(" "),s("tr",[s("td",[a._v("重试队列")]),a._v(" "),s("td",[a._v("❌ 可以改造支持")]),a._v(" "),s("td",[a._v("❌ 可以封装延时队列实现")])]),a._v(" "),s("tr",[s("td",[a._v("消费模式")]),a._v(" "),s("td",[a._v("拉模式")]),a._v(" "),s("td",[a._v("推+拉模式")])]),a._v(" "),s("tr",[s("td",[a._v("广播消费")]),a._v(" "),s("td",[a._v("✔")]),a._v(" "),s("td",[a._v("✔")])]),a._v(" "),s("tr",[s("td",[a._v("回溯消费")]),a._v(" "),s("td",[a._v("✔")]),a._v(" "),s("td",[a._v("❌")])]),a._v(" "),s("tr",[s("td",[a._v("消息堆积")]),a._v(" "),s("td",[a._v("✔")]),a._v(" "),s("td",[a._v("✔ 堆积效率比kafka低")])]),a._v(" "),s("tr",[s("td",[a._v("持久化")]),a._v(" "),s("td",[a._v("✔")]),a._v(" "),s("td",[a._v("✔")])]),a._v(" "),s("tr",[s("td",[a._v("消息轨迹")]),a._v(" "),s("td",[a._v("❌ 可以改造支持")]),a._v(" "),s("td",[a._v("✔")])]),a._v(" "),s("tr",[s("td",[a._v("消息审计")]),a._v(" "),s("td",[a._v("❌")]),a._v(" "),s("td",[a._v("❌")])]),a._v(" "),s("tr",[s("td",[a._v("消息过滤")]),a._v(" "),s("td",[a._v("客户端级别支持")]),a._v(" "),s("td",[a._v("❌ 可改造支持")])]),a._v(" "),s("tr",[s("td",[a._v("多租户")]),a._v(" "),s("td",[a._v("✔")]),a._v(" "),s("td",[a._v("✔")])]),a._v(" "),s("tr",[s("td",[a._v("多协议支持")]),a._v(" "),s("td",[a._v("❌只自定义协议")]),a._v(" "),s("td",[a._v("AMQP实现,支持多种协议")])]),a._v(" "),s("tr",[s("td",[a._v("跨语言支持")]),a._v(" "),s("td",[a._v("✔ 多语言客户端")]),a._v(" "),s("td",[a._v("✔ 多语言客户端")])]),a._v(" "),s("tr",[s("td",[a._v("流量控制")]),a._v(" "),s("td",[a._v("✔")]),a._v(" "),s("td",[a._v("✔")])]),a._v(" "),s("tr",[s("td",[a._v("消息顺序性")]),a._v(" "),s("td",[a._v("单分区的顺序性")]),a._v(" "),s("td",[a._v("❌")])]),a._v(" "),s("tr",[s("td",[a._v("安全机制")]),a._v(" "),s("td",[a._v("✔")]),a._v(" "),s("td",[a._v("✔")])]),a._v(" "),s("tr",[s("td",[a._v("幂等性")]),a._v(" "),s("td",[a._v("单个生产者单分区幂等")]),a._v(" "),s("td",[a._v("❌")])]),a._v(" "),s("tr",[s("td",[a._v("事务性消息")]),a._v(" "),s("td",[a._v("✔")]),a._v(" "),s("td",[a._v("✔")])])])]),a._v(" "),s("h4",{attrs:{id:"_2-性能维度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-性能维度"}},[a._v("#")]),a._v(" 2.性能维度")]),a._v(" "),s("p",[a._v("kafka单机QPS十万级~百万级")]),a._v(" "),s("h4",{attrs:{id:"_3-可靠性和可用性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-可靠性和可用性"}},[a._v("#")]),a._v(" 3.可靠性和可用性")]),a._v(" "),s("p",[a._v("通常用几个9衡量; kafka使用类PacificA的一致性协议, RabbitMQ使用全量镜像;")]),a._v(" "),s("h4",{attrs:{id:"_4-运维管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-运维管理"}},[a._v("#")]),a._v(" 4.运维管理")]),a._v(" "),s("p",[a._v("监控管理系统, 都不错")]),a._v(" "),s("h4",{attrs:{id:"_5-社区-生态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-社区-生态"}},[a._v("#")]),a._v(" 5.社区&生态")]),a._v(" "),s("p",[a._v("Java社区更活跃")])])}),[],!1,null,null,null);t.default=e.exports}}]);