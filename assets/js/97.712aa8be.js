(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{452:function(s,e,a){"use strict";a.r(e);var n=a(45),t=Object(n.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"redis问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis问题"}},[s._v("#")]),s._v(" Redis问题")]),s._v(" "),a("h2",{attrs:{id:"说一下redis在项目中的应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一下redis在项目中的应用场景"}},[s._v("#")]),s._v(" 说一下redis在项目中的应用场景？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1，5大value类型：zset, set, list, hash, 根据我的redis课有场景的介绍\n2，基本上就是用作缓存~！\n3，存session, 验证码.. 为的是服务无状态，延申思考，看你的项目有哪些数据结构或对象，在单机里需要单机锁，在多机需要分布式锁，抽出来放入redis中；\n4，对于大企业而言, 更重要的是业务无锁化\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("ol",[a("li",[a("p",[s._v("redis是单线程还是多线程？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1，无论什么版本，工作线程就是一个\n2，6.x高版本出现了IO多线程\n3，使用上来说，没有变化\n------\n3，[去学一下系统IO课]，你要真正的理解面向IO模型编程的时候，有内核的事，从内核把数据搬运到程序里这是第一步，然后，搬运回来的数据做的计算式第二步，netty\n4，单线程，满足redis的串行原子，只不过IO多线程后，把输入/输出放到更多的线程里去并行，好处如下：1，执行时间缩短，更快；2，更好的压榨系统及硬件的资源(网卡能够高效的使用)；\n*，客户端被读取的顺序不能被保障, 在一个连接里的顺序可以保证\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])])]),s._v(" "),a("li",[a("p",[s._v("redis存在线程安全的问题吗？为什么？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("重复2中的单线程串行\nredis可以保障内部串行\n外界使用的时候要保障，业务上要自行保障顺序~！\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])])])]),s._v(" "),a("h2",{attrs:{id:"遇到过缓存穿透吗-详细描述一下。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#遇到过缓存穿透吗-详细描述一下。"}},[s._v("#")]),s._v(" 遇到过缓存穿透吗？详细描述一下。")]),s._v(" "),a("p",[s._v("无值数据频繁访问: 解决: key null; 布隆过滤器; 加分布式锁;")]),s._v(" "),a("h2",{attrs:{id:"缓存击穿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[s._v("#")]),s._v(" 缓存击穿")]),s._v(" "),a("p",[s._v("热点数据打到数据库(可能是过期,可能是初始状态下访问); 加锁;")]),s._v(" "),a("h2",{attrs:{id:"缓存雪崩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[s._v("#")]),s._v(" 缓存雪崩")]),s._v(" "),a("p",[s._v("大量的key失效, 并且高并发访问; 不同的key, 需要用自己的锁, 细化锁粒度;")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("以上问题，核心就是避免DB无效/重复请求，结合图去理解\n涉及一些架构思想上的提升\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h2",{attrs:{id:"redis是怎么删除过期key的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis是怎么删除过期key的"}},[s._v("#")]),s._v(" Redis是怎么删除过期key的？")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("缓存如何回收的？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1，后台在轮询，分段分批的删除哪些过期的key (定期删除)\n2，请求的时候判断时候已经过期了 (惰性删除)\n尽量的把内存无用空间回收回来~！\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])])])]),s._v(" "),a("h2",{attrs:{id:"缓存是如何淘汰的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存是如何淘汰的"}},[s._v("#")]),s._v(" 缓存是如何淘汰的")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("0，内存空间不足的情况下：\n1，淘汰机制里有不允许淘汰\n2，lru/lfu/random/TTL\n3，全空间淘汰\n4，设置过过期的key的集合中淘汰\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h2",{attrs:{id:"如何进行缓存预热"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何进行缓存预热"}},[s._v("#")]),s._v(" 如何进行缓存预热？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1，提前把数据塞入redis，(你知道那些是热数据吗？肯定不知道，会造成上线很多数据没有缓存命中)\n2，开发逻辑上也要规避差集(你没缓存的,没猜到的热点数据)，会造成击穿，穿透，雪崩，实施456中的锁方案\n3，一劳永逸，未来也不怕了\n*，结合4，5，6点去看，看图理解\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("h2",{attrs:{id:"数据库与缓存不一致如何解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库与缓存不一致如何解决"}},[s._v("#")]),s._v(" 数据库与缓存不一致如何解决？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1，恶心点的，我们可以使用分布式事务来解决，（意义不大），顶多读多，写稀有情况下\n结合图去思考\n1，redis是缓存，更倾向于稍微的有时差(先更数据库, 再更缓存/删缓存)\n2，还是减少DB的操作\n3，真的要落地，咱就canal + binlog吧\n背景了解: 缓存中间件本就不是用来处理数据一致性问题的---在单机状况下, 应用缓存持久化都需要经过: 应用 - pagecache - 磁盘; 一般情况下数据先保存在页缓存中, 根据操作系统的设置刷写磁盘, 此时断电仍然会丢失数据; 如果为了保证数据安全, 每次修改都fsync, 则性能会急剧下降;\n*即便单机的情况下都有数据不一致的问题, 就算分布式下保证数据一致又有什么用...\n*扩展: 超大型项目将写操作放入MQ,再由mysql和redis消费,并将架构封装成中台,对开发人员透明\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("h2",{attrs:{id:"简述一下主从不一致的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简述一下主从不一致的问题"}},[s._v("#")]),s._v(" 简述一下主从不一致的问题？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1，redis的确默认是弱一致性，异步的同步\n2，锁不能用主从(单实例/分片集群/redlock)==>redisson\n3，在配置中提供了必须有多少个Client连接能同步，你可以配置同步因子，趋向于强制一性\n4，wait 2 0  小心\n5，34点就有点违背redis的初衷了\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[s._v("描述一下redis持久化原理？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("当前线程阻塞服务 不聊\n异步后台进程完成持久\nfork(进程) + copyonwrite\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])])]),s._v(" "),a("li",[a("p",[s._v("Redis有哪些持久化方式？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1，RDB，AOF；主从同步也算持久化；\n2，高版本：开启AOF，AOF是可以通过执行日志得到全部内存数据的方式，但是追求性能：\n2.1，体积变大，重复无效指令  重写，后台用线程把内存的kv生成指令写个新的aof\n2.2，4.x 新增更有性能模式：把重写方式换成直接RDB放到aof文件的头部，比2.1的方法快了，再追加日志\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])])]),s._v(" "),a("li",[a("p",[s._v("Redis也打不住了，万级流量会打到DB上，该怎么处理？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("见456\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])])]),s._v(" "),a("li",[a("p",[s._v("redis中的事务三条指令是什么，第三条指令到达后执行失败了，怎么处理")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("见图, 失败就算失败, 其他继续执行\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])])]),s._v(" "),a("li",[a("p",[s._v("为什么使用setnx？redis实现分布式锁的指令")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1，好东西，原子（不存在的情况下完成创建）\n2，如果要做分布式锁，就要用set k v nx ex  (不存在，过期时间，避免死锁); 或者lua脚本\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])])]),s._v(" "),a("li",[a("p",[s._v("分布式锁实现，理论：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])])])]),s._v(" "),a("p",[s._v("首先,为什么使用Redis\n硬盘太慢: 数据库数据越来越大,增删改需要维护索引,并发量大的时候带宽不足\nRedis对比memcached : mem的value没有类型概念,一般存json格式的字符串;而redis可以存各种类型,并且每种类型提供了一系列操作api;Redis可以持久化;memcached更加轻量\n这里会引申到redis使用epoll进行IO通信\nRedis的worker是单线程的,免去加锁的过程\nlist: 同向命令-栈; 反向命令-队列; 阻塞队列;\nset: 乱序, 去重的; 集合操作, 随机事件 SRANDMEMBER k1 1 : 随机取数,正数取去重,负数可以重复; 应用场景 抽奖\nzset (sorted set): 按score排序, 去重的; 除了元素本身,还有分值维度\nkey的有效期: set mutex 123 NX PX 30000 (设置过期时间30秒) 过期时间不会随着被访问到而延长, 一旦发生写,剔除过期时间\nredis的过期策略: 定期删除+懒删除: 1.首先遍历每个db进行定期删除,按照比例删除一部分key,保证过程中不占用太多资源 2.访问key时顺便查看过期时间,如果过期直接删除")]),s._v(" "),a("p",[s._v('-- redis管道\n-- 消息订阅: publish channel hello 发布; SUBSCRIBE channel 订阅; "聊天室"架构: 发布订阅处理实时,sorted_set处理热点,数据库存储全量\n-- redis事务: multi开启, exec提交, 先提交的整个事务先生效; WATCH: CAS监控.如果事务中需要操作的对象期间被别的任务所更改,相关事务不会被执行,但不支持回滚\n-- redis不支持回滚: redis事务失败时不回滚,而是执行后续命令; 1.因为redis只会因语法失败 2.保证redis的简单,快速')]),s._v(" "),a("p",[s._v("第一：Redis 核心数据结构都有哪些？String类型都有哪些特点？\nString,bitmap,list,hash,set,zset(sorted set)\nString特点: 二进制安全的字符串, 数值计算incr, 原子操作setnx, 设置ttl存活时间, 截取字符串, 正反向索引\n二进制安全: 通过字节流交互,编码不影响数据存储,底层按字节存储,STRLEN计算字节数量,一个数字1字节,UTF-8中文3字节")]),s._v(" "),a("p",[s._v("第二：Redis值类型中 hash 和 string 有什么区别呢？实际工作中如何选择？\nhash是一个string类型的kv映射表, 更适合存储object, 当需要存储一个对象, 并且该对象有较多属性, 如果属性还有修改的需求, 推荐使用hash存储")]),s._v(" "),a("p",[s._v("第三：Redis 持久化是如何工作的？Redis在持久化过程中和可以对外服务么？如果可以的话，Redis又是如何处理新命令的？\nRDB(redis db快照)和AOF(appendonly file日志)\nRDB: 生成指定时间的整个redis的快照 - 命令save(阻塞,不提供服务)和bgsave(子线程,非阻塞); copyonwrite机制, 配置文件是使用bgsave\nAOF: 将redis的写操作记录到文件中(类似于mysql的binlog) - fsync,由操作系统/每秒/每次 进行持久化\n可以提供对外服务吗 - save不可以, bgsave可以\n在fork子进程的时候,只拷贝指针,如果遇到写操作,将操作数据复制一份给子进程,子进程持久化,父进程提供服务")]),s._v(" "),a("p",[s._v("第四：Redis 持久化方式Rdb和Aof的优缺点\nRDB特点: 1.不支持拉链,只有一个dump.rdb,需要运维拉版本; 2.丢失数据相对AOF多; 3.java序列化,恢复速度较快\nAOF特点: 1.丢失数据相对少 2.AOF较RDB优先恢复 3.日志追加导致日志不断,恢复速度慢 4.redis4.0开始RDB+AOF混合使用\n重写: 为了解决AOF的日志无限增加,合并重复的命令(4.0开始RDB+AOF混合使用)\n重写的两个参数: 1.当AOF文件大小超过了上次重写的文件大小的百分之多少时进行重写 2.文件大小超过多少才允许重写")]),s._v(" "),a("p",[s._v("第五：Redis 内存不够时，如何处理新的请求？\n提供了6种淘汰策略 volatile-lru volatile-ttl volatile-random allkeys-lru allkeys-random noeviction\nvolatile是在过期时间的key中选择 allkeys是全部key中选择 lru移除最久未使用的 random完全随机 ttl选择最先过期的\nnoeviction 不移除任何数据,返回一个写错误,如果其他命令最终没有适合移除的key,同样返回错误")]),s._v(" "),a("p",[s._v("第六：Redis 是如何处理过期数据的？\nredis的过期策略: 定期删除+懒删除: 1.首先遍历每个db进行定期删除,按照策略删除一部分key,保证过程中不占用太多资源 2.访问key时顺便查看过期时间,如果过期直接删除\n--具体流程是,随机抽样(expire字典表中)一些(10还是20)key,过期的key在抽样中如果超过25%,进行下一轮抽样和删除,直到低于25%")]),s._v(" "),a("p",[s._v("第七：Redis 内存淘汰算法 LRU/ LFU 可以讲一下原理么？\nLRU: 最久未使用. 双向链表(根据使用情况排序) + 哈希表(用来存储和查找)\nLFU: 最小访问频率, 小顶堆(按频率排序) + 哈希表(用来存储和查找), LeetCode中使用双hash表实现\n但是redis的LRU实现是在每个key中维护一个时间戳(24位),找到距离当前时间最久的key进行淘汰,即便如此还是在随机取样的N个key中进行淘汰\nredis的LFU把24位记录分成 16(时间戳)+ 8(访问频率), redis会根据最近使用时间和访问频率两个条件进行评估后再进行淘汰")]),s._v(" "),a("p",[s._v("第八：Redis 有序数据结构zset底层原理有了解过么？\n跳跃表/跳表 skip list;\nzset还使用了ziplist(压缩过的链表数组)和dict(map)\n为什么使用跳表而不是树? 跳表速度不慢,相比平衡树范围查询更方便; 平衡树的实现更复杂,尤其是树的结构变化\n作者说, 1.skiplist比btree消耗内存更少 2.范围查询时跳表的性能很好 3.更容易实现")]),s._v(" "),a("p",[s._v("第九：Redis 位图应用场景及实现原理可以讲一下么？\nbitmap数据类型, 操作:setbit getbit bitpos bitcount(二进制统计) bitop(与或操作)\nsetbit k1 1 1 :按字节存储 00000000 -> 01000000 也就是ASCII的@符号\nsetbit k1 7 1 : 01000000 -> 01000001 也就是字符A\nbitcount 0 0 (统计第1个字节bit为1的个数)下标是按字节读取而不是位\n使用场景1: 统计用户登录天数: setbit tom 0 1 ; setbit tom 364 1 : 代表tom这年第一天和第365天登录了, 比如 bitcount -1 -2 : 最后16天的登录情况\n使用场景2: 统计某天/某时间窗口的用户登录数量: setbit 20200909 1 1 : 表示这一天1号用户登录过; bitop or destkey 20200909 20200910 进行或运算取这两天的交集,再通过bitcount 0 -1计算这段时间内登录过的(去重的)用户数量")]),s._v(" "),a("p",[s._v("第十：Redis 的缓存穿透/缓存雪崩/缓存重建/这类问题，可以讲讲么\n缓存穿透: 从前端接受的查询是你系统根本不存在的数据,通过布隆过滤器解决,或者布谷鸟过滤器,空key\n空key: 将不存在的数据缓存空key: 1.占内存 2.如果此时数据库加上了这个key会导致数据不一致\n布隆过滤器: 用小空间解决大量数据匹配的问题\n首先将数据库中所有数据用过算法映射到一张bitmap中, 如果要查询的key经过同样算法映射到bitmap没有数据的位置,说明key不存在\n特点在于: 通过计算和bitmap进行有效过滤,但数据库频繁修改会带来bitmap同步问题")]),s._v(" "),a("p",[s._v("缓存击穿(热点数据集中失效): key不存在(过期或是LRU/LFU清理掉了),大量同key请求访问数据库\n1.对于热点key的大量请求,加锁,只允许一个请求去数据库查询,其他请求进入等待,把结果更新回到redis后,才允许其他请求访问\n这会有很多问题(分布式协调问题),拿到锁的请求挂了导致死锁;访问数据库超时;但是数据一致性可以得到保证;\n2.设置key永不超时(或者说预先更新缓存),启动单独的线程构建缓存.(根本避免危害,但无法保证强一致性,代码复杂度增加)")]),s._v(" "),a("p",[s._v("缓存雪崩: 大量的访问到达数据库.(缓存直接down或大量key同时失效)\n其次对于雪崩: 主要思路 1.防止key的同时大量失效,参考击穿 2.限流\n1.设置随机过期时间防止key同时失效 2.客户端限流,避免大量请求(Hystrix) 3.redis集群保证可用性")]),s._v(" "),a("p",[s._v("缓存重建: 缓存击穿时如何重建缓存, 1.加锁 2.设置key永不超时")]),s._v(" "),a("p",[s._v("第十二：Redis 单线程和Redis6.0 的多线程是如何工作的？\n6.0以后提供了IO thread, 计算worker依旧还单线程, 但是和客户端之间的IO读写是多线程的(每个IO/客户端都可以保证他的指令是有序的)")]),s._v(" "),a("p",[s._v("单点故障,容量有限,压力过大/Redis Cluster/缓存一致性\n集群,主从,选举,哨兵")]),s._v(" "),a("p",[s._v("主从复制: 主机数据更新后,自动同步到从机,master写,slaver读. slaveof [ip] [port]; 增量复制队列大小设置; AKF的x轴\n问题: 1.从机意外关闭,重启后增量添加丢失数据; 2.主机意外关闭,从机还是只读,从机需要slaveof no one; 3.单点故障需要人工维护;\n哨兵: 替代人工维护解决单点故障,实现高可用. --sentinel,所有哨兵在master上发布消息,互相发现;\n主观下线(单机做出的下线判断SDOWN)和客观下线(多个哨兵对同一个服务器判断并经过交流之后SDOWN-> ODOWN)\n定期任务: 1.每秒向所有主服务器/从服务器/哨兵发送PING命令 2.如果指定时间窗口内一直无效返回,被视为SDOWN 3.达到指定数量的哨兵对服务器SDOWN,则标记客观下线\n4.客观下线后对这个客观下线主服务器的从服务器加快INFO的发送频率(10s->1s) 5.没有足够数量的哨兵同意主服务器下线,客观下线状态会被移除\n6.主服务器下线后,哨兵进行投票,完成故障转移后,哨兵自动修改自己的配置文件\n故障转移: 1.主机客观下线 2.对当前纪元(Epoch)自增,尝试在这个纪元中当选 3.重复当选 4.选出一个从机,升级为主机 5.发布配置给其他哨兵,让其他从机SLAVEOF新主机\n哨兵选择主机规则: 从机两轮淘汰->复制偏移量->最小运行ID")]),s._v(" "),a("p",[s._v("第十一：Redis 集群分片原理是怎样的？\n集群分片: 将数据分发到不同的redis, 每个redis存储所有key的一个子集; 缺点: 1.不支持多key操作比如求交集 2.不支持多key的事务 3.备份文件复杂 4.扩容缩容较复杂\n原理:\n分区方法: 范围分区,哈希,一致性哈希,哈希槽\n一致性哈希算法: 哈希环,将节点均摊到环的各处,新加入的元素映射到环的某个位置,经过顺时针寻找到第一个节点位置,进行存储;\n特点: 1.容错性好,一个节点挂了可以由下个节点承担 2.扩展性好,可以随时加节点 3.虽然容错和扩展好,但是需要缓存重建 4.容易出现数据倾斜(优化:虚拟节点细分)\nredis哈希槽: redis包含16384个哈希槽,将这些槽自定义分配到各个主机上;扩展时只要把槽位转移给新主机负责就可以(容错同理)\n分区实现方案: 客户端分区,代理分区,查询路由\n查询路由: 请求由redis转发(重定向)到正确的redis节点\n代理层分片: twemproxy, 代理层实现的分片\nredis预分片: 先搞个几十个redis实例分片,到时候新加服务器只要把其中一部分拿到新的服务器就行了")]),s._v(" "),a("p",[s._v("缓存一致性\nmysql和redis的一致性: 1.更新mysql先删redis,加锁,再更新redis 2.mysql的binlog增量订阅-消息队列-redis消费(最终一致性)\nredis集群的一致性: 1.redis保证最终一致性,保证高吞吐量 2.主机挂了,数据未同步到从机,会出现数据丢失")]),s._v(" "),a("p",[s._v("Redis作为分布式锁: 1.set nx 2.设置过期时间 3.多线程监控,延长过期时间")]),s._v(" "),a("p",[s._v("CAP/Paxos/Raft/AKF\nCAP理论:\nAKF拆分原则: x轴:全量镜像,读写分离; y轴:根据业务/功能拆分,数据分开存储 z轴:基于规则拆分/逻辑拆分\nRaft协议:\nzab协议:\nPaxos算法:")])])}),[],!1,null,null,null);e.default=t.exports}}]);