(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{446:function(n,e,t){"use strict";t.r(e);var a=t(45),i=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("ol",[t("li",[n._v("JMM Java内存区域划分\n程序计数器 JavaVMStack 本地方法栈 Java堆 方法区 其中:")])]),n._v(" "),t("p",[n._v('Java堆和方法区是被所有线程"共享"的, 生命周期跟随JVM\n程序计数器、Java虚拟机栈和本地方法栈是线程"私有"的, 生命周期跟随线程')]),n._v(" "),t("p",[n._v("程序计数器: \t当前线程所执行字节码的行号指示器(记录地址,线程切换时保护现场); 分支、循环、跳转、异常处理、线程恢复等基础功能\nJavaVMStack:\t用于执行Java方法, 每个方法都有栈帧(Stack Frame)(存储局部变量表,操作数栈,动态链接(方法地址),方法出口(返回位置))\nNativeMethodStack:\t\t用于执行Native方法, 同样有StackOverflowError/OutOfMemoryError")]),n._v(" "),t("p",[n._v("JavaHeap:\t\t占用最大,存放大部分对象,GC主要管理区域\nMethodArea:\t\t就是perm Space(1.7)和metadata(1.8)存放class字节码,方法,接口..; 包括了(run-time constant pool运行时常量池)常量, 静态变量\n要注意的是永久代和元数据区(其实都是方法区) 存放class,接口,方法,常量,动态生成的class ; 永久代必须指定大小,元数据区则无上限 ; 字符串常量放在永久代, 1.8开始放在堆")]),n._v(" "),t("p",[n._v("Direct Memorey: \t直接内存,NIO分配的堆外内存")]),n._v(" "),t("p",[n._v("JMM Java内存模型,Java虚拟机规范中的定义,用来屏蔽掉各种硬件和操作系统的内存访问差异,定义程序中各个变量的访问规则\n1. 主内存(main mem)和工作内存(线程的work mem),工作内存不能互相访问,需要通过主内存;所有变量存在主内存;\n2. 内存之间的交互操作,规定8种对内存的原子操作 lock unclock read load use assign store write 以及详细规则\n3. volatile变量的特殊规则, 保证可见和静止指令重排, 对于上8条操作又新增三条规则\n(1.每次使用都从主存重新读 2.每次修改必须同步回主存 3.保证相关联代码的顺序与执行顺序相同)\n4. --对long和double变量的特殊规则 (支持32位非原子性) 没啥用\n5. 原子性, 虽然不能直接使用lock和unlock; 可以用monitorenter和monitorexit(也就是synchronized)\n6. 可见性, volatile,synchronized(释放锁之前必须写回主存),final(初始化就能看见)\n7. 有序性, volatile,synchronized(只有一个线程能进行lock操作)\n8. Happens-before\n1. 线程中的每个操作 hb 线程的后续操作\n2. 解锁 \t\t\thb 下一次同一个锁的加锁\n3. 对volatile变量的写 hb 读\n4. 传递性: 如果 A hb B ; B hb C ;那么 A hb C\n5. Thread.start() \thb 线程中的操作\n6. 线程中的操作 \thb 线程的终止监测(join, isAlive)\n7. interrupt() \t\thb 检测中断事件(interrupted())\n8. 对象的初始化 \thb 对象的finalize()方法")]),n._v(" "),t("p",[n._v("as-if-serial 重排序的结果和顺序执行的一致")]),n._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[n._v("java文件从编码到执行 类加载过程, 类初始化过程 (或者称为生命周期?)\n.java经过javac, 编译出.class文件, 然后被ClassLoader读取到内存中作为class对象, 通过解释器或JIT即时编译器(翻译或编译), 进入执行引擎, 最终调用OS, 硬件")])]),n._v(" "),t("p",[n._v("加载class文件 (class文件的平台无关性)\t获取二进制字节/转化为运行时结构数据/生成class对象作为访问入口\nloading加载(放在方法区(永久代), jdk8开始在元数据区) 一般使用类加载器\nlinking (verification校验 - preparation准备:静态变量赋默认值 - resolution解析:将class中的符号变成真正的引用,包括方法,接口..)\ninitializing开始执行Java代码,执行"),t("clinit",[n._v("(),将静态变量赋值,初始化,在堆中生成类对象\nUsing使用 Unloading卸载")])],1),n._v(" "),t("p",[n._v("类加载器 双亲委派 从下往上检查, 缓存中是否有, 都没有再从上往下查找并加载\n(顺序: Bootstrap(核心类/lib) - Extension(扩展/lib/ext) - App(classpath) - Customer(自定义))\n- 为什么要这样设置?\t安全\n- 如何打破?并举例?\t\n基础ClassLoader,不打破只需要重写findClass,打破双亲委派需要重写整个loadClass方法\n主流web服务器都会自定义类加载器(如tomcat),1.应用程序要和Java类库隔离 2.多个应用程序的Jar包共享 3.支持热替换(jsp)")]),n._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[n._v("对象构成")])]),n._v(" "),t("p",[n._v("new对象过程 也分为 1.申请内存 2.赋予默认值 3.调用初始化代码(成员变量复制>构造方法)\nJVM指令 new dup invokespecial astore_1")]),n._v(" "),t("p",[n._v("对象大小, 普通对象的构成\n1.对象头8字节; 2.ClassPointer指针,指向该对象的Class对象; 3.实例数据,保存的基本类型以及引用类型; 4.Padding对齐,对齐保证块读效率,保证是8字节的倍数\n数组对象的构成\n上面普通对象的第3条换成数组长度+数组数据")]),n._v(" "),t("p",[n._v("可以使用Java Agent可以查看对象大小; 这里的指针有个指针压缩的概念,JVM参数(-XX:+UseCompressedOops);\nObject大小: 对象头8+压缩的4+padding = 16字节\n数组大小 : \t对象头8+压缩ClassPointer 4 + 数组长度4 = 16字节 (不压缩指针的话是24字节)")]),n._v(" "),t("h1",{attrs:{id:"对象头markword-8字节-64位"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象头markword-8字节-64位"}},[n._v("#")]),n._v(" 对象头markword 8字节(64位)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("\t存储内容 共64-2或32-2位\t\t\t\t\t锁状态2位\n")])])]),t("h1",{attrs:{id:"锁状态2位-4位-偏向锁1位-锁标志2位无锁对象的hashcode-分代年龄-0-01偏向锁线程id-epoch分代年龄-101轻量级指向轻量级锁的指针00重量级指向重量级锁的指针10gc标记empty11"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁状态2位-4位-偏向锁1位-锁标志2位无锁对象的hashcode-分代年龄-0-01偏向锁线程id-epoch分代年龄-101轻量级指向轻量级锁的指针00重量级指向重量级锁的指针10gc标记empty11"}},[n._v("#")]),n._v(" 锁状态\t\t\t2位 \t4位 \t\t偏向锁1位 \t锁标志2位\n无锁\t对象的hashcode \t分代年龄 \t0 \t\t\t01\n偏向锁\t线程ID \tEpoch\t分代年龄 \t1\t\t\t01\n轻量级\t\t\t指向轻量级锁的指针\t\t\t\t00\n重量级\t\t\t指向重量级锁的指针\t\t\t\t10\nGC标记\t\t\t\t\tempty\t\t\t\t\t11")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("Epoch: 偏向锁的时间戳\n为什么GC年龄默认为15? -因为分代年龄只有4bit来表示\nhashcode部分: 调用c++的os:hashcode方法, 31位hashcode; 如果你重写了就不会存在对象头里; 对象的IdentityHashCode计算后,无法进入偏向锁状态\n")])])]),t("ol",{attrs:{start:"4"}},[t("li",[n._v("Heap的内存模型 常见GC 以及 GC算法")])]),n._v(" "),t("p",[n._v("如何找到垃圾\nReference Counting 引用计数法 特点: 实现简单效率高,问题是无法解决循环引用\nRoot Tracing 根可达算法 从roots开始找, 如引用不到的视为垃圾; 准确高效,实现较麻烦; GC roots包括:\nJVM stack 虚拟机栈(比如main线程栈帧里面引用的对象)\nnative method stack 调用C, C++本地方法中引用的对象\nrun-time constant pool 常量池, 类对象T.class\nstatic-references in method area 静态变量引用到的对象")]),n._v(" "),t("p",[n._v("GC算法 垃圾回收算法\tMark-Sweep(标记清理) Coping(拷贝) Mark-Compact(标记压缩)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("Mark-Sweep(标记清理): 先标记一遍可回收的对象,第二遍回收;\n特点:算法简单,存活对象多的情况下效率高;但是需要两遍扫描,且容易产生碎片,程序分配较大对象时无法找到足够的连续内存\n\nCoping(拷贝): 将内存一分为二,把存活对象全部copy到一侧,最后清理掉另一侧,一般用于Eden+Survivor回收新生代\n特点: (适用于Eden区)适用于存活对象较少的情况;只需要扫描一次,而且没有碎片;空间浪费,移动对象+调整引用\n\nMark-Compact(标记压缩): 先标记,然后回收+整理; 一般用于回收老年代\n特点: 没有碎片,内存不会减半;但是需要扫描两次,移动对象+调整引用\n")])])]),t("p",[n._v("遍历对象图的标记算法: 三色标记/三色遍历,一种广度优先搜索电线实现: 白色 灰色 黑色;\n黑:已遍历完:已经被标记,且引用关系已经被处理(field)\n灰:已遍历到:已经被标记,field还未标记,引用关系尚未处理\n白:未遍历到:还未被标记的对象\n过程: 1.一开始所有对象是白色 2.把根集合直接碰到的对象标记为灰色 3.逐个扫描灰色对象的出边,这些边直接碰到的对象标记为灰色,当一个对象的所有边都扫描完,把这个对象标记为黑色 4.重复3直到不再有灰色对象")]),n._v(" "),t("p",[n._v("堆内存逻辑分区(仅适用于分代垃圾回收期)\tEpsilon,ZGC,Shenandoah不使用分代模型, G1仅逻辑分代\n逻辑分代模型: new/yound(Eden s1 s2) \told/tenured\t; 根据对象的存活周期的不同将内存划分为几块;")]),n._v(" "),t("p",[n._v("新生代,主要用来存储新创建的对象,内存较小,YGC频繁(采用复制算法);YGC扫描Eden和一个S区,将存活的复制到另一个S区;下次扫描则将两个S区互换;当对象经过老年代标准的扫描后,进入老年代\n老年代,主要用来存储长时间被引用的对象, 因为比较稳定所以FGC较少(采用标记-整理算法)\n永久代,存储类元数据信息,如类定义,字节码和常量,GC不会对永久代进行清理,最终会OOM\n元空间,并不在虚拟机中,而是使用本地内存来存储类元数据信息")]),n._v(" "),t("p",[n._v("一个对象的出生到被回收(内存分配策略):\n对象首先尝试在栈上分配,然后看是否是大对象(老年代),再看是否可以TLAB(线程),再进入Eden区,经过垃圾回收一次之后进入S1/S2(from/to),第二次垃圾回收后将Eden和S1的对象放入S2,经过多次重复流程之后进入Old区(可以是15次,或者s区占用了50%),最终FGC")]),n._v(" "),t("p",[n._v('概念:\nYGC/MinorGC FGC/MajorGC(System.gc())\n栈上分配: 特定的小对象,在某段代码块中,而且是简单对象(可以被普通类型代替)\n线程本地分配TLAB Thread Local Allocation Buffer: 首先堆是共享的,所以申请内存需要加锁;为了提升内存分配的效率,对于创建的线程都会分配一块独立的空间TLAB;在TLAB上分配对象效率很高(不加锁)\n动态年龄: 根据s区所占百分比,达到后把年龄最大对象放入old去\n分配担保: s满了,新来对象直接进入老年代\nsafe point: 线程马上停下可能会有问题,需要找到安全点才能STW\nSTW: stop the world\nRemembered Set: 用于记录从非收集部分指向收集部分的指针的集合的抽象数据结构;是一种抽象概念;分代GC模型下,一般针对YGC来说,此时RSet记录的就是从老年代指向新生代的跨代指针;对于Regional收集器,则是记录跨region的指针(每个Region中都有一个RSet,记录哪些Region指向了自己),其价值在于不需要扫描整个堆就能够找到谁引用了当前Region的对象;\n另: G1的RSet是一个hash表,key是指向本Region的Region,value是CardTable;\nCard Table: CT可以是RSet的一种实现方式, 通过Dirty Table的方式记录哪些Card有跨代指针,需要扫描\nRemembered Set和Card Table:\n一般假设RSet是对象粒度,里面存有老年代对象的指针; CT是card粒度(2的次方的内存区域,如512字节),可能包含多个对象; 但其实你可以对两者的精度任意实现\n一般假设RSet使用指针数组, CT使用字节数组来实现; 实际上CT是RSet的一种特殊实现.\nCollection Set: G1中的概念,是GC需要回收的Region的集合,靠RSet实现,然后用copy算法把集合中的每个region存活对象拷贝到新的region里\nwrite-barrier: 对"对引用类型字段赋值"这个动作的环切,有pre和post\nmutator: 应用程序,STW需要停止的对象\nEvacuation: 将region中存活对象复制到新region,并把旧region清空\nSATB(snapshot at the beginning)(G1): SATB目的是维持在GC开始时存活对象的快照;把引用的改变推送到satb_mark_queue(通过write-barrier实现);用region记录的TAMS指针来记录新分配的对象\nTAMS(top-at-mark-start): 在TAMS以上的对象就是新分配的,所谓的隐式marked')]),n._v(" "),t("p",[n._v("GC 常见的垃圾回收期\t\nSerial\t\t复制算法, 单线程\nSerial Old\t标记整理算法, 单线程\nParNew\t\t复制算法,Serial的多线程版本,只有ParNew和Serial能和CMS配合工作\nCMS\t\t\t标记清理算法,jdk1.5 真正意义上的并发收集器,但无法和PS配合, 基于Mark-Sweep算法\n初始标记, 只标记根对象(STW)\n并发标记, 最浪费时间的, 标记现有能找到的对象(根可达)\n并发预清理(preclean),\n重新标记, 标记上个并发阶段发生改变的对象 (标记新的垃圾;或垃圾被重新引用,取消标记)(STW)\n并发清理(sweep), 如果是并发过程中产生的垃圾(浮动垃圾),需要下次清理\n内存整理/压缩, (STW)针对内存空间碎片,进行压缩/整理\n并发重置状态,等待下次CMS触发\n特点:\n并发->吞吐量降低/无法处理浮动垃圾->Concurrent Mode Failure->临时启用Serial Old -XX:CMSInitiatingOccupancyFraction 启动CMS的阈值,不能设置太高,否则大量出现Concurrent Mode Failure;\n标记清除算法带来的空间碎片,合并整理过程无法并发,STW时间过长: -XX:+UseCMSCompactAtFullCollection 开启内存碎片的合并整理过程; -XX:+CMSFullGCsBeforeCompaction 默认每次执行Full GC都会进行压缩整理\nCMS算法: 并发标记的算法,CMS使用三色标记 + Incremental Update")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("并发标记的漏标问题: 1.标记进行时增加了一个黑到白的引用(黑需要重新扫描); 2.标记时删除了灰到白的引用(白可能遍历不到)\n增量更新解决漏标(Incremental Update)(CMS): 关注引用的增加,把黑重新标记为灰色,需要重新扫描(缺点)\n")])])]),t("p",[n._v("Parallel Scavenge\t复制算法,目标则是达到一个可控制的吞吐量(同时体现在调节策略上), 也是多线程版本的Serial\nParallel Old\t\t标记整理算法,jdk1.6,多线程版的Serial Old\nG1\t\t重点关注响应时间,稍微牺牲吞吐量,算法为两大部分: 并发标记+拷贝存活对象\n分治法,把物理内存分为多个Regions, Regions分为Eden Survivor Old Humongous")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("初始标记,标记所有GC Roots可直接到达的对象,并将它们的字段压入扫描栈.G1使用外部的位图记录mark信息\n并发标记,不断从扫描栈取出引用递归扫描,重复扫描过程直到栈清空,过程中还会扫描SATB所记录的引用\n最终标记,每个Java线程还会有一些剩下的SATB记录,需要处理完;这个暂停只需要扫描SATB buffer(而CMS需要重新扫描dirtycard+根集合)\n清理,(stw)清理并重置标记状态,类似于sweep,区别是G1在marking bitmap里统计每个region被标记为活的对象有多少,对各个Region的回收价值和成本进行排序,然后根据用户期望的GC停顿时间来制定回收计划,按计划回收一些价值高的Region,回收过程是copy到新的Region,并清空原Region(也就是所谓的Evacuation)\n--特点: 并发收集,低停顿,还能建立可预测的停顿时间模型;\n--做到这些的基础: \nwrite barrier: 1.实现SATB buffer的收集 2.实现RSet中跨Region的引用记录\n选择任意数量的region来独立收集,构成收集集合CSet\nG1的YGC: 选定所有年轻代里的region(作为CSet进行回收)\nG1的MixedGC: 选定所有年轻代里的region+老年代排序后的部分region(作为CSet进行回收)\n年轻代region总是在CSet内,所以G1的RSet不维护从年轻代出发的引用\nG1的fullGC也是共用Serial Old的代码, 正常情况不会调用\n")])])]),t("p",[n._v("ZGC\t\t使用颜色指针+(load barrier): GC信息记录在指针上,而不是记录在对象头部,所以无法使用指针压缩(取指针中第19-22共4位作为标记,不同标记可以代表不同空间的虚拟地址)\nShenandoah\t使用颜色指针+(write barrier)\nEpsilon")]),n._v(" "),t("p",[n._v("GC参数\n使用各种GC\n-XX:+UseConcMarkSweepGC -XX:+UseG1GC -XX:+UseSerialGC -XX:+UseParallelOldGC\n禁止调用System.gc()\n-XX:+DisableExplictGC\n-Xmn -Xms -Xmx -Xss 年轻代 最小堆 最大堆 栈空间\n-XX:+UseTLAB 使用TLAB，默认打开\n-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintHeapAtGC 打印GC日志, 打印各种GC信息\n-Xloggc:opt/log/gc.log 生成日志\n-verbose:class 类加载详细过程\n-XX:+PrintVMOptions打印JVM运行参数\n-XX:MaxTenuringThreshold 设置分代年龄\n-XX:PreBlockSpin JVM锁升级优化自旋次数\n-XX:CompileThreshold JVM优化JIT热点代码检测参数\nParallel常用参数\n-XX:SurvivorRatio Eden与S区比例, 默认 8:1:1\n-XX:PreTenureSizeThreshold 直接分配到Old区的大对象到底多大\n-XX:MaxTenuringThreshold 老年代阈值\n-XX:+ParallelGCThreads 并行收集器的线程数\n-XX:+UseAdaptiveSizePolicy 自动选择size/自适应\nCMS常用参数\n-XX:ParallelCMSThreads CMS线程数量\n-XX:CMSInitiatingOccupancyFraction 老年代占用多少开始CMS,默认约68%,如果频繁发生SerialOld,应该调小\n-XX:+UseCMSCompactAtFullCollection 在FGC时进行压缩 (解决碎片化的参数)\n-XX:CMSFullGCsBeforeCompactio 多少次FGC之后进行压缩\n-XX:MaxGCPauseMillis 停顿时间,CMS会建立模型去达到这个建议值\nG1常用参数\n-XX:MaxGCPauseMillis 停顿时间,G1会建立模型去达到这个建议值\n-XX:+G1HeapRegionSize 设置region大小,建议逐渐增大该值,单位m\nG1NewSizePercent G1MaxNewSizePercent 新生代比例 默认5-60% ConcGCThreads 线程数")]),n._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[t("p",[n._v("调优过程\nGC日志查看, 可以看到GC时间/消耗时间,原因,内存\n调优概念: 1.根据需求进行JVM规划(预调优) 2.优化JVM运行/问题(卡顿,OOM) 3.重启\n调优规划: 根据业务场景,选择合适垃圾回收期,计算服务器需求(内存,cpu),设定参数(设定GC日志,通过压力测试调参)\n电商每日百万订单,订单处理系统需要什么配置? 先找到交易高峰,比如每秒1000笔,根据CPU处理时间和每个订单产生对象大小预估内存(避免频繁GC和OOM);最后要对服务器进行压测.\n12306春运抢票支撑(偏架构设计): CDN-LVS-NGINX-业务系统\n文档网站响应慢,原1.5G扩到16G反而变卡: 1.原网站慢是因为内存不足频繁GC, 2.增加内存后FGC时间更长\nsmile jira 提交测试报告系统(响应慢,需要频繁重启保持响应): 查看日志YGC频繁,dump定位原因失败,最终扩内存换G1回收器解决\n其他可能问题: tomcat http-header-size过大;lambda表达式导致方法区溢出;直接内存溢出;重写finalize引发频繁GC;\n3.解决:通过PSPO换CMS或G1\n系统CPU经常100%,如何调优: CPU占用看线程,内存高看堆\n1.首先要找出哪个进程 top -Hp pid命令查看子线程信息,找到哪个线程占用CPU高\n2.导出该线程的堆栈信息 jps和jstack命令定位线程状态,重点关注比如WAITING BLOCKED线程状态(线程命名很重要)\n3.通过这个对象地址,查找jstack dump日志中所有相关线程的信息,找到持有锁的线程\n4.查找哪个方法(栈帧)消耗时间,占用CPU\n5.查看工作线程和垃圾回收线程哪个占用CPU高\n系统内存飙高,如何查找问题: 1.jmap导出堆内存 2.分析dump文件(jhat jvisualvm..)\n如何监控JVM: jstat jvisualvm jprofiler arthas top jmx\n基本命令\njps 只列举Java的进程\njstack 把所有java线程信息列出来,包括线程名,调用代码行,锁对象等\njinfo 把进程的一些详细信息列出来\njstat jstat gc pid 1000 打印各种区的大小, GC时间\njconsole 和 jvisualvm 是远程的可视化的控制台,需要开启JMX, jvisualvm也可以分析jmap出的dump文件\njmap 查看堆占用,导出堆文件,线上jmap执行期间占用资源过多会导致卡顿\n1.设定OOM时候自动生成dump文件 2.多服务器情况下停一台jmap 3.使用在线分析工具Arthas\njhat 堆分析工具,分析dump文件,会开启http服务,对象数量/大小等信息,还可以使用OQL进行查询")])]),n._v(" "),t("li",[t("p",[n._v("Arthas 在线排查工具\n启动,选择线程,然后自动挂到线程上,可以在arthas里输入命令进行操作,查看jvm信息,线程情况,导出堆文件..还有反编译,热替换等功能")])]),n._v(" "),t("li",[t("p",[n._v("class文件结构\n文件头CAFEBABE - 小版本号+大版本号(52.0) - 常量池数量+常量池 - 修饰用关键字 - 本类 - 父类 - 接口/ - 成员变量/ - 方法/... 可以使用javap/插件查看,JVM的汇编指令这种..")])]),n._v(" "),t("li",[t("p",[n._v("L3缓存数据共享问题 cache-line伪共享问题 cpu乱序执行 合并写writeCombineBuffer\n解决L3缓存共享数据问题 \t1.总线锁 2.缓存锁(MESI等缓存一致性协议)\ncache-line伪共享问题\t缓存块一次读64bytes,多线程下缓存锁造成多CPU缓存之间持续同步\ncpu乱序执行\t\t\t\tcpu为了提高效率,打乱没有依赖关系的指令顺序,压榨多线程的性能\n合并写 WriteCombineBuffer\t一般是4个字节大小,由于ALU 速度最快,在写入L1的同时写入一个CombineBuffer,写满后直接给L2\n硬件级别CPU内存屏障\t\tsfence lfence mfence (save load mix)")])]),n._v(" "),t("li",[t("p",[n._v("基本问题\njava是解释还是编译的? (mixed-mod下)解释+编译(JIT) JIT代码热点检测(计数器 -- 方法多次, 循环多次)(热点参数-XX:CompileThreshold=10000)\njavac过程? (解析文件生成抽象语法树再输出为class)\n常见JVM实现: Hotspot,zing,J9,JRocket\nJVM JRE JDK区别\tJVM只是一种标准/规范, 有多种实现, java SE拥有java语言规范和jvm规范\ni=i++;问题: 把局部变量表i的原值压栈,把i的值增加,然后再把栈里的原值弹回来赋值.. 最终i值没变\nDCL问题: new 开辟内存空间(创建默认对象),并把内存地址压栈\tdup double一份压栈\tinvokespecial弹出一个元素,初始化后赋值给它\n一些JVM指令: invokeStatic静态方法, invokeVirtual多态方法, invokeInterface接口, invokeSpecial直接定位的方法, invokeDynamic动态(反射,asm,lambda,动态语言Scala)")])])])])}),[],!1,null,null,null);e.default=i.exports}}]);