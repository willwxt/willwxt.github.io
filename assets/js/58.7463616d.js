(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{412:function(a,t,v){"use strict";v.r(t);var _=v(45),r=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"xiaobai"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#xiaobai"}},[a._v("#")]),a._v(" xiaobai")]),a._v(" "),v("h2",{attrs:{id:"基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[a._v("#")]),a._v(" 基础")]),a._v(" "),v("h3",{attrs:{id:"二进制移位运算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二进制移位运算"}},[a._v("#")]),a._v(" 二进制移位运算")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("具体运算")]),a._v(" "),v("ul",[v("li",[a._v("<< 右移")]),a._v(" "),v("li",[v("blockquote",[v("blockquote",[v("p",[a._v("带符号左移")])])])]),a._v(" "),v("li",[v("blockquote",[v("blockquote",[v("blockquote",[v("p",[a._v("不带符号左移")])])])])]),a._v(" "),v("li",[a._v("~ 取反")]),a._v(" "),v("li",[v("ul",[v("li",[a._v("负数, 一般等于取反加一")])])]),a._v(" "),v("li",[a._v("^ 异或, & 按位与, | 按位或")])])]),a._v(" "),v("li",[v("p",[a._v("不借助二进制工具打印二进制")])])]),a._v(" "),v("h3",{attrs:{id:"三种辣鸡排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三种辣鸡排序"}},[a._v("#")]),a._v(" 三种辣鸡排序")]),a._v(" "),v("ul",[v("li",[a._v("选择排序, 冒泡排序, 插入排序")])]),a._v(" "),v("h3",{attrs:{id:"随机函数计算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#随机函数计算"}},[a._v("#")]),a._v(" 随机函数计算")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("题目: 等概率范围转换, 思路")]),a._v(" "),v("ul",[v("li",[a._v("将概率转换为等概率0,1发生器")]),a._v(" "),v("li",[a._v("通过等概率的不同二进制位进行范围生成")])])]),a._v(" "),v("li",[v("p",[a._v("不等概率返回2个数")]),a._v(" "),v("ul",[v("li",[a._v("分别返回一个, 根据顺序等概率生成0, 1发生器")])])])]),a._v(" "),v("h3",{attrs:{id:"通过随机函数完成对数器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#通过随机函数完成对数器"}},[a._v("#")]),a._v(" 通过随机函数完成对数器")]),a._v(" "),v("h3",{attrs:{id:"时间复杂度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[a._v("#")]),a._v(" 时间复杂度")]),a._v(" "),v("ul",[v("li",[a._v("ArrayList扩容均摊在每次add操作中,\n影响只有常数级")])]),a._v(" "),v("h2",{attrs:{id:"数组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[a._v("#")]),a._v(" 数组")]),a._v(" "),v("h3",{attrs:{id:"前缀和数组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前缀和数组"}},[a._v("#")]),a._v(" 前缀和数组")]),a._v(" "),v("ul",[v("li",[a._v("更快返回数组中的一段数据L-R")])]),a._v(" "),v("h3",{attrs:{id:"二分法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二分法"}},[a._v("#")]),a._v(" 二分法")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("有序数组的找到num并返回")])]),a._v(" "),v("li",[v("p",[a._v("有序数组的找到≥num的最左位置\n(≤num的最右位置)")]),a._v(" "),v("ul",[v("li",[a._v("记录, 直到二分切完再返回")])])]),a._v(" "),v("li",[v("p",[a._v("无序,但相邻不等数组的局部最小值")]),a._v(" "),v("ul",[v("li",[a._v("根据两头的斜率进行二分")]),a._v(" "),v("li",[a._v("边界处理: 限制L..R之间至少3个数, 以这种方式解决边界问题")])])])]),a._v(" "),v("h2",{attrs:{id:"哈希表和有序表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#哈希表和有序表"}},[a._v("#")]),a._v(" 哈希表和有序表")]),a._v(" "),v("h3",{attrs:{id:"hashmap"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" HashMap:")]),a._v(" "),v("p",[a._v("基础类型按值存储, 对象类型按地址存储")]),a._v(" "),v("h3",{attrs:{id:"treemap"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[a._v("#")]),a._v(" TreeMap:")]),a._v(" "),v("p",[a._v("作为key的元素必须能被比较")]),a._v(" "),v("h2",{attrs:{id:"链表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[a._v("#")]),a._v(" 链表")]),a._v(" "),v("h3",{attrs:{id:"首先java方法中的参数若是引用-传递的是引用的拷贝"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#首先java方法中的参数若是引用-传递的是引用的拷贝"}},[a._v("#")]),a._v(" 首先java方法中的参数若是引用, 传递的是引用的拷贝")]),a._v(" "),v("h3",{attrs:{id:"一个链表即可实现栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一个链表即可实现栈"}},[a._v("#")]),a._v(" 一个链表即可实现栈")]),a._v(" "),v("h3",{attrs:{id:"两个链表实现队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两个链表实现队列"}},[a._v("#")]),a._v(" 两个链表实现队列")]),a._v(" "),v("h3",{attrs:{id:"双向链表才能实现双端队列-注意指针-节点释放"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#双向链表才能实现双端队列-注意指针-节点释放"}},[a._v("#")]),a._v(" 双向链表才能实现双端队列, 注意指针/节点释放")]),a._v(" "),v("h3",{attrs:{id:"_25-k-个一组翻转链表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_25-k-个一组翻转链表"}},[a._v("#")]),a._v(" 25. K 个一组翻转链表")]),a._v(" "),v("h3",{attrs:{id:"两个链表相加"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两个链表相加"}},[a._v("#")]),a._v(" 两个链表相加")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("先找到长链表/短链表")]),a._v(" "),v("ul",[v("li",[a._v("分三阶段(有有, 有无, 无无)")])])])]),a._v(" "),v("h3",{attrs:{id:"两个有序链表的合并"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两个有序链表的合并"}},[a._v("#")]),a._v(" 两个有序链表的合并")]),a._v(" "),v("ul",[v("li",[a._v("先决定返回的头部, 依次修改指针")])]),a._v(" "),v("h2",{attrs:{id:"位运算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#位运算"}},[a._v("#")]),a._v(" 位运算")]),a._v(" "),v("h3",{attrs:{id:"位图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#位图"}},[a._v("#")]),a._v(" 位图")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("使用一个有限长度的二进制来存储信息(如int)\n功能是判断数值是否存在, 优势是节省空间")]),a._v(" "),v("ul",[v("li",[a._v("比如int[32] 可以表示1024个数\n一个long可以表示64个数")])])]),a._v(" "),v("li",[v("p",[a._v("实现")]),a._v(" "),v("ul",[v("li",[a._v("创建, long[]长度为 (最大长度 >> 6 然后加1)")]),a._v(" "),v("li",[a._v("加入的数值, 对应下标在 (数值 >> 6)\n位置在 (数值 & 63)\n加入过程是 (对应下标 |= 1L << 位置)")]),a._v(" "),v("li",[a._v("删除过程 (对应下标 &= (~(1L << 位置)))")]),a._v(" "),v("li",[a._v("查询是否存在\n对应下标 & (1L << 位置) 是否等于 0")]),a._v(" "),v("li",[a._v("注意 1L << 42 中, 如果是1会变为0")])])])]),a._v(" "),v("h3",{attrs:{id:"实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[a._v("#")]),a._v(" 实现+-*/")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("加法 a+b")]),a._v(" "),v("ul",[v("li",[a._v("异或运算就是无进位相加")]),a._v(" "),v("li",[a._v("进位信息是 (a & b) << 1")]),a._v(" "),v("li",[a._v("原加法等同于 (无进位相加 + 进位信息)\n并在进位信息不为空的时候不断迭代")])])]),a._v(" "),v("li",[v("p",[a._v("减法 a-b")]),a._v(" "),v("ul",[v("li",[a._v("add(a, add(~b, 1))")])])]),a._v(" "),v("li",[v("p",[a._v("乘法 a*b")]),a._v(" "),v("ul",[v("li",[a._v("根据二进制乘法流程计算")]),a._v(" "),v("li",[a._v("判断(b&1)是否为0来决定是否为结构增加值a\na右移, b左移, 不断循环至b为0")])])]),a._v(" "),v("li",[v("p",[a._v("除法 a/b")]),a._v(" "),v("ul",[v("li",[v("ol",[v("li",[a._v("需要绝对值相除, 最终再加上符号")])])])])])]),a._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[a._v("需要将b左移到离a最近的位置, 这里使用a右移保证不溢出\n"),v("ul",[v("li",[a._v("考虑系统最小的情况, 需要补偿")])])])]),a._v(" "),v("p",[v("em",[a._v("XMind - Trial Version")])])])}),[],!1,null,null,null);t.default=r.exports}}]);