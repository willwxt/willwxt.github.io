(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{373:function(e,n,t){"use strict";t.r(n);var l=t(45),a=Object(l.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("自我介绍 项目架构 最有成长的项目")]),e._v(" "),t("p",[e._v("消息中间件的使用, 重复发送, 幂等性,")]),e._v(" "),t("ul",[t("li",[e._v("幂等(以相同的请求调用这个接口一次和调用这个接口多次，对系统产生的影响是相同的)  主要关注插入和更新操作\n"),t("ul",[t("li",[e._v("CAS乐观锁, 根据版本号进行更新")]),e._v(" "),t("li",[e._v("token, 给生产者带去token, 使用一次就失效,")]),e._v(" "),t("li",[e._v("或者带上序列号, 处理过就加入数据库做唯一索引, 已存在的直接丢弃; 并发处理还能以序列号作为分布式锁;")])])])]),e._v(" "),t("p",[e._v("保证有序性(多个队列) "),t("a",{attrs:{href:"https://segmentfault.com/a/1190000040004347",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考"),t("OutboundLink")],1)]),e._v(" "),t("ol",[t("li",[e._v("首先生产者必须有序, 对于需要有序保证的数据流采取单生产者")]),e._v(" "),t("li",[e._v("对于消息中间件的有序\n"),t("ul",[t("li",[e._v("对于结构简单的(单队列)消息中间件, 必然是有序的(全局有序)")]),e._v(" "),t("li",[e._v("对于kafka多partition; 局部有序: 根据需要有序的业务维度将消息分类(如用户id等); 将一类的消息都放入同一partition(通过设置partition key)")])])]),e._v(" "),t("li",[e._v("对于消费者; 单实例单线程肯定是有序\n"),t("ul",[t("li",[e._v("多线程情况下, 可以继续局部拆分, 将读取的消息按规则存到多个内存队列, 每个队列用单独线程处理;")])])])]),e._v(" "),t("p",[e._v("线程池了解哪些;")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("newFixedThreadPool 固定大小线程池\nnewSingleThreadExecutor\t\t单线程的线程池, 保证任务有序\nnewCachedThreadPool\t0容量的任务队列, 0核心, 超大max; 最终是有多少任务就执行多少线程\nnewScheduledThreadPool 定时任务线程池\n阿里规范中明确不允许使用这些线程; 由于一些属性设置过大(21亿), 可能导致OOM\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br")])]),t("p",[e._v("CPU密集型和IO密集型有什么区别, 该如何设置线程数量")]),e._v(" "),t("ol",[t("li",[e._v("要考虑CPU核数, 过多线程数会导致上下文切换的开销\n"),t("ol",[t("li",[e._v("显然, CPU密集型我们要尽可能减少线程切换的开销, 线程数量尽量不要超过核数")]),e._v(" "),t("li",[e._v("在IO密集型则更多等待, CPU开销很小, 可以多增加线程以压榨CPU性能")])])])]),e._v(" "),t("p",[e._v("hashtable 和 concurrentHashMap的区别")]),e._v(" "),t("p",[e._v("SpringAOP的实现")]),e._v(" "),t("p",[e._v("缓存击穿, 雪崩, 穿透;")]),e._v(" "),t("p",[e._v("redis实现分布式锁;")])])}),[],!1,null,null,null);n.default=a.exports}}]);