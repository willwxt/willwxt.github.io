(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{370:function(i,v,t){"use strict";t.r(v);var l=t(45),_=Object(l.a)({},(function(){var i=this,v=i.$createElement,t=i._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[t("ul",[t("li",[t("p",[i._v("一个列表，找出三个数的和等于19，代码实现")]),i._v(" "),t("ol",[t("li",[i._v("暴力法穷举所有可能, O(n³)复杂度")]),i._v(" "),t("li",[i._v("穷举中会有重复列举对象,\n"),t("ol",[t("li",[i._v("比如 [a,b,c] , [a,c,b] , [b, c, a] ... ; 我们保证取出数值是有序的(排序) a <= b <= c , 从而避免去重")]),i._v(" "),t("li",[i._v("相同循环中不取与上次重复的值, 从而避免重复")])])]),i._v(" "),t("li",[i._v("基于结果 [a, b, c] , 在 a 固定的情况下, b 所在循环递增的话, c 必然是递减才能趋近正确答案, 所以最终结果为在固定 a 为一层循环的情况下,  第二层是以 b 和 c 作为 (a, n) 的头尾双指针遍历")])])]),i._v(" "),t("li",[t("p",[i._v("Python打开一个文件，找出某个字符串最快的方法")]),i._v(" "),t("ul",[t("li")])]),i._v(" "),t("li",[t("p",[i._v("写一个awk 打印出第10行")]),i._v(" "),t("ul",[t("li",[t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[i._v("awk")]),i._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[i._v("'{if(NR == 10){print}}'")]),i._v(" SystemOut.log\n")])]),i._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[i._v("1")]),t("br")])])])])])]),i._v(" "),t("h4",{attrs:{id:"报警收敛怎么做"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#报警收敛怎么做"}},[i._v("#")]),i._v(" 报警收敛怎么做")]),i._v(" "),t("ul",[t("li",[t("strong",[i._v("Prometheus告警收敛")]),i._v(" : 告警面临最大问题，是警报太多，收件人很容易麻木，不再继续理会\n"),t("ol",[t("li",[i._v("分组(Group): 将类似性质的警报分类为单个通知, 信息的整合发送")]),i._v(" "),t("li",[i._v("抑制(Inhibition): 当警报发出后，停止重复发送由此警报引发的其他警报")]),i._v(" "),t("li",[i._v("静默(Silences): 一种简单的特定时间静音提醒的机制")])])])]),i._v(" "),t("p",[i._v("另: "),t("a",{attrs:{href:"https://www.infoq.cn/article/the-alarm-of-operation-and-maintenance",target:"_blank",rel:"noopener noreferrer"}},[i._v("如何将运维的报警做成运营的报警"),t("OutboundLink")],1)]),i._v(" "),t("ol",[t("li",[t("p",[i._v("项目, (先整体, 用户数量, 并发数量(新架构测试环境单机4C8G指令TPS440, 查询加挂账号1700-1900QPS), 架构, 中间件, 主要负责的模块, 部署模式, SIT生产环境怎么隔离(上线编写操作步骤, 指定release版本(最终测试通过版本), 接口授权, Apollo配置, 部署平台操作), 后端开发人数(15人), 系统调用链路)")])]),i._v(" "),t("li",[t("p",[i._v("使用了哪些中间件的哪些特性\t(oracle: 新老项目都是RAC集群(本地高可用), 中心之间DG同步(DATAGUARD, 通过日志进行数据库同步), 物理机2+2, 老项目大量使用存储过程, 新项目则是sql")])]),i._v(" "),t("li",[t("p",[i._v("老项目was, 新项目tomcat")])]),i._v(" "),t("li",[t("p",[i._v("redis, kv存储session")])]),i._v(" "),t("li",[t("p",[i._v("消息中间件rocketmq, 看见项目中新老内管交易暂停有用到")])]),i._v(" "),t("li",[t("p",[i._v("新项目主要使用springboot, restcontroller, valid, swagger, feign, mybatis, mockito单元测试 junit架构守护, 其他项目 schedule, ldap, async")])]),i._v(" "),t("li",[t("p",[i._v("单独负责的项目(注重), 自己有什么设计(责任链), 如何保证幂等性(消息中间件)\n有, (账管中心, 保证金账号, 保证金充值)目前功能较少, 后续需求增加就可能不是一个人负责, 其他项目都是一起完成\n新项目只简单使用MVC分层调用, 老项目则是大量使用责任链模式, 首先是接口控制器的通用责任链: 渠道号, session模式, pre/post, 获取对应action列表, 按order顺序执行action的execute 比如存储动态数据; 这里引出动态数据覆盖问题 1.通过返回页面唯一id;")])])]),i._v(" "),t("p",[i._v("主流程也是责任链, 从开始action循环处理到结束action跳出循环, 循环内依次调用action, transition(过渡), 主要优势是提高action类的复用性, 一般以返回retValue为0成功, 1失败, 抛出异常")]),i._v(" "),t("p",[i._v("幂等性是效果和返回都一致! 判断是否已经新增/消费成功, 已消费直接丢弃, 否则进行新增 (线程安全问题?)\n大部分交易没有更新, 有的话: 每条消息携带全局唯一id, 消费时将id保存至redis, 先查询是否消费")]),i._v(" "),t("h4",{attrs:{id:"如何提高qps-tps-最佳实践-服务器性能怎么优化-cpu-内存-io占用高如何调优-jvm停顿怎么解决"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何提高qps-tps-最佳实践-服务器性能怎么优化-cpu-内存-io占用高如何调优-jvm停顿怎么解决"}},[i._v("#")]),i._v(" 如何提高QPS TPS (最佳实践) 服务器性能怎么优化  CPU/内存/IO占用高如何调优  JVM停顿怎么解决?")]),i._v(" "),t("ul",[t("li",[i._v("查看cpu, 内存, 磁盘io等负载, top, free, df, iostat, vmstat")]),i._v(" "),t("li",[i._v("cpu占用: top查看进程, jstack分析GC日志, 线程\n"),t("ul",[t("li",[i._v("使用jvm工具jmap, jstack等(按最佳实践)分析堆内存快照, GC日志, 查看JVM参数设置(GC及配置, 堆大小), 看是否有调整空间, 调整设置后多台机器进行对比压测, 最好模拟生产环境全链路, 最终做出选择")])])]),i._v(" "),t("li",[i._v("内存占用: jmap, dump日志, 分析jvm内存对象")]),i._v(" "),t("li",[i._v("业务问题: 分析调用日志, 请求量, 耗时, 成功率, 最新上线代码")])]),i._v(" "),t("ol",[t("li",[t("p",[i._v("部署环境升级: 使用云平台快速扩容(数据不敏感);  使用CDN动静分离;")])]),i._v(" "),t("li",[t("p",[i._v("服务器优化: tomcat参数调优最大并发线程数, NIO模式, 服务器扩容;  增加数据库连接数, 缓存, 线程数, 使用SSD;")])]),i._v(" "),t("li",[t("p",[i._v("限流削峰: web数据缓存, 应用数据多级缓存: 应用缓存-redis缓存-数据库;  用户单交易访问限制; 限流降级;")])]),i._v(" "),t("li",[t("p",[i._v("应用逻辑性能优化: 对同一记录的频繁操作在redis中执行避免锁表; 交易记录放到异步队列中; 流水日志化;  SQL性能优化;")])]),i._v(" "),t("li",[t("p",[i._v("集合的数据结构: 数组, 链表, 哈希表, 红黑树")])]),i._v(" "),t("li",[t("p",[i._v("HashMap 1.7 和 1.8 区别, 增加红黑树是为了什么(加快检索速度), 一句话描述红黑树(自平衡二叉查找树)")])]),i._v(" "),t("li",[t("p",[i._v("节点是红色或黑色。")])]),i._v(" "),t("li",[t("p",[i._v("根是黑色。")])]),i._v(" "),t("li",[t("p",[i._v("所有叶子都是黑色（叶子是NIL节点）。")])]),i._v(" "),t("li",[t("p",[i._v("每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）")])]),i._v(" "),t("li",[t("p",[i._v("从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点")])])]),i._v(" "),t("ul",[t("li",[t("p",[i._v("volatile底层原理,  多个线程去操作volatile变量线程安全吗?\nvolatile不能保证非原子操作, 两个线程同时读取i, 增加后同时写入")])]),i._v(" "),t("li",[t("p",[i._v("BIO NIO AIO 区别, BIO存在的价值?\nBIO被阻塞时基本不消耗资源, 而NIO仍然在轮询; BIO处理多个连接时需要开启多线程, 高并发下线程切换消耗巨大")])]),i._v(" "),t("li",[t("p",[i._v("介绍JVM, 类加载过程, 打破双亲委派机制的场景并加载String\n可以通过自定义加载器重写loadClass打破双亲委派, 但是针对java.*开头的类，jvm的实现中已经保证了必须由bootstrap来加载")])]),i._v(" "),t("li",[t("p",[i._v("GC垃圾回收算法, 标记清理和标记整理的区别\n标记清除: 标记和清除, 产生空间碎片\n标记整理: 让所有存活的对象都向一端移动, 清理掉以外的对象 (没有空间碎片, 但是整理会消耗一定时间)\n复制算法: 将内存等分; 将存活对象复制到对面, 然后清理原空间 (s1, s2区)")])]),i._v(" "),t("li",[t("p",[i._v("CMS和G1的区别\nCMS是老年代GC, 标记清除算法, 初始标记-并发标记-重新标记-并发清除, 内存超过百分比会进行整理, 整理的停顿时间较长\nG1重新定义了堆空间, 划分为一个个region, 新生代和老年代是一部分region的集合, 两个region之间使用复制算法, 整体上是标记整理, 优势在于不产生空间碎片, 停顿时间更短\n初始标记-并发标记-最终标记-筛选回收")])]),i._v(" "),t("li",[t("p",[i._v("Spring如何设置初始化方法\n@PostConstruct\n实现InitializingBean接口\nxml中配置 "),t("code",[i._v('<bean init-method="">')]),i._v('\t或者 @Bean(initMethod="init")')])])])])}),[],!1,null,null,null);v.default=_.exports}}]);