(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{461:function(a,v,_){"use strict";_.r(v);var i=_(45),e=Object(i.a)({},(function(){var a=this,v=a.$createElement,_=a._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"mq常见问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mq常见问题"}},[a._v("#")]),a._v(" mq常见问题")]),a._v(" "),_("p",[_("a",{attrs:{href:"https://www.modb.pro/db/70231",target:"_blank",rel:"noopener noreferrer"}},[a._v("常见问题参考博客"),_("OutboundLink")],1)]),a._v(" "),_("h3",{attrs:{id:"为什么使用消息队列-消息队列的优点和缺点-kafka、activemq、rabbitmq、rocketmq都有什么优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用消息队列-消息队列的优点和缺点-kafka、activemq、rabbitmq、rocketmq都有什么优缺点"}},[a._v("#")]),a._v(" 为什么使用消息队列? 消息队列的优点和缺点? kafka、activemq、rabbitmq、rocketmq都有什么优缺点?")]),a._v(" "),_("blockquote",[_("p",[a._v("你们系统里为什么要用消息队列这个东西, 有什么好处; 既然用了, 那当时为什么选用这一款MQ")])]),a._v(" "),_("ol",[_("li",[a._v("为什么使用消息队列(项目中什么业务场景, 使用MQ带来了很多好处):")]),a._v(" "),_("li",[a._v("消息队列主要有三个功能, 解耦 / 异步 / 削峰\n"),_("ol",[_("li",[a._v("解耦: 当我们系统需要调用多个系统, 调用复杂, 此时不需要实时返回的, 可以用MQ异步解耦")]),a._v(" "),_("li",[a._v("异步: 当我们调用比较耗时的模块, 使用消息中间件慢慢消费, 异步返回结果")]),a._v(" "),_("li",[a._v("削峰: 高峰期, 将请求都压入消息中间件(消息堆积), 避免后台数据库压力过大")])])]),a._v(" "),_("li",[a._v("缺点 (优点上面就是了)\n"),_("ol",[_("li",[a._v("系统可用性降低: 引入的依赖越多, 系统可用性越低; 如何保证消息一致性? MQ系统可用性?")]),a._v(" "),_("li",[a._v("系统复杂性提高: 消息丢失? 消息重复消费? 如何保证顺序性?")]),a._v(" "),_("li",[a._v("数据一致性")])])]),a._v(" "),_("li",[a._v("引入确实带来很多优势和麻烦, 但是该用的时候还是得用")])]),a._v(" "),_("h3",{attrs:{id:"kafka、activemq、rabbitmq、rocketmq都有什么优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka、activemq、rabbitmq、rocketmq都有什么优缺点"}},[a._v("#")]),a._v(" kafka、activemq、rabbitmq、rocketmq都有什么优缺点？")]),a._v(" "),_("ol",[_("li",[a._v("吞吐量: kafka > rocketmq > rabbitmq > activemq")]),a._v(" "),_("li",[a._v("时效性: RabbitMQ(微秒级) > 其他(毫秒级)")]),a._v(" "),_("li",[a._v("可用性: 主从镜像(activemq, RabbitMQ) 分布式架构(rocketmq, kafka)")]),a._v(" "),_("li",[a._v("消息丢失: 可以做到不丢失(rocketmq, kafka, RabbitMQ)")]),a._v(" "),_("li",[a._v("协议: 支持多协议(RabbitMQ) , 自定义协议(kafka)")]),a._v(" "),_("li",[a._v("activemq: 功能成熟, 高并发用的少")]),a._v(" "),_("li",[a._v("RabbitMQ: 支持很多协议, 比如物联网, erlang开发较难定制/二次开发/不确定性")]),a._v(" "),_("li",[a._v("rocketmq: 社区阉割版, 有精力二次开发的可以选择")]),a._v(" "),_("li",[a._v("kafka: 仅提供核心功能, 很多功能需要自己实现, 提供超高吞吐量")])]),a._v(" "),_("h3",{attrs:{id:"如何保证消息中间件的高可用性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息中间件的高可用性"}},[a._v("#")]),a._v(" 如何保证消息中间件的高可用性?")]),a._v(" "),_("blockquote",[_("p",[a._v("集群")])]),a._v(" "),_("ol",[_("li",[a._v("RabbitMQ普通集群: 就是启动多个不同的RabbitMQ, 主要提高吞吐量,")]),a._v(" "),_("li",[a._v("RabbitMQ镜像集群: 一主多副本集群, 副本只做镜像复制, 读写都在主机\n"),_("ol",[_("li",[a._v("新增镜像模式策略, 设置数据同步到指定数量的节点, 后续创建queue会自动同步")]),a._v(" "),_("li",[a._v("主机处理消息需要同步所有副本")])])]),a._v(" "),_("li",[a._v("kafka高可用\n"),_("ol",[_("li",[a._v("每个topic可以指定多个partition, 每个partition可以指定多个副本(一般3个足够)")]),a._v(" "),_("li",[a._v("相同partition的副本一般均匀分布在不同broker上, leader同理")]),a._v(" "),_("li",[a._v("生产者推送消息到leader, 根据策略同步到其他副本, 消费者最多消费到HW")])])])]),a._v(" "),_("h3",{attrs:{id:"如何保证消息不被重复消费-幂等性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息不被重复消费-幂等性"}},[a._v("#")]),a._v(" 如何保证消息不被重复消费? (幂等性)")]),a._v(" "),_("blockquote",[_("p",[a._v("本质是业务架构如何保证在使用mq时候的幂等性, 主要由业务保证的")])]),a._v(" "),_("p",[a._v("kafka本身的一个幂等是保证生产者推送消息重试时(单分区中)不会发生消息重复")]),a._v(" "),_("ol",[_("li",[a._v("首先为什么会重复消费: 一般是先处理业务, 然后再向消息中间件 ack / 保存消费位移,  但是反过来则可能消息丢失")]),a._v(" "),_("li",[a._v("主要根据实际业务来定制解决方案: 比如在消息流转中增加全局唯一id, 根据id来判断是否消费过")])]),a._v(" "),_("h3",{attrs:{id:"如何保证消息的可靠传输-消息丢失"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息的可靠传输-消息丢失"}},[a._v("#")]),a._v(" 如何保证消息的可靠传输? (消息丢失)")]),a._v(" "),_("ol",[_("li",[a._v("RabbitMQ:\n"),_("ol",[_("li",[a._v("生产者丢失: 提供事务机制(同步, 开销大), 提供confirm确认机制(根据投递结果返回ack/nack, 允许异步)")]),a._v(" "),_("li",[a._v("RabbitMQ自己弄丢数据(未持久化): 跟前面ack配合, 持久化到磁盘后再回复生产者ack")]),a._v(" "),_("li",[a._v("消费端丢失: 消费端自动ack问题, 可以开启手动ack, 这样就可以先处理业务再ack回复")])])]),a._v(" "),_("li",[a._v("kafka:\n"),_("ol",[_("li",[a._v("生产者: 设置参数 acks = -1, 那么收到消息的leader必须同步副本, 可以保证不丢失")]),a._v(" "),_("li",[a._v("kafka丢失数据: 先保证kafka集群副本足够可靠好吧, 足够ISR作为可用副本")]),a._v(" "),_("li",[a._v("消费端: 同样, 关闭自动提交消费位移; 先消费, 再提交消费位移")])])])]),a._v(" "),_("h3",{attrs:{id:"如何保证消息顺序性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息顺序性"}},[a._v("#")]),a._v(" 如何保证消息顺序性?")]),a._v(" "),_("ol",[_("li",[a._v("首先, 生产者自己先去保证推送消息是顺序的好吧;")]),a._v(" "),_("li",[a._v("RabbitMQ中, 在单个queue队列中是保证顺序的, 用一个消费者去消费这个queue, 消费者再顺序分发消息到不同的worker进行消费")]),a._v(" "),_("li",[a._v("kafka是保证单个partition中消息的顺序性,")])]),a._v(" "),_("h2",{attrs:{id:"kafka"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kafka"}},[a._v("#")]),a._v(" kafka")]),a._v(" "),_("p",[_("a",{attrs:{href:"https://xie.infoq.cn/article/8b753e8f20eca9404e45c33ad",target:"_blank",rel:"noopener noreferrer"}},[a._v("具体某个消息中间件问题博客"),_("OutboundLink")],1)]),a._v(" "),_("ol",[_("li",[a._v("Kafka 的用途有哪些? 使用场景如何?")]),a._v(" "),_("li",[a._v("Kafka 中的 ISR、AR 又代表什么? ISR 的伸缩又指什么")]),a._v(" "),_("li",[a._v("Kafka 中的 HW、LEO、LSO、LW 等分别代表什么?")]),a._v(" "),_("li",[a._v("Kafka 中是怎么体现消息顺序性的?")]),a._v(" "),_("li",[a._v("Kafka 中的分区器、序列化器、拦截器是否了解? 它们之间的处理顺序是什么?")]),a._v(" "),_("li",[a._v("Kafka 生产者客户端的整体结构是什么样子的?")]),a._v(" "),_("li",[a._v("Kafka 生产者客户端中使用了几个线程来处理? 分别是什么?")]),a._v(" "),_("li",[a._v("Kafka 的旧版 Scala 的消费者客户端的设计有什么缺陷?")]),a._v(" "),_("li",[a._v("“消费组中的消费者个数如果超过 topic 的分区，那么就会有消费者消费不到数据”这句话是否正确? 如果正确，那么有没有什么 hack 的手段?")]),a._v(" "),_("li",[a._v("有哪些情形会造成重复消费?")]),a._v(" "),_("li",[a._v("哪些情景下会造成消息漏消费?")]),a._v(" "),_("li",[a._v("KafkaConsumer 是非线程安全的，那么怎么样实现多线程消费?")]),a._v(" "),_("li",[a._v("简述消费者与消费组之间的关系")]),a._v(" "),_("li",[a._v("当你使用 kafka-topics.sh 创建（删除）了一个 topic 之后，Kafka 背后会执行什么逻辑?")]),a._v(" "),_("li",[a._v("topic 的分区数可不可以增加? 如果可以怎么增加? 如果不可以，那又是为什么?")]),a._v(" "),_("li",[a._v("topic 的分区数可不可以减少? 如果可以怎么减少? 如果不可以，那又是为什么?")]),a._v(" "),_("li",[a._v("创建 topic 时如何选择合适的分区数?")]),a._v(" "),_("li",[a._v("Kafka 目前有哪些内部 topic，它们都有什么特征? 各自的作用又是什么?")]),a._v(" "),_("li",[a._v("优先副本是什么? 它有什么特殊的作用?")]),a._v(" "),_("li",[a._v("Kafka 有哪几处地方有分区分配的概念? 简述大致的过程及原理")]),a._v(" "),_("li",[a._v("简述 Kafka 的日志目录结构")]),a._v(" "),_("li",[a._v("Kafka 中有哪些索引文件?")]),a._v(" "),_("li",[a._v("如果我指定了一个 offset，Kafka 怎么查找到对应的消息?")]),a._v(" "),_("li",[a._v("如果我指定了一个 timestamp，Kafka 怎么查找到对应的消息?")]),a._v(" "),_("li",[a._v("聊一聊你对 Kafka 的 Log Retention 的理解")]),a._v(" "),_("li",[a._v("聊一聊你对 Kafka 的 Log Compaction 的理解")]),a._v(" "),_("li",[a._v("聊一聊你对 Kafka 底层存储的理解")]),a._v(" "),_("li",[a._v("聊一聊 Kafka 的延时操作的原理")]),a._v(" "),_("li",[a._v("聊一聊 Kafka 控制器的作用")]),a._v(" "),_("li",[a._v("Kafka 的旧版 Scala 的消费者客户端的设计有什么缺陷?")]),a._v(" "),_("li",[a._v("消费再均衡的原理是什么? （提示：消费者协调器和消费组协调器）")]),a._v(" "),_("li",[a._v("Kafka 中的幂等是怎么实现的?")]),a._v(" "),_("li",[a._v("Kafka 中的事务是怎么实现的?")]),a._v(" "),_("li",[a._v("失效副本是指什么? 有哪些应对措施?")]),a._v(" "),_("li",[a._v("多副本下，各个副本中的 HW 和 LEO 的演变过程")]),a._v(" "),_("li",[a._v("Kafka 在可靠性方面做了哪些改进? （HW, LeaderEpoch）")]),a._v(" "),_("li",[a._v("为什么 Kafka 不支持读写分离?")]),a._v(" "),_("li",[a._v("Kafka 中的延迟队列怎么实现")]),a._v(" "),_("li",[a._v("Kafka 中怎么实现死信队列和重试队列?")]),a._v(" "),_("li",[a._v("Kafka 中怎么做消息审计?")]),a._v(" "),_("li",[a._v("Kafka 中怎么做消息轨迹?")]),a._v(" "),_("li",[a._v("怎么计算 Lag? (注意 read_uncommitted 和 read_committed 状态下的不同)")]),a._v(" "),_("li",[a._v("Kafka 有哪些指标需要着重关注?")]),a._v(" "),_("li",[a._v("Kafka 的哪些设计让它有如此高的性能?")])]),a._v(" "),_("h2",{attrs:{id:"rabbitmq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq"}},[a._v("#")]),a._v(" RabbitMQ")]),a._v(" "),_("ol",[_("li",[a._v("RabbitMQ 中的 broker 是指什么？cluster 又是指什么？")]),a._v(" "),_("li",[a._v("什么是元数据？元数据分为哪些类型？包括哪些内容？与 cluster 相关的元数据有哪些？元数据是如何保存的？元数据在 cluster 中是如何分布的？")]),a._v(" "),_("li",[a._v("RAM node 和 disk node 的区别？")]),a._v(" "),_("li",[a._v("RabbitMQ 上的一个 queue 中存放的 message 是否有数量限制？")]),a._v(" "),_("li",[a._v("RabbitMQ 概念里的 channel、exchange 和 queue 这些东东是逻辑概念，还是对应着进程实体？这些东东分别起什么作用？")]),a._v(" "),_("li",[a._v("vhost 是什么？起什么作用？")]),a._v(" "),_("li",[a._v("在单 node 系统和多 node 构成的 cluster 系统中声明 queue、exchange ，以及进行 binding 会有什么不同？")]),a._v(" "),_("li",[a._v("客户端连接到 cluster 中的任意 node 上是否都能正常工作？")]),a._v(" "),_("li",[a._v("若 cluster 中拥有某个 queue 的 owner node 失效了，且该 queue 被声明具有 durable 属性，是否能够成功从其他 node 上重新声明该 queue ？")]),a._v(" "),_("li",[a._v("cluster 中 node 的失效会对 consumer 产生什么影响？若是在 cluster 中创建了 mirrored queue ，这时 node 失效会对 consumer 产生什么影响？")]),a._v(" "),_("li",[a._v("能够在地理上分开的不同数据中心使用 RabbitMQ cluster 么？")]),a._v(" "),_("li",[a._v("为什么 heavy RPC 的使用场景下不建议采用 disk node ？")]),a._v(" "),_("li",[a._v("向不存在的 exchange 发 publish 消息会发生什么？向不存在的 queue 执行 consume 动作会发生什么？")]),a._v(" "),_("li",[a._v("routing_key 和 binding_key 的最大长度是多少？")]),a._v(" "),_("li",[a._v("RabbitMQ 允许发送的 message 最大可达多大？")]),a._v(" "),_("li",[a._v("什么情况下 producer 不主动创建 queue 是安全的？")]),a._v(" "),_("li",[a._v("“dead letter”queue 的用途？")]),a._v(" "),_("li",[a._v("为什么说保证 message 被可靠持久化的条件是 queue 和 exchange 具有 durable 属性，同时 message 具有 persistent 属性才行？")]),a._v(" "),_("li",[a._v("什么情况下会出现 blackholed 问题？")]),a._v(" "),_("li",[a._v("如何防止出现 blackholed 问题？")]),a._v(" "),_("li",[a._v("Consumer Cancellation Notification 机制用于什么场景？")]),a._v(" "),_("li",[a._v("Basic.Reject 的用法是什么？")]),a._v(" "),_("li",[a._v("为什么不应该对所有的 message 都使用持久化机制？")]),a._v(" "),_("li",[a._v("RabbitMQ 中的 cluster、mirrored queue，以及 warrens 机制分别用于解决什么问题？存在哪些问题？")])])])}),[],!1,null,null,null);v.default=e.exports}}]);