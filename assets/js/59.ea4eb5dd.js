(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{417:function(t,a,v){"use strict";v.r(a);var e=v(45),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"design-partterns"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#design-partterns"}},[t._v("#")]),t._v(" DESIGN PARTTERNS")]),t._v(" "),v("h2",{attrs:{id:"单例模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[t._v("#")]),t._v(" *单例模式")]),t._v(" "),v("blockquote",[v("p",[t._v("8种方法, 安全的只有两种")]),t._v(" "),v("p",[t._v("把构造方法设置为private")]),t._v(" "),v("p",[t._v("恶汉式 懒汉式 CL DCL")]),t._v(" "),v("p",[t._v("静态内部类在外部类被加载的时候是不会被加载的, JVM保证内部类只加载一次(静态内部类单例写法)")]),t._v(" "),v("p",[t._v("枚举单例, 除了保证线程安全, 还可以防止反序列化")]),t._v(" "),v("p",[t._v("一般交给Spring")])]),t._v(" "),v("h2",{attrs:{id:"策略模式-strategy"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#策略模式-strategy"}},[t._v("#")]),t._v(" 策略模式 Strategy")]),t._v(" "),v("blockquote",[v("p",[t._v("Comparable")]),t._v(" "),v("p",[t._v("要求对象继承该接口, 才能进行比较, 并不是策略模式. 因为如果想要使用不同的比较策略, 必须修改类, 违背了对更改关闭, 对扩展开放原则")]),t._v(" "),v("p",[t._v("Comparator - 策略模式")]),t._v(" "),v("p",[t._v("比较的同时需要实现比较器类, 通过实现不同的比较器, 可以定义需要的比较方式, 易于扩展")]),t._v(" "),v("p",[t._v("简单的来说, 所有的 if判断/switch 的逻辑代码块都可以改为策略模式")])]),t._v(" "),v("h2",{attrs:{id:"工厂系列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工厂系列"}},[t._v("#")]),t._v(" *工厂系列")]),t._v(" "),v("blockquote",[v("p",[t._v("简单工厂")]),t._v(" "),v("p",[t._v("静态工厂")]),t._v(" "),v("p",[t._v("工厂方法")]),t._v(" "),v("p",[t._v("抽象工厂")]),t._v(" "),v("p",[t._v("Spring IOC/DI")])]),t._v(" "),v("h4",{attrs:{id:"任何可以产生对象的方法或类-都可以称为工厂-单例也是一种工厂模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#任何可以产生对象的方法或类-都可以称为工厂-单例也是一种工厂模式"}},[t._v("#")]),t._v(" 任何可以产生对象的方法或类, 都可以称为工厂, 单例也是一种工厂模式")]),t._v(" "),v("h4",{attrs:{id:"已经有new-为什么还要有工厂模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#已经有new-为什么还要有工厂模式"}},[t._v("#")]),t._v(" 已经有new, 为什么还要有工厂模式")]),t._v(" "),v("blockquote",[v("p",[t._v("更灵活地控制生产过程")]),t._v(" "),v("p",[t._v("例如权限控制, 对象修饰, 打印日志")])]),t._v(" "),v("h4",{attrs:{id:"思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#思想"}},[t._v("#")]),t._v(" 思想")]),t._v(" "),v("blockquote",[v("p",[t._v("想要new car , plane , train")]),t._v(" "),v("p",[t._v("抽取父类/或接口 moveable , 使用多态的向上转型, 减少修改代码量 - 任意定制交通工具")]),t._v(" "),v("p",[t._v("想要修改生产过程")])]),t._v(" "),v("h4",{attrs:{id:"简单工厂"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简单工厂"}},[t._v("#")]),t._v(" 简单工厂")]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("任意修改生产过程")])]),t._v(" "),v("p",[t._v("扩展性不好, 需求变更需要修改Factory工厂")])]),t._v(" "),v("h4",{attrs:{id:"抽象工厂"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#抽象工厂"}},[t._v("#")]),t._v(" 抽象工厂")]),t._v(" "),v("blockquote",[v("p",[t._v("要求任意定义产品一族")]),t._v(" "),v("p",[t._v("定义一个抽象工厂, 包含需要生产的产品一族")]),t._v(" "),v("p",[t._v("所以当你需要生产一个系列的产品族, 只要从抽象工厂继承, 实现自己生产这些产品的逻辑即可")]),t._v(" "),v("p",[t._v("最终调用的时候, 通过多种向上转型, 你只需要修改调用的工厂实现, 不需要修改任何代码")])]),t._v(" "),v("h4",{attrs:{id:"工厂方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工厂方法"}},[t._v("#")]),t._v(" 工厂方法")]),t._v(" "),v("blockquote",[v("p",[t._v("拥有对一类产品的抽象(抽象类/接口)的生产方法, 然后通过不同工厂的继承实现来产生不同产品的设计模式")]),t._v(" "),v("p",[t._v("类似于你的产品一族里只有一件产品的抽象工厂模式")])]),t._v(" "),v("h4",{attrs:{id:"思考-抽象工厂-与-工厂方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#思考-抽象工厂-与-工厂方法"}},[t._v("#")]),t._v(" 思考, 抽象工厂 与 工厂方法")]),t._v(" "),v("blockquote",[v("p",[t._v("抽象工厂不擅长对产品一族的新增一类产品, 需要修改抽象工厂以及所有实现类")]),t._v(" "),v("p",[t._v("工厂方法则是无法实现产品族")])]),t._v(" "),v("h4",{attrs:{id:"更好的解决方案-spring-bean-工厂-spring-bean-ioc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#更好的解决方案-spring-bean-工厂-spring-bean-ioc"}},[t._v("#")]),t._v(" 更好的解决方案, spring bean 工厂 Spring Bean IOC")]),t._v(" "),v("blockquote",[v("p",[t._v("坦克一期07节03部分 26:00 开始")]),t._v(" "),v("p",[t._v("创建gradle项目")])]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("dependencies {\n\tcompile group: '', name:'', version:''\n}\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br")])]),v("blockquote",[v("p",[t._v("编辑 Spring 配置文件 , 可以通过[配置文件进行 IOC, 将对象交给Spring管理")])]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[t._v('//ApplicationContext context = new ClassPathXmlApplication("app.xml");')]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v('//Driver d = (Driver) context.getBean("driver");')]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])]),v("h2",{attrs:{id:"mediator-调停者-facade-门面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mediator-调停者-facade-门面"}},[t._v("#")]),t._v(" Mediator 调停者 Facade 门面")]),t._v(" "),v("h4",{attrs:{id:"facade-门面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#facade-门面"}},[t._v("#")]),t._v(" Facade 门面")]),t._v(" "),v("blockquote",[v("p",[t._v("由于项目内部的互相调用逻辑复杂, 使用门面进行交互, 用户只需要和门面打交道而不需要关注内部实现")])]),t._v(" "),v("h4",{attrs:{id:"mediator-调停者"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mediator-调停者"}},[t._v("#")]),t._v(" Mediator 调停者")]),t._v(" "),v("blockquote",[v("p",[t._v("多个模块互相调用会使逻辑关系复杂, 设置调停者, 所有模块都只和他交互 (消息中间件)")])]),t._v(" "),v("h2",{attrs:{id:"decorator-装饰器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#decorator-装饰器"}},[t._v("#")]),t._v(" Decorator 装饰器")]),t._v(" "),v("blockquote",[v("p",[t._v("GOF中以图形界面作为案例")]),t._v(" "),v("p",[t._v("想要给坦克加些装饰, 如果使用继承实现 : 装饰和被装饰者之间耦合度太高")])]),t._v(" "),v("p",[t._v("场景: Collections工具类中的 Collections.sync")]),t._v(" "),v("h2",{attrs:{id:"责任链模式-chain-of-responsibility"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#责任链模式-chain-of-responsibility"}},[t._v("#")]),t._v(" *责任链模式 Chain Of Responsibility")]),t._v(" "),v("h4",{attrs:{id:"场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[t._v("#")]),t._v(" 场景")]),t._v(" "),v("blockquote",[v("p",[t._v("在论坛中发表文章, 后台要经过信息处理才可以发表或进入数据库")])]),t._v(" "),v("h4",{attrs:{id:"思路"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#思路"}},[t._v("#")]),t._v(" 思路")]),t._v(" "),v("blockquote",[v("ol",[v("li",[t._v("定义一堆的Filter, 逐个调用, 抽出Filter接口")]),t._v(" "),v("li",[t._v("逐个调用过于麻烦, 定义 Chain 类, 维护一个Filter 类型的 List")]),t._v(" "),v("li",[t._v("如何让两个 Chain 可以连接? - 让Chain类实现 Filter 接口")]),t._v(" "),v("li",[t._v("如何实现在某一个Filter判断是否向下执行? - 调用方法返回 参数, 通过判断参数是否继续执行 (或者再传入一个参数, 由这个参数控制)")])])]),t._v(" "),v("h4",{attrs:{id:"javax-servlet-filter-javax-servlet-filterchain"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javax-servlet-filter-javax-servlet-filterchain"}},[t._v("#")]),t._v(" Javax.servlet.Filter  Javax.servlet.FilterChain")]),t._v(" "),v("blockquote",[v("p",[t._v("参数有三个 request response chain")]),t._v(" "),v("p",[t._v("在处理完 request 之后, 调用 chain 的 doFilter 开始递归调用下一个 Filter 直到所有request 调用完毕之后, 反向调用处理 response 的函数")]),t._v(" "),v("p",[t._v("JavaEE 中的 FilterChain 是没有继承 Filter 的")])]),t._v(" "),v("h2",{attrs:{id:"观察者-observer"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#观察者-observer"}},[t._v("#")]),t._v(" *观察者 Observer")]),t._v(" "),v("p",[t._v("事件处理模型")]),t._v(" "),v("h4",{attrs:{id:"场景-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#场景-2"}},[t._v("#")]),t._v(" 场景")]),t._v(" "),v("blockquote",[v("p",[t._v("小孩哭")])]),t._v(" "),v("h4",{attrs:{id:"思路-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#思路-2"}},[t._v("#")]),t._v(" 思路")]),t._v(" "),v("blockquote",[v("ol",[v("li",[t._v("首先最普通的写法, 没有观察者")]),t._v(" "),v("li",[t._v("向被观察的对象中加入观察者 , 达成某种条件直接调用观察者的方法 , 可以有多个观察者")]),t._v(" "),v("li",[t._v("抽出 Observer 接口")]),t._v(" "),v("li",[t._v("抽象出 事件")])]),t._v(" "),v("p",[t._v("事件源 - 观察者 - 事件本身")]),t._v(" "),v("p",[t._v("事件源对象拥有 观察者 可以发出 Event")]),t._v(" "),v("p",[t._v("eg: 窗口拥有 keyListener 可以发出按键事件")])]),t._v(" "),v("blockquote",[v("p",[t._v("Event 中往往有 事件源 source , 很多 Observer 会需要事件源的数据")]),t._v(" "),v("p",[t._v("以 Frame 和 Listener 举例, 很多UI组件都是用了 Observer 模式")])]),t._v(" "),v("h4",{attrs:{id:"钩子函数-hook-callback"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#钩子函数-hook-callback"}},[t._v("#")]),t._v(" 钩子函数 Hook Callback")]),t._v(" "),v("blockquote",[v("p",[t._v("本质上就是 Observer , Listener , 回调函数 - 发生事件的时候会调用 , 本质上就是观察者模式")])]),t._v(" "),v("h4",{attrs:{id:"javascript-event-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javascript-event-对象"}},[t._v("#")]),t._v(" JavaScript event 对象")]),t._v(" "),v("blockquote",[v("p",[t._v("event.target.value")])]),t._v(" "),v("blockquote",[v("p",[t._v("很多系统中, Observer 模式和责任链cor 模式共同负责事件的处理")])]),t._v(" "),v("h2",{attrs:{id:"组合-composite"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组合-composite"}},[t._v("#")]),t._v(" 组合 Composite")]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("树状结构专用模式")])]),t._v(" "),v("p",[t._v("Node 节点")]),t._v(" "),v("p",[t._v("LeafNode 叶子节点")]),t._v(" "),v("p",[t._v("BranchNode 父节点 一对多, 拥有 "),v("code",[t._v("List<Node>")])]),t._v(" "),v("p",[t._v("(深度直接在调用的时候+1就可以)")])]),t._v(" "),v("h2",{attrs:{id:"享元模式-flyweight"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#享元模式-flyweight"}},[t._v("#")]),t._v(" 享元模式 Flyweight")]),t._v(" "),v("blockquote",[v("p",[t._v("共享元数据")])]),t._v(" "),v("h4",{attrs:{id:"简单使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简单使用"}},[t._v("#")]),t._v(" 简单使用")]),t._v(" "),v("blockquote",[v("p",[t._v("(字母表字符串的) 常量池 ; 连接池 ; 线程池")]),t._v(" "),v("p",[t._v("Java 中的 String 是享元模式")])]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[t._v('//String s1 = new String("abc");')]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v('//String s2 = new String("abc");//这两个在堆中new了两个String对象并各自指向, 所以不相等')]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//boolean b = s1.intern() == s2.intern();//true *intern()是拿到字符串对象的常亮引用")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br")])]),v("h4",{attrs:{id:"composite-flyweight-使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#composite-flyweight-使用"}},[t._v("#")]),t._v(" Composite + Flyweight 使用")]),t._v(" "),v("blockquote",[v("p",[t._v("元数据 >> 组合的元数据")])]),t._v(" "),v("h2",{attrs:{id:"proxy-代理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#proxy-代理"}},[t._v("#")]),t._v(" Proxy 代理")]),t._v(" "),v("blockquote",[v("p",[t._v("静态代理, 动态代理, SpringAOP")]),t._v(" "),v("p",[t._v("jdk的实现 决定了动态代理的类必须实现接口")])]),t._v(" "),v("h4",{attrs:{id:"场景-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#场景-3"}},[t._v("#")]),t._v(" 场景")]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("问题一: 计算坦克运行时间 (在不能改变源码的情况下)")]),t._v(" "),v("li",[t._v("问题引申: benchmark , 记录调用模块的耗时")])]),t._v(" "),v("ol",[v("li",[t._v("继承 (但是耦合度太高, 每个需求都要继承)")]),t._v(" "),v("li",[t._v("聚合, 代理类(维护一个目标类) , 不需要每次继承, 但是无法实现代理的各种组合")]),t._v(" "),v("li",[t._v("静态代理, 聚合类维护聚合类本身, 与目标共同继承与一个接口, 实现代理之间的组合使用")])]),t._v(" "),v("p",[t._v("很多设计模式只是语义上的区分, 代码非常类似(都是多态等), 比如装饰者可以视为代理")]),t._v(" "),v("ul",[v("li",[t._v("问题二: 分离代理行为与被代理对象 (把打印日志的代理功能修改为可以代理所有类型/Object)")]),t._v(" "),v("li",[t._v("动态代理 - 不是我们手写的代理类, 而是动态生成的代理类")])]),t._v(" "),v("p",[t._v("反射: 通过class字节码分析方法, 属性...")]),t._v(" "),v("p",[v("code",[t._v("Proxy.newProxyInstance(ClassLoader, Interfaces, InvocationHandler)")]),t._v(" 创建动态代理对象, 需要传入类加载器, 这个类实现的接口, 以及实现了代理方法的分装类")]),t._v(" "),v("p",[t._v("可以配置参数, 将动态生成的类保存到磁盘 可以看到自动生成的动态代理类"),v("code",[t._v('System.geProperties().put("jdk.proxy.ProxyGenerator.saveGeneratedFiles","true");')])])]),t._v(" "),v("h4",{attrs:{id:"分析动态代理生成的类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分析动态代理生成的类"}},[t._v("#")]),t._v(" 分析动态代理生成的类")]),t._v(" "),v("blockquote",[v("p",[t._v("首先该类继承自 Proxy , 构造方会法传入并维护 InvocationHandler (代理方法封装类), 当调用方法时会直接调用 invoke 方法 (你实现的代理方法)")]),t._v(" "),v("p",[v("code",[t._v("invoke(Proxy, Method, Object[])")]),t._v(" 代理对象 调用的方法 方法参数")]),t._v(" "),v("p",[t._v("调用生成的代理类的方法 - 代理类会调用实现的 InvocationHandler 中实现的 invoke 方法, 并把方法参数传入; 在invoke中, 会调用代理的逻辑, 以及原方法")])]),t._v(" "),v("h4",{attrs:{id:"如何生成动态代理类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何生成动态代理类"}},[t._v("#")]),t._v(" 如何生成动态代理类")]),t._v(" "),v("blockquote",[v("p",[t._v("各种找.. method.add 调用了 "),v("code",[t._v("jdk.internal.org.objectweb.asm")]),t._v(" ASM包下的方法")]),t._v(" "),v("p",[t._v("ASM是可以直接操作二进制码的类库")])]),t._v(" "),v("h4",{attrs:{id:"除了使用jdk的动态代理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#除了使用jdk的动态代理"}},[t._v("#")]),t._v(" 除了使用JDK的动态代理")]),t._v(" "),v("blockquote",[v("p",[t._v("Instrument 使用这种方式必须通二进制码格式")]),t._v(" "),v("p",[t._v("CGLib")])]),t._v(" "),v("h4",{attrs:{id:"cglib-实现动态代理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cglib-实现动态代理"}},[t._v("#")]),t._v(" CGLIB 实现动态代理")]),t._v(" "),v("blockquote",[v("p",[t._v("首先需要cglib的jar包依赖")]),t._v(" "),v("p",[t._v("Enhance(); 增强器")]),t._v(" "),v("ol",[v("li",[t._v("创建一个增强器, 设置想要代理(增强)的类作为父类")]),t._v(" "),v("li",[t._v("设置回调函数 (也就是代理的逻辑)")]),t._v(" "),v("li",[t._v("使用增强器 create 创建对象")])]),t._v(" "),v("p",[t._v("缺陷: 无法代理 final 类 (因为无法被继承)")]),t._v(" "),v("p",[t._v("cglib spring 的底层依然是 asm")])]),t._v(" "),v("h4",{attrs:{id:"spring-aop"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop"}},[t._v("#")]),t._v(" Spring AOP")]),t._v(" "),v("blockquote",[v("p",[t._v("通过框架读取配置文件, 可以自定义生成不同的代理类 (方法, 位置, 代理 .. )")])]),t._v(" "),v("h4",{attrs:{id:"aop-配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aop-配置"}},[t._v("#")]),t._v(" aop 配置")]),t._v(" "),v("blockquote",[v("p",[t._v("指定方法作为切点. 当发生切点(指定方法的调用)的时候, 可以在切点前后调用配置的 before , after 方法")]),t._v(" "),v("p",[t._v("..还有各种切的方法")])]),t._v(" "),v("h4",{attrs:{id:"aop-注解-autoproxy"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aop-注解-autoproxy"}},[t._v("#")]),t._v(" aop 注解 autoproxy")]),t._v(" "),v("blockquote",[v("p",[t._v("需要 aspectjweaver 依赖jar包")]),t._v(" "),v("p",[t._v("@Aspect @Before @After 并制定想要切的方法(切点)")])]),t._v(" "),v("h2",{attrs:{id:"iterator-迭代器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#iterator-迭代器"}},[t._v("#")]),t._v(" Iterator 迭代器")]),t._v(" "),v("h4",{attrs:{id:"实现可动态扩展的容器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现可动态扩展的容器"}},[t._v("#")]),t._v(" 实现可动态扩展的容器")]),t._v(" "),v("blockquote",[v("p",[t._v("很多数据结构都是逻辑结构, 比如说二叉树, 栈, 队列, 其实他们都可以用数组或链表结构")]),t._v(" "),v("p",[t._v("物理结构只有数组和链表两种")]),t._v(" "),v("p",[t._v("数组实现 链表实现, 抽象出公共方法至 Collection 接口")])]),t._v(" "),v("h4",{attrs:{id:"如何遍历容器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何遍历容器"}},[t._v("#")]),t._v(" 如何遍历容器")]),t._v(" "),v("blockquote",[v("p",[t._v("for 循环, 只能遍历 数组实现 , 无法遍历 链表 或者 hashset")]),t._v(" "),v("p",[t._v("所以遍历方法需要交给每个不同实现的容器类自己实现")]),t._v(" "),v("p",[t._v("通过迭代器, 只要我们拿到他的迭代器, 就可以对容器进行遍历 (而不需要知道这个容器的具体实现)")]),t._v(" "),v("p",[t._v("把迭代器抽取出接口")])]),t._v(" "),v("h4",{attrs:{id:"iterator-接口实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#iterator-接口实现"}},[t._v("#")]),t._v(" Iterator 接口实现")]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("hasNext()")]),t._v(" "),v("li",[t._v("next()")])]),t._v(" "),v("p",[t._v("维护一个实现了 Iterator 接口的内部类")])]),t._v(" "),v("h4",{attrs:{id:"作业-自己实现arraylist和linkedlist"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作业-自己实现arraylist和linkedlist"}},[t._v("#")]),t._v(" 作业 自己实现ArrayList和LinkedList")]),t._v(" "),v("h2",{attrs:{id:"visitor-访问者"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#visitor-访问者"}},[t._v("#")]),t._v(" Visitor 访问者")]),t._v(" "),v("h4",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("在结构不变的情况下动态改变对于内部元素的动作")]),t._v(" "),v("li",[t._v("GOF典型案例: 编译器")])])]),t._v(" "),v("h4",{attrs:{id:"思路-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#思路-3"}},[t._v("#")]),t._v(" 思路")]),t._v(" "),v("blockquote",[v("p",[t._v("电脑由三个部件组成, 不同visitor访问需要执行不同的代码, 然后分别调用电脑的 accept() 接待方法")]),t._v(" "),v("p",[t._v("电脑则是直接调用组件的 accept() 方法")]),t._v(" "),v("p",[t._v("如果把判断逻辑写入到 各个组件的 accept() 方法中, 每当加入新的visitor类, 需要修改所有的accept方法")]),t._v(" "),v("p",[t._v("所以我们把 accept 的逻辑全部放在 visitor 中实现, 所以所有组件的 accept 代码都是调用 visitor 的 visit 方法 (并把自身传入), 而 visit 方法由 visitor 本身来实现, 这样每有新的 visitor, 我们不需要修改任何组件的代码")]),t._v(" "),v("p",[t._v("抽象出 visitor 接口, 接口中拥有 visitorCPU visitorMemory... 用来访问不同组件的方法")])]),t._v(" "),v("h4",{attrs:{id:"问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),v("blockquote",[v("p",[t._v("以上描述的问题在于, 受访问对象的结构一般是固定的, 如果新增组件, 需要修改所有的 visitor")])]),t._v(" "),v("h4",{attrs:{id:"编译器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编译器"}},[t._v("#")]),t._v(" 编译器")]),t._v(" "),v("blockquote",[v("p",[t._v("编译器构建出抽象语法数AST,")]),t._v(" "),v("ul",[v("li",[t._v("按照传统模式, 对每个节点调用方法需要判断每个节点类型, 调用对应的方法做处理")]),t._v(" "),v("li",[t._v("使用visitor模式, 树上所有节点只调用 accept 方法(接受一个visitor), 调用每个不同的visitor本身就具有的方法实现")])])]),t._v(" "),v("h4",{attrs:{id:"asm"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#asm"}},[t._v("#")]),t._v(" ASM")]),t._v(" "),v("blockquote",[v("p",[t._v("ASM - 直接操作java字节码文件的框架 - AsSeMbly")]),t._v(" "),v("p",[t._v("学习一个新东西, 首先去看官网")])]),t._v(" "),v("h4",{attrs:{id:"_2-2-2-节-parsing-classes"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-节-parsing-classes"}},[t._v("#")]),t._v(" 2.2.2 节 Parsing classes")]),t._v(" "),v("blockquote",[v("p",[t._v("解析这个类 ClassPrinter extends ClassVistor")]),t._v(" "),v("p",[t._v("实现class字节码中各种 node 的 visit 方法, 方法中获得了很多class各个node的具体的属性, 你可以进行定制化操作")]),t._v(" "),v("p",[t._v("最后让一个 ClassReader 接待你所定制的 visitor")])]),t._v(" "),v("h4",{attrs:{id:"_2-2-3-节-generating-classes"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-节-generating-classes"}},[t._v("#")]),t._v(" 2.2.3 节 Generating classes")]),t._v(" "),v("blockquote",[v("p",[t._v("使用 ClassWriter (也是一个visiter) 可以通过各种visit方法生成class")])]),t._v(" "),v("h4",{attrs:{id:"_2-2-4-节-transforming-classes"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-4-节-transforming-classes"}},[t._v("#")]),t._v(" 2.2.4 节 Transforming classes")]),t._v(" "),v("blockquote",[v("p",[t._v("改变class")]),t._v(" "),v("p",[t._v("很显然是 ClassReader 和 ClassWriter 的组合使用 , 中间通过visitor的实现类进行定制")])]),t._v(" "),v("h2",{attrs:{id:"builder-构建器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#builder-构建器"}},[t._v("#")]),t._v(" Builder 构建器")]),t._v(" "),v("h4",{attrs:{id:"概述-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-2"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("blockquote",[v("p",[t._v("分离复杂对象的构建和表示")]),t._v(" "),v("p",[t._v("同样的构建过程(接口中)可以创建不同的表示(简单的,或 复杂的接口实现)")])]),t._v(" "),v("h4",{attrs:{id:"思路-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#思路-4"}},[t._v("#")]),t._v(" 思路")]),t._v(" "),v("blockquote",[v("p",[t._v("当一个对象非常复杂, (比如需要传入50个参数... ), 拆分内部的构建过程, 依次调用构建方法, 最后返回构建完毕的对象")]),t._v(" "),v("p",[t._v("builder 模式经常使用链式编程的写法")])]),t._v(" "),v("h2",{attrs:{id:"adapter-适配器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#adapter-适配器"}},[t._v("#")]),t._v(" Adapter 适配器")]),t._v(" "),v("h4",{attrs:{id:"概述-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-3"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("blockquote",[v("p",[t._v("Adapter / Wrapper(包装器)")]),t._v(" "),v("p",[t._v("接口转换器")])]),t._v(" "),v("h4",{attrs:{id:"举例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#举例"}},[t._v("#")]),t._v(" 举例")]),t._v(" "),v("blockquote",[v("p",[t._v("国标接口转接头")]),t._v(" "),v("p",[t._v("java.io : Reader/Writer 和 Steam 之间的转换 , 例如 InputStreamReader OutputStreamWriter")]),t._v(" "),v("p",[t._v("jdbc-odbc : Java通过(JDBC-ODBC bridge)访问ODBC访问SQLServer")]),t._v(" "),v("p",[t._v("ASM transformer - ClassReader 和 ClassWriter 之间的")])]),t._v(" "),v("h4",{attrs:{id:"误区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#误区"}},[t._v("#")]),t._v(" 误区")]),t._v(" "),v("blockquote",[v("p",[t._v("常见的Adapter类反而不是Adapter或者说也算转换器..., 如 WindowAdapter KeyAdapter")]),t._v(" "),v("p",[t._v("WindowAdapter 是避免实现所有的接口方法实现的 空方法的实现类")])]),t._v(" "),v("h2",{attrs:{id:"bridge-桥接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#bridge-桥接"}},[t._v("#")]),t._v(" Bridge 桥接")]),t._v(" "),v("ul",[v("li",[t._v("双维度扩展")])]),t._v(" "),v("h4",{attrs:{id:"概述-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-4"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("blockquote",[v("p",[t._v("分离抽象与具体")]),t._v(" "),v("p",[t._v("用聚合的方式 (桥) 连接抽象与具体")])]),t._v(" "),v("h4",{attrs:{id:"思路-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#思路-5"}},[t._v("#")]),t._v(" 思路")]),t._v(" "),v("blockquote",[v("p",[t._v("将礼物类抽取不同的特征, 并不断增加")]),t._v(" "),v("p",[t._v("同时礼物的种类也在不断增加, 造成类的数量过多")]),t._v(" "),v("p",[t._v("解决:")]),t._v(" "),v("p",[t._v("在最初的抽象类中 维护一个具体的实现(当然这个具体的实现也是一个向上转型的接口), 当你想要创建对应类型的具体实现, 只需要将对应的实现传至对应类型的构造器")]),t._v(" "),v("ul",[v("li",[t._v("在抽象和具体两个维度上同时进行多态, 并通过聚合的方式互相联系")])])]),t._v(" "),v("h2",{attrs:{id:"command-命令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#command-命令"}},[t._v("#")]),t._v(" Command 命令")]),t._v(" "),v("p",[t._v("封装命令, 结合cor实现undo")]),t._v(" "),v("h4",{attrs:{id:"概述-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-5"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("blockquote",[v("p",[t._v("别名 : Action / Transaction")]),t._v(" "),v("p",[t._v("do的时候记录必要的事务用于undo的时候回退")]),t._v(" "),v("ul",[v("li",[t._v("宏命令 - command + composite")]),t._v(" "),v("li",[t._v("多次undo - command + cor责任链")]),t._v(" "),v("li",[t._v("transaction回滚  - command + Memento")])])]),t._v(" "),v("h2",{attrs:{id:"prototype-原型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#prototype-原型"}},[t._v("#")]),t._v(" Prototype 原型")]),t._v(" "),v("h4",{attrs:{id:"概述-6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-6"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("blockquote",[v("p",[t._v("java自带原型模式 , 也就是 Object.clone()")]),t._v(" "),v("ul",[v("li",[t._v("实现原型模式要实现标记型接口Cloneable, 一般会重新clone()方法, 但如果没实现接口, 调用时会抛出异常")]),t._v(" "),v("li",[t._v("一般用于一个对象的属性已经确定, 需要产生很多相同对象的时候")]),t._v(" "),v("li",[t._v("需要区分深/浅")])]),t._v(" "),v("p",[t._v("极少用到, 极少问到")])]),t._v(" "),v("h4",{attrs:{id:"原clone方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原clone方法"}},[t._v("#")]),t._v(" 原clone方法")]),t._v(" "),v("blockquote",[v("p",[t._v("将对象的内存直接拷贝一份")]),t._v(" "),v("p",[t._v("是浅拷贝(浅克隆), 两份对象中的引用指向同一个对象")])]),t._v(" "),v("h4",{attrs:{id:"深拷贝"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝"}},[t._v("#")]),t._v(" 深拷贝")]),t._v(" "),v("blockquote",[v("p",[t._v("浅克隆的同时, 将内部存在的引用对象也调用克隆")])]),t._v(" "),v("h4",{attrs:{id:"string-需要克隆吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#string-需要克隆吗"}},[t._v("#")]),t._v(" String 需要克隆吗")]),t._v(" "),v("blockquote",[v("p",[t._v("String类型不需要进行深克隆, 因为String在常量池, 本来就是共用的")]),t._v(" "),v("ul",[v("li",[t._v("对克隆(不论深浅)前后的两个对象的String属性进行修改, 并不会相互影响")]),t._v(" "),v("li",[t._v("但是使用 new String() , 在堆里面创建了指向String常量的对象, 则会被改变")])])]),t._v(" "),v("h2",{attrs:{id:"memento-备忘录"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#memento-备忘录"}},[t._v("#")]),t._v(" Memento 备忘录")]),t._v(" "),v("ul",[v("li",[t._v("记录状态状态, 便于回滚")])]),t._v(" "),v("h4",{attrs:{id:"概述-7"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-7"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("blockquote",[v("p",[t._v("记录快照 (瞬时状态)")]),t._v(" "),v("p",[t._v("存盘功能")]),t._v(" "),v("p",[t._v("比起 command , 直接恢复数据 (某次快照的数据)")]),t._v(" "),v("p",[t._v("可以使用Memento对象存储其他对象的状态, 或者直接序列化")])]),t._v(" "),v("h4",{attrs:{id:"java-序列化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java-序列化"}},[t._v("#")]),t._v(" Java 序列化")]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("使用 ObjectOutputStream , 输出到磁盘文件 , 被序列化的对象, 以及对象属性中引用的所有对象, 都需要实现 Serializable")])])]),t._v(" "),v("h2",{attrs:{id:"templatemethod-模板方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#templatemethod-模板方法"}},[t._v("#")]),t._v(" TemplateMethod 模板方法")]),t._v(" "),v("ul",[v("li",[t._v("钩子函数, 回调函数")])]),t._v(" "),v("h4",{attrs:{id:"概述-8"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-8"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("blockquote",[v("p",[t._v("重写方法, 系统帮你自动调用的方法, 都可以称为模板方法")]),t._v(" "),v("p",[t._v("在父类中有个方法A调用了很多其他的方法, 子类在继承的过程中不需要重写A或是所有的方法, 只需要按需重写自己需要的方法, 调用A时就会生效")]),t._v(" "),v("p",[t._v("相当于定义了一个方法模板 A () , 其中调用了 op1 op2 ... , 只要继承并重写这些 op1 op2 .. 然后调用 A() 就可以")])]),t._v(" "),v("h2",{attrs:{id:"state-状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#state-状态"}},[t._v("#")]),t._v(" State 状态")]),t._v(" "),v("ul",[v("li",[t._v("根据状态决定行为")])]),t._v(" "),v("h4",{attrs:{id:"概述-9"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述-9"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("blockquote",[v("p",[t._v("如果当一个类中的方法大都要通过判断一个状态来决定执行的代码逻辑, 我们把State状态抽取出来, 进行不同状态的State的方法实现, 而原来的类中只需要调用 State 的handler()方法即可")]),t._v(" "),v("p",[t._v("GOF中案例 : TCP 连接的 State")]),t._v(" "),v("p",[t._v("根据TCP连接的状态, 拥有不同的 Open Close 等方法的实现")])]),t._v(" "),v("h4",{attrs:{id:"特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),v("blockquote",[v("p",[t._v("当Client中方法数量比较固定, 状态容易增加的时候使用")]),t._v(" "),v("p",[t._v("如果需要增加方法, 那么每个State中都需要实现一遍, 而增加一种State则相当方便")]),t._v(" "),v("p",[t._v("如果没有那么多状态, 或者状态固定, 也没有必要使用这种设计模式")])]),t._v(" "),v("h4",{attrs:{id:"有限状态机-fsm"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#有限状态机-fsm"}},[t._v("#")]),t._v(" 有限状态机 FSM")]),t._v(" "),v("blockquote",[v("p",[t._v("状态是有限的, 状态与状态之间是可以实现变换的(通过某个操作实现状态迁移)")]),t._v(" "),v("p",[t._v("举例 : 线程的状态图 就是有限状态机")])]),t._v(" "),v("h4",{attrs:{id:"作业-car的state和action"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作业-car的state和action"}},[t._v("#")]),t._v(" 作业: Car的State和Action")]),t._v(" "),v("h2",{attrs:{id:"intepreter-解释器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#intepreter-解释器"}},[t._v("#")]),t._v(" Intepreter 解释器")]),t._v(" "),v("ul",[v("li",[t._v("动态脚本解析")])]),t._v(" "),v("blockquote",[v("p",[t._v("SQL, JS, Python, 脚本... 的解释器")])]),t._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("h4",{attrs:{id:"设计模式列表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#设计模式列表"}},[t._v("#")]),t._v(" 设计模式列表")]),t._v(" "),v("blockquote",[v("ol",[v("li",[t._v("首先分类列出所有设计模式\n"),v("ol",[v("li",[t._v("这种设计模式的典型用法是什么? 典型案例")]),t._v(" "),v("li",[t._v("把类图想起来")])])]),t._v(" "),v("li",[t._v("如果想不起来就回去看, 直到能够想起来为止")])])]),t._v(" "),v("h4",{attrs:{id:"创建型模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#创建型模式"}},[t._v("#")]),t._v(" 创建型模式")]),t._v(" "),v("blockquote",[v("p",[t._v("Abstract Factory")]),t._v(" "),v("p",[t._v("Builder")]),t._v(" "),v("p",[t._v("Factory Method")]),t._v(" "),v("p",[t._v("ProtoType")]),t._v(" "),v("p",[t._v("Singleton")])]),t._v(" "),v("h4",{attrs:{id:"结构型模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#结构型模式"}},[t._v("#")]),t._v(" 结构型模式")]),t._v(" "),v("blockquote",[v("p",[t._v("Adapter")]),t._v(" "),v("p",[t._v("Bridge")]),t._v(" "),v("p",[t._v("Composite")]),t._v(" "),v("p",[t._v("Decorator")]),t._v(" "),v("p",[t._v("Facade")]),t._v(" "),v("p",[t._v("Flyweight")]),t._v(" "),v("p",[t._v("Proxy")])]),t._v(" "),v("h4",{attrs:{id:"行为型模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#行为型模式"}},[t._v("#")]),t._v(" 行为型模式")]),t._v(" "),v("blockquote",[v("p",[t._v("Chain Of Resposibility")]),t._v(" "),v("p",[t._v("Command")]),t._v(" "),v("p",[t._v("Intepreter")]),t._v(" "),v("p",[t._v("Iterator")]),t._v(" "),v("p",[t._v("Mediator")]),t._v(" "),v("p",[t._v("Memento")]),t._v(" "),v("p",[t._v("Observer")]),t._v(" "),v("p",[t._v("State")]),t._v(" "),v("p",[t._v("Strategy")]),t._v(" "),v("p",[t._v("Template Method")]),t._v(" "),v("p",[t._v("Visitor")])]),t._v(" "),v("h4",{attrs:{id:"指导思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#指导思想"}},[t._v("#")]),t._v(" 指导思想")]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("可维护性 Maintainability\n"),v("ul",[v("li",[t._v("修改功能时, 需要改动的地方越少, 维护性越好")])])]),t._v(" "),v("li",[t._v("可复用性 Reusability\n"),v("ul",[v("li",[t._v("可以被重复使用")]),t._v(" "),v("li",[t._v("提取自己的类库")])])]),t._v(" "),v("li",[t._v("可扩展性 Extensibility / Scalability\n"),v("ul",[v("li",[t._v("添加功能无需修改原来的代码")])])]),t._v(" "),v("li",[t._v("灵活性 flexibility / mobility / adaptability\n"),v("ul",[v("li",[t._v("代码接口可以灵活调用")])])])])]),t._v(" "),v("h4",{attrs:{id:"单一职责-srp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单一职责-srp"}},[t._v("#")]),t._v(" 单一职责 SRP")]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("Single Responsibility Principle")]),t._v(" "),v("li",[t._v("一个类别太大, 负责单一的职责, 别太累\n"),v("ul",[v("li",[t._v("Person")]),t._v(" "),v("li",[t._v("PersonManager")])])]),t._v(" "),v("li",[t._v("高内聚, 低耦合")])])]),t._v(" "),v("h4",{attrs:{id:"开闭原则-ocp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则-ocp"}},[t._v("#")]),t._v(" 开闭原则 OCP")]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("Open-Closed Principle")]),t._v(" "),v("li",[t._v("对扩展开放, 对修改关闭\n"),v("ul",[v("li",[t._v("尽量不修改原来代码的情况下, 进行扩展")])])]),t._v(" "),v("li",[t._v("抽象化, 多态是开闭原则的关键")])])]),t._v(" "),v("h4",{attrs:{id:"里式替换原则-lsp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#里式替换原则-lsp"}},[t._v("#")]),t._v(" 里式替换原则 LSP")]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("Liscov Substitution Principle")]),t._v(" "),v("li",[t._v("所有使用父类的地方, 必须能够透明的使用子类对象")])])]),t._v(" "),v("h4",{attrs:{id:"依赖倒置原则-dip"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则-dip"}},[t._v("#")]),t._v(" 依赖倒置原则 DIP")]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("Dependency Inversion Principle")]),t._v(" "),v("li",[t._v("依赖抽象, 而不是依赖具体")]),t._v(" "),v("li",[t._v("面向抽象编程 / 面向接口编程 (里面的实现可以随便换)")])])]),t._v(" "),v("h4",{attrs:{id:"接口隔离原则-isp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则-isp"}},[t._v("#")]),t._v(" 接口隔离原则 ISP")]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("Interface Segregation Principle")]),t._v(" "),v("li",[t._v("每一个接口应该承担独立的角色, 不干不该自己干的事\n"),v("ul",[v("li",[t._v("Flyable Runnable 不该合二为一")]),t._v(" "),v("li",[t._v("避免子类实现不需要实现的方法")]),t._v(" "),v("li",[t._v("需要对客户提供接口的时候, 只需要暴露最小的接口")])])])])]),t._v(" "),v("h4",{attrs:{id:"迪米特法则-lod"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则-lod"}},[t._v("#")]),t._v(" 迪米特法则 LoD")]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("Low of Demeter")]),t._v(" "),v("li",[t._v("尽量不要和陌生人说话")]),t._v(" "),v("li",[t._v("在迪米特法则中, 对于一个对象, 非陌生人包括以下积累\n"),v("ul",[v("li",[t._v("当前对象本身 this")]),t._v(" "),v("li",[t._v("以参数形式传入到当前对象方法中的对象")]),t._v(" "),v("li",[t._v("当前对象的成员对象")]),t._v(" "),v("li",[t._v("如果当前对象的成员对象是一个集合, 集合中的也是")]),t._v(" "),v("li",[t._v("当前对象所创建的对象")])])]),t._v(" "),v("li",[t._v("和其他类的耦合度变低")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);