(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{445:function(e,n,a){"use strict";a.r(n);var t=a(45),s=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("HashMap\nHashMap构造器: 初始化成员变量,校验参数是否合法,参数赋值\nHashMap的put: 流程是计算hash值-判断原来hash表是否初始化-计算下标(如果下标新增则resize)-下标有node,看下是新增还是更新,新增则可能树化")]),e._v(" "),a("p",[e._v("LinkedHashMap: 它维护一个遍历其所有条目的双向链接列表。\nTreeMap: 基于红黑树的导航map(可以查最近floor,ceiling的有序map)")]),e._v(" "),a("p",[e._v("HashTable: 很老的哈希表, put方法加了sync, 且控制了key和value不能为null\nSynchronizedMap: Collections工具类提供的线程安全哈希表, 可以自行传入mutex, 不传自己就是mutex; 注释中标注, 在迭代器遍历的时候注意要加锁sync(mutex)\nConcurrentHashMap: 检索的完全并发,更新的高期望并发; 检索操作不需加锁, 但不支持锁表; 不允许keyvalue有null; 中间的一些赋值使用CAS实现;\nConcurrentHashMap 的 put: 基本和HashMap一样, 如果为空直接CAS赋值, 有链表或树直接加锁处理(锁首个节点), 如果是REMOVE状态则帮助rehash;\n如果新增sizeCtl<0, 则transfer(), transfer移动赋值到新表,和其他操作是并行的;")]),e._v(" "),a("p",[e._v("AQS")])])}),[],!1,null,null,null);n.default=s.exports}}]);