(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{451:function(a,t,r){"use strict";r.r(t);var s=r(45),h=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"常用数据类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常用数据类型"}},[a._v("#")]),a._v(" 常用数据类型")]),a._v(" "),r("h2",{attrs:{id:"基本数据类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本数据类型"}},[a._v("#")]),a._v(" 基本数据类型")]),a._v(" "),r("h2",{attrs:{id:"string"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[a._v("#")]),a._v(" String")]),a._v(" "),r("h3",{attrs:{id:"string-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#string-2"}},[a._v("#")]),a._v(" String")]),a._v(" "),r("ul",[r("li",[a._v("1.6及以下时,字符串常量池存储在永久代(堆外)\n1.7字符串常量存储在堆中,intern方法修改")]),a._v(" "),r("li",[a._v("请区分字符串常量和字符串对象, 字符串对象和普通对象一样存储在堆中")]),a._v(" "),r("li",[a._v('new String("...")的流程:')])]),a._v(" "),r("ol",[r("li",[a._v('若出现"..."(或者"..." + "..."), 查询是否常量池中存在常量池String对象, 是则返回引用, 否则创建常量池String对象, 再返回引用')]),a._v(" "),r("li",[a._v("若出现动态对象(new String, 变量的相加等等), 在堆中new String对象, 它可以不唯一")])]),a._v(" "),r("ul",[r("li",[a._v("str.intern() 查询(创建)并返回常量池对象\n1.6 若无会创建常量池String对象\n1.7 若无只会记录堆中(首次创建的)String对象的引用")])]),a._v(" "),r("h2",{attrs:{id:"普通集合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#普通集合"}},[a._v("#")]),a._v(" 普通集合")]),a._v(" "),r("h3",{attrs:{id:"list"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[a._v("#")]),a._v(" List")]),a._v(" "),r("ul",[r("li",[a._v("ArrayList")]),a._v(" "),r("li",[a._v("LinkedList")]),a._v(" "),r("li",[a._v("List接口")])]),a._v(" "),r("h3",{attrs:{id:"map"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[a._v("#")]),a._v(" Map")]),a._v(" "),r("ul",[r("li",[a._v("HashMap")]),a._v(" "),r("li",[a._v("LinkedHashMap")]),a._v(" "),r("li",[a._v("TreeMap")])]),a._v(" "),r("h3",{attrs:{id:"set"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[a._v("#")]),a._v(" Set")]),a._v(" "),r("ul",[r("li",[a._v("实现基本同Map")])]),a._v(" "),r("h2",{attrs:{id:"juc线程安全集合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#juc线程安全集合"}},[a._v("#")]),a._v(" JUC线程安全集合")]),a._v(" "),r("h3",{attrs:{id:"collections-synchronized"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#collections-synchronized"}},[a._v("#")]),a._v(" Collections.synchronized")]),a._v(" "),r("h3",{attrs:{id:"copyonwritearraylist"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#copyonwritearraylist"}},[a._v("#")]),a._v(" CopyOnWriteArrayList")]),a._v(" "),r("h3",{attrs:{id:"concurrenthashmap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[a._v("#")]),a._v(" ConcurrentHashMap")]),a._v(" "),r("h3",{attrs:{id:"blockingqueue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#blockingqueue"}},[a._v("#")]),a._v(" BlockingQueue")]),a._v(" "),r("ul",[r("li",[a._v("LinkedBlockingQueue")]),a._v(" "),r("li",[a._v("ArrayBlockingQueue")]),a._v(" "),r("li",[a._v("DelayQueue")]),a._v(" "),r("li",[a._v("SynchronousQueue")])]),a._v(" "),r("h2",{attrs:{id:"常见问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[a._v("#")]),a._v(" 常见问题")]),a._v(" "),r("h3",{attrs:{id:"hashmap如何解决hash冲突-为什么hashmap中的链表需要转成红黑树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hashmap如何解决hash冲突-为什么hashmap中的链表需要转成红黑树"}},[a._v("#")]),a._v(" hashmap如何解决hash冲突，为什么hashmap中的链表需要转成红黑树？")]),a._v(" "),r("h3",{attrs:{id:"hashmap什么时候会触发扩容"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hashmap什么时候会触发扩容"}},[a._v("#")]),a._v(" hashmap什么时候会触发扩容？")]),a._v(" "),r("h3",{attrs:{id:"jdk1-8之前并发操作hashmap时为什么会有死循环的问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-8之前并发操作hashmap时为什么会有死循环的问题"}},[a._v("#")]),a._v(" jdk1.8之前并发操作hashmap时为什么会有死循环的问题？")]),a._v(" "),r("h3",{attrs:{id:"hashmap扩容时每个entry需要再计算一次hash吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hashmap扩容时每个entry需要再计算一次hash吗"}},[a._v("#")]),a._v(" hashmap扩容时每个entry需要再计算一次hash吗？")]),a._v(" "),r("h3",{attrs:{id:"hashmap的数组长度为什么要保证是2的幂"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的数组长度为什么要保证是2的幂"}},[a._v("#")]),a._v(" hashmap的数组长度为什么要保证是2的幂？")]),a._v(" "),r("h3",{attrs:{id:"linkedhashmap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashmap"}},[a._v("#")]),a._v(" LinkedHashMap")]),a._v(" "),r("ul",[r("li",[a._v("如何用LinkedHashMap实现LRU？")])]),a._v(" "),r("h3",{attrs:{id:"treemap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[a._v("#")]),a._v(" TreeMap")]),a._v(" "),r("ul",[r("li",[a._v("如何用TreeMap实现一致性hash？")])]),a._v(" "),r("h3",{attrs:{id:"concurrenthashmap是如何在保证并发安全的同时提高性能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap是如何在保证并发安全的同时提高性能"}},[a._v("#")]),a._v(" ConcurrentHashMap是如何在保证并发安全的同时提高性能？")]),a._v(" "),r("h3",{attrs:{id:"concurrenthashmap是如何让多线程同时参与扩容"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap是如何让多线程同时参与扩容"}},[a._v("#")]),a._v(" ConcurrentHashMap是如何让多线程同时参与扩容？")]),a._v(" "),r("h3",{attrs:{id:"linkedblockingqueue、delayqueue是如何实现的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#linkedblockingqueue、delayqueue是如何实现的"}},[a._v("#")]),a._v(" LinkedBlockingQueue、DelayQueue是如何实现的？")]),a._v(" "),r("h3",{attrs:{id:"copyonwritearraylist是如何保证线程安全的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#copyonwritearraylist是如何保证线程安全的"}},[a._v("#")]),a._v(" CopyOnWriteArrayList是如何保证线程安全的？")]),a._v(" "),r("p",[r("em",[a._v("XMind - Trial Version")])])])}),[],!1,null,null,null);t.default=h.exports}}]);