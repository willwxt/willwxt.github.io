(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{398:function(i,_,t){"use strict";t.r(_);var s=t(45),v=Object(s.a)({},(function(){var i=this,_=i.$createElement,t=i._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[t("h1",{attrs:{id:"redis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[i._v("#")]),i._v(" redis")]),i._v(" "),t("h2",{attrs:{id:"redis数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis数据结构"}},[i._v("#")]),i._v(" redis数据结构")]),i._v(" "),t("p",[i._v("使用者角度/Redis暴露的接口")]),i._v(" "),t("h3",{attrs:{id:"string"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[i._v("#")]),i._v(" string")]),i._v(" "),t("ul",[t("li",[i._v("string底层实现-动态字符串SDS")]),i._v(" "),t("li",[i._v("子主题 2")]),i._v(" "),t("li",[i._v("子主题 3")])]),i._v(" "),t("h3",{attrs:{id:"bitmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bitmap"}},[i._v("#")]),i._v(" bitmap")]),i._v(" "),t("h3",{attrs:{id:"hash"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[i._v("#")]),i._v(" hash")]),i._v(" "),t("h3",{attrs:{id:"list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[i._v("#")]),i._v(" list")]),i._v(" "),t("h3",{attrs:{id:"set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[i._v("#")]),i._v(" set")]),i._v(" "),t("h3",{attrs:{id:"zset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zset"}},[i._v("#")]),i._v(" zset")]),i._v(" "),t("h2",{attrs:{id:"redis内部数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis内部数据结构"}},[i._v("#")]),i._v(" redis内部数据结构")]),i._v(" "),t("h3",{attrs:{id:"研究目标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#研究目标"}},[i._v("#")]),i._v(" 研究目标")]),i._v(" "),t("p",[i._v("存储效率（memory efficiency）\n快速响应时间（fast response time）\n单线程（single-threaded）")]),i._v(" "),t("ul",[t("li",[i._v("节省内存, 压缩数据、减少内存碎片")]),i._v(" "),t("li",[i._v("单个请求的响应时间要求很高, 有时可能与高吞吐量矛盾")]),i._v(" "),t("li",[i._v("瓶颈在于内存访问和网络IO")])]),i._v(" "),t("h3",{attrs:{id:"dict"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dict"}},[i._v("#")]),i._v(" dict")]),i._v(" "),t("p",[i._v("所谓的hashtable")]),i._v(" "),t("p",[i._v("https://mp.weixin.qq.com/s/qFDOFr4HYpgUg-J_VCNvQw")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("dict概述")]),i._v(" "),t("ul",[t("li",[i._v("用于维护key-value映射关系, Redis中的一个db就用一个dict来维护;")]),i._v(" "),t("li",[i._v("当hash结构的field较多, 就会采用dict存储;")]),i._v(" "),t("li",[i._v("dict和skiplist配合使用来维护sorted set;")]),i._v(" "),t("li",[i._v("基于哈希表的算法, 与传统哈希算法类似, 拥有loadfactor, rehash\n特点是采用了增量式哈希incremental rehash:\n避免一次性将所有key rehash, 而是将rehash操作分散到对dict各个增删改查操作中\n避免rehash期间请求响应时间的剧烈增加")])])]),i._v(" "),t("li",[t("p",[i._v("dict结构")]),i._v(" "),t("p",[i._v("每个dict包含\n两个dictht, dictht是一个存储dictEntry的数组, 平时只有ht[0]有效\ndictType结构的指针type, 类似java的"),t("T",[i._v("\n私有数据指针privdata\n当前rehash索引 long rehashidx\n遍历的个数int iterators")])],1),i._v(" "),t("ul",[t("li",[t("p",[i._v("dictht ht[2]")]),i._v(" "),t("p",[i._v("平时只有ht[0]有效, 只有在重哈希的过程中，ht[0]和ht[1]才都有效")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("dictEntry **table\ndictEntry指针数组")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("dictEntry")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("void *key (可以指向任何类型)")])]),i._v(" "),t("li",[t("p",[i._v("union v")]),i._v(" "),t("p",[i._v("union {\nvoid *val;\nuint64_t;\nint64_t;\ndouble d;\n} v;\n当v是uint64_t、int64_t或double类型, 不再需要额外的存储, 这有利于减少内存碎片;\nv也可以是void指针")])]),i._v(" "),t("li",[t("p",[i._v("next")])])])])])]),i._v(" "),t("li",[t("p",[i._v("unsigned long size\ntable的长度, 总为2的指数")])]),i._v(" "),t("li",[t("p",[i._v("unsigned long sizemask\n(size-1, 各位全1的数组, 用于取余)")])]),i._v(" "),t("li",[t("p",[i._v("unsigned long used\n记录dict中现有的数据个数")])]),i._v(" "),t("li",[t("p",[i._v("(used/size的比值就是装载因子load factor)")])])])]),i._v(" "),t("li",[t("p",[i._v("dataType *type\n有一堆函数指针")]),i._v(" "),t("ul",[t("li",[i._v("hashFunction, 计算hash值的")]),i._v(" "),t("li",[i._v("keyDup和valDup, 拷贝函数(深拷贝)")]),i._v(" "),t("li",[i._v("keyCompare, 比较函数, 查找key使用")]),i._v(" "),t("li",[i._v("keyDestructor和valDestructor析构函数")])])]),i._v(" "),t("li",[t("p",[i._v("void *privdata\n私有数据指针")]),i._v(" "),t("ul",[t("li",[i._v("dictType的某些操作被调用时会传回给调用者")])])]),i._v(" "),t("li",[t("p",[i._v("long rehashidx\n当前rehash索引")])]),i._v(" "),t("li",[t("p",[i._v("int iterators")])])])]),i._v(" "),t("li",[t("p",[i._v("dict方法")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("dict的创建(dictCreate)")]),i._v(" "),t("ul",[t("li",[t("ol",[t("li",[i._v("zmalloc(sizeof(*d)); 给dict分配空间")])])])])])])])]),i._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("p",[i._v("dictht中的table=NULL, 数组还未分配空间")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("dict的查找(dictFind)")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("如果正在进行rehash,\n调用_dictRehashStep")])]),i._v(" "),t("li",[t("p",[i._v("调用dictHashKey, 计算key的hash值")]),i._v(" "),t("ul",[t("li",[i._v("调用了dictType的hashFunction")])])]),i._v(" "),t("li",[t("p",[i._v("在ht[0]查找,\n找到直返回")]),i._v(" "),t("ul",[t("li",[i._v("根据hash值与sizemask按位与, 找到指定下标的dictEntry(链表),\n调用dictCompareKeys在链表中逐个比较, (用到keyCompare)")])])]),i._v(" "),t("li",[t("p",[i._v("如果ht[0]中未找到")]),i._v(" "),t("ul",[t("li",[i._v("判断是否rehash\n是-在ht[1]中查找\n否-返回null")])])])])]),i._v(" "),t("li",[t("p",[i._v("_dictRehashStep调用\ndictRehash(*d, 1)\n(将rehash向前推进1步)")]),i._v(" "),t("ul",[t("li",[i._v("每一步将ht[0]上一个dictEntry链表(bucket\n移动到ht[1]上(rehashidx记录尚未迁移的ht[0]位置), 新位置根据ht[1]的sizemask重新计算")]),i._v(" "),t("li",[i._v("rehashidx: 如果指向的bucket没有数据, 会向后遍历n*10步查找")]),i._v(" "),t("li",[i._v("如果ht[0]上的数据都迁移到ht[1]上, 整个重哈希结束, ht[0]变成ht[1]的内容, 而ht[1]重置为空")])])]),i._v(" "),t("li",[t("p",[i._v("dict的插入")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("dictAdd\nval已存在会失败")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("dictAddRaw")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("_dictRehashStep 推进rehash")])]),i._v(" "),t("li",[t("p",[i._v("_dictKeyIndex")]),i._v(" "),t("ul",[t("li",[i._v("寻找插入位置, 如果rehash, 查找ht[0]和ht[1]")]),i._v(" "),t("li",[i._v("可能触发_dictExpandIfNeeded")])])]),i._v(" "),t("li",[t("p",[i._v("如果正在rehash. 会把数据插入到ht[1]")])]),i._v(" "),t("li",[t("p",[i._v("总是插入到bucket的dictEntry头部:\n因为新数据被访问概率比较高")])])])])])]),i._v(" "),t("li",[t("p",[i._v("dictReplace\n会更新已存在的val")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("在dictAdd基础上实现")]),i._v(" "),t("ul",[t("li",[i._v("先调用dictAdd, 如果失败再find再setvalue")])])])])])])]),i._v(" "),t("li",[t("p",[i._v("dict的删除dictDelete")]),i._v(" "),t("ul",[t("li",[i._v("_dictRehashStep 推进rehash")]),i._v(" "),t("li",[i._v("ht[0]或两个数组中查找并删除并调用析构函数")])])])])])]),i._v(" "),t("h3",{attrs:{id:"sds"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sds"}},[i._v("#")]),i._v(" sds")]),i._v(" "),t("p",[i._v("字符串")]),i._v(" "),t("p",[i._v("Simple Dynamic String")]),i._v(" "),t("p",[i._v("https://mp.weixin.qq.com/s/_uqWOC1Gau-yCja1fmTdqA")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("特点")]),i._v(" "),t("ul",[t("li",[i._v("可动态扩展内存, mutable")]),i._v(" "),t("li",[i._v("二进制安全, 存储二进制数据")]),i._v(" "),t("li",[i._v("与传统C语言字符串类型兼容")])])]),i._v(" "),t("li",[t("p",[i._v("结构")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("5种类型header结构")]),i._v(" "),t("p",[i._v("能让不同长度的字符串可以使用不同大小的header, 节省内存\n#define SDS_TYPE_5  0\n#define SDS_TYPE_8  1\n#define SDS_TYPE_16 2\n#define SDS_TYPE_32 3\n#define SDS_TYPE_64 4")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("len: 表示字符串的真正长度")])]),i._v(" "),t("li",[t("p",[i._v("alloc: 表示字符串的最大容量")])]),i._v(" "),t("li",[t("p",[i._v("flags: 总是占用一个字节。")]),i._v(" "),t("p",[i._v("其中的最低3个bit用来表示header的类型。header的类型共有5种，在sds.h中有常量定义。")])]),i._v(" "),t("li",[t("p",[i._v("char buf[]: 表明flags后是一个字符数组")])]),i._v(" "),t("li",[t("p",[i._v("sdshdr5与其它几个header结构不同")]),i._v(" "),t("p",[i._v("sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。")])])])]),i._v(" "),t("li",[t("p",[i._v("字符串数组")]),i._v(" "),t("p",[i._v("通常是最大容量+1, 因为要存放NULL结束符, 兼容传统C字符串")])]),i._v(" "),t("li",[t("p",[i._v("通过字符串指针获取内存中header的位置")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("通过s1[-1]找到flags, 低3位解析出header的类型")])]),i._v(" "),t("li",[t("p",[i._v("拥有header类型后调用SDS_HDR(8, s1) 定位到header指针")]),i._v(" "),t("p",[i._v("在各个header的定义中使用了__attribute__ ((packed))，是为了让编译器以紧凑模式来分配内存, 保证\nheader和sds的数据部分紧紧前后相邻,\n向低地址方向偏移1个字节的方式来获取flags")])])])])])]),i._v(" "),t("li",[t("p",[i._v("结构优势")]),i._v(" "),t("ul",[t("li",[i._v("header和数据相邻, 减少内存碎片, 提高存储效率")]),i._v(" "),t("li",[i._v("统一的char *表达, 兼容C, 可直接进行C函数调用")])])]),i._v(" "),t("li",[t("p",[i._v("sds基础函数")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("sdslen(s) 求长度")]),i._v(" "),t("ul",[t("li",[i._v("字符串->flag->header类型->SDS_HDR->len")])])]),i._v(" "),t("li",[t("p",[i._v("sdsReqType 不同size选用不同header")]),i._v(" "),t("p",[i._v("通过sdsReqType的代码，很容易看到：\n长度在0和2^5-1之间，选用SDS_TYPE_5类型的header\n长度在2^5和2^8-1之间，选用SDS_TYPE_8类型的header\n长度在2^8和2^16-1之间，选用SDS_TYPE_16类型的header\n长度在2^16和2^32-1之间，选用SDS_TYPE_32类型的header\n长度大于2^32的选用SDS_TYPE_64类型的header。能表示的最大长度为2^64-1\n注：sdsReqType的实现代码，直到3.2.0，它在长度边界值上都一直存在问题，直到最近3.2 branch上的commit 6032340才修复。")])]),i._v(" "),t("li",[t("p",[i._v("sdscatlen(s, "),t("em",[i._v("t, len)\n将")]),i._v("t指向的数据(长度len)追加到s后")]),i._v(" "),t("ul",[t("li",[i._v("子主题 1")])])]),i._v(" "),t("li",[t("p",[i._v("sdsMakeRoomFor(s, addlen)\n保证字符串s有足够空间追加(len长度)")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("如果原字符串空间够用, 直接返回")])]),i._v(" "),t("li",[t("p",[i._v("如果需要分配空间, 会比实际请求多分配一些, 以备接下来继续追加")]),i._v(" "),t("p",[i._v("它在字符串已经比较长的情况下要至少多分配SDS_MAX_PREALLOC个字节，这个常量在sds.h中定义为(1024*1024)=1MB。")])]),i._v(" "),t("li",[t("p",[i._v("按分配后的空间大小，可能需要更换header类型")]),i._v(" "),t("p",[i._v("（原来header的alloc字段太短，表达不了增加后的容量）")])]),i._v(" "),t("li",[t("p",[i._v("如果需要更换header, 整个sds重新分配, 数据搬迁")]),i._v(" "),t("p",[i._v("如果需要更换header，那么整个字符串空间（包括header）都需要重新分配（s_malloc），并拷贝原来的数据到新的位置")])]),i._v(" "),t("li",[t("p",[i._v("如果不需要更换header, 尝试原地址上重新分配; 成功直接返回, 失败重新分配新地址+数据搬迁")]),i._v(" "),t("p",[i._v("如果不需要更换header（原来的header够用），那么调用一个比较特殊的s_realloc，试图在原来的地址上重新分配空间\n如果原来的地址位置有足够的空余空间完成重新分配，那么它返回的新地址与传入的旧地址相同；否则，它分配新的地址块，并进行数据搬迁")])])])]),i._v(" "),t("li",[t("p",[i._v("sdscatlen函数使用模式")]),i._v(" "),t("p",[i._v("调用它的时候，传入一个旧的sds变量，然后它返回一个新的sds变量。由于它的内部实现可能会造成地址变化，因此调用者在调用完之后，原来旧的变量就失效了，而都应该用新返回的变量来替换。不仅仅是sdscatlen函数，sds中的其它函数（比如sdscpy、sdstrim、sdsjoin等），还有Redis中其它一些能自动扩展内存的数据结构（如ziplist），也都是同样的使用模式。")])])])]),i._v(" "),t("li",[t("p",[i._v("sds创建和销毁")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("sdsnewlen(*init, initlen)")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("创建长度为initlen的sds字符串, 用*init的数据初始化sds字符串")]),i._v(" "),t("p",[i._v("如果init为NULL，那么使用全0来初始化数据。")])]),i._v(" "),t("li",[t("p",[i._v("如果创建长度为0的空字符串, 很可能接下来的操作是追加, 所以创建SDS_TYPE_8类型的header")])]),i._v(" "),t("li",[t("p",[i._v("需要的内存一次性进行分配")]),i._v(" "),t("p",[i._v("其中包含三部分：header、数据、最后的多余字节（hdrlen+initlen+1）")])]),i._v(" "),t("li",[t("p",[i._v("初始化的sds字符串数据最后会追加一个NULL结束符（s[initlen] = ‘\\0’）")])])])]),i._v(" "),t("li",[t("p",[i._v("sdsfree")]),i._v(" "),t("ul",[t("li",[i._v("内存整体释放, 将header起始指针传给s_free")])])])])]),i._v(" "),t("li",[t("p",[i._v("string和sds的关系")]),i._v(" "),t("ul",[t("li",[i._v("append, setbit, getrange 使用 sds 实现")]),i._v(" "),t("li",[i._v("当string为数值,incr/decr/setbit/getrange,就不是sds实现")])])])]),i._v(" "),t("h3",{attrs:{id:"robj-redisobject"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#robj-redisobject"}},[i._v("#")]),i._v(" robj(redisObject)")]),i._v(" "),t("p",[i._v("可以表示多种类型")]),i._v(" "),t("p",[i._v("https://mp.weixin.qq.com/s/Jlv6AgaO4QrCXvjr6RipIQ")]),i._v(" "),t("p",[i._v("为多种数据类型提供一种统一的表示方式。\n允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。\n支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("结构")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("type 对象的数据类型(api)")]),i._v(" "),t("p",[i._v("OBJ_STRING,\nOBJ_LIST,\nOBJ_SET,\nOBJ_ZSET,\nOBJ_HASH")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("同一type可能不同encoding")]),i._v(" "),t("p",[i._v("当type = OBJ_STRING的时候，表示这个robj存储的是一个string，这时encoding可以是下面3种中的一种：\nOBJ_ENCODING_RAW: string采用原生的表示方式，即用sds来表示。\nOBJ_ENCODING_INT: string采用数字的表示方式，实际上是一个long型。\nOBJ_ENCODING_EMBSTR: string采用一种特殊的嵌入式的sds来表示。")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("string可能是raw, int, embstr\nhash可能是dict, ziplist")]),i._v(" "),t("p",[i._v("string默认不为double, incrbyfloat是在sds基础上做的浮点运算")])])])])])]),i._v(" "),t("li",[t("p",[i._v("encoding 对象的内部表示方式")]),i._v(" "),t("p",[i._v("OBJ_ENCODING_RAW: 最原生的表示方式。其实只有string类型才会用这个encoding值（表示成sds）。\nOBJ_ENCODING_INT: 表示成数字。实际用long表示。\nOBJ_ENCODING_HT: 表示成dict。\nOBJ_ENCODING_ZIPMAP: 是个旧的表示方式，已不再用。在小于Redis 2.6的版本中才有。\nOBJ_ENCODING_LINKEDLIST: 也是个旧的表示方式，已不再用。\nOBJ_ENCODING_ZIPLIST: 表示成ziplist。\nOBJ_ENCODING_INTSET: 表示成intset。用于set数据结构。\nOBJ_ENCODING_SKIPLIST: 表示成skiplist。用于sorted set数据结构。\nOBJ_ENCODING_EMBSTR: 表示成一种特殊的嵌入式的sds。\nOBJ_ENCODING_QUICKLIST: 表示成quicklist。用于list数据结构。")]),i._v(" "),t("ul",[t("li",[i._v("EMBSTR压缩版sds(存储), RAW原版(操作)")])])]),i._v(" "),t("li",[t("p",[i._v("lru 做LRU替换算法用")])]),i._v(" "),t("li",[t("p",[i._v("refcount 引用计数")]),i._v(" "),t("ul",[t("li",[i._v("引用计数器归零会将robj内存释放")])])]),i._v(" "),t("li",[t("p",[i._v("ptr 数据指针")]),i._v(" "),t("ul",[t("li",[i._v("指向真正的数据如 sds")])])])])]),i._v(" "),t("li",[t("p",[i._v("tryObjectEncoding(robj)\n编码")]),i._v(" "),t("p",[i._v("set命令首先将接收到的value值（string类型）表示成一个type = OBJ_STRING并且encoding = OBJ_ENCODING_RAW的对象，然后在存入内部存储之前先执行一个编码过程，试图将它表示成另一种更节省内存的encoding方式。\n这一过程的核心代码，tryObjectEncoding函数")]),i._v(" "),t("ul",[t("li",[t("ol",[t("li",[i._v("检查type, 确保string")])])])])])]),i._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("p",[i._v("检查encoding, RAW和EMBSTR可进一步编码")])]),i._v(" "),t("li",[t("p",[i._v("检查refcount, 不对共享对象编码")])]),i._v(" "),t("li",[t("p",[i._v("试图转成64位long()")]),i._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[i._v(" - 成功, 不要求LRU替换&&数字值较小, 使用预存的小数字对象; 否则转换encoding并直接存在robj的ptr数据指针处\n - 失败, 如果长度足够小, 转成EMPSTR; \n")])])])])]),i._v(" "),t("p",[i._v("不足够小, 如果空余字节过多, 释放空余字节")]),i._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[i._v("\t\t- createEmbeddedStringObject\n\t\n\t\t  对sds重新分配内存, 将robj和sds放在连续的内存块中, (对于短字符串)利于减少内存碎片\n\t\n\t\t- sdsRemoveFreeSpace\n")])])]),t("ul",[t("li",[t("p",[i._v("getDecodedObject(robj)\n解码")]),i._v(" "),t("p",[i._v("执行get, 需要做编码过程相反的操作")]),i._v(" "),t("ul",[t("li",[i._v("sds的两个类型对象直接返回")]),i._v(" "),t("li",[i._v("若为数字的robj, 将long转为十进制字符串形式, 调用createStringObject转为EMBSTR(sds)")])])]),i._v(" "),t("li",[t("p",[i._v("总结")]),i._v(" "),t("ul",[t("li",[i._v("string类型是以robj表示,\n有3种encoding, INT, EMBSTR, RAW")]),i._v(" "),t("li",[i._v("INT类型的可以直接运算, 而EMBSTR和RAW需要实时转换成long再运算(如果转不了就报错)")]),i._v(" "),t("li",[i._v("append, setbit, getrange 会先把INT转成sds字符串操作(一般是RAW)")])])])]),i._v(" "),t("h3",{attrs:{id:"ziplist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ziplist"}},[i._v("#")]),i._v(" ziplist")]),i._v(" "),t("p",[i._v('特殊的"双向链表"')]),i._v(" "),t("p",[i._v("ziplist将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("结构")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("zlbytes, ziplist占用的字节总数")])]),i._v(" "),t("li",[t("p",[i._v("zltail, 最后一项偏移量")])]),i._v(" "),t("li",[t("p",[i._v("zllen, 数据项（entry）的个数")])]),i._v(" "),t("li",[t("p",[i._v("entry 数据项")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("prevrawlen, 前一个数据长度")]),i._v(" "),t("ul",[t("li",[i._v("1字节(254)或5字节整形")])])]),i._v(" "),t("li",[t("p",[i._v("len, data长度")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("根据len第一个字节分成多种情况")]),i._v(" "),t("p",[i._v("|00pppppp| - 1 byte。第1个字节最高两个bit是00，那么"),t("len",[i._v("字段只有1个字节，剩余的6个bit用来表示长度值，最高可以表示63 (2^6-1)。\n|01pppppp|qqqqqqqq| - 2 bytes。第1个字节最高两个bit是01，那么"),t("len",[i._v("字段占2个字节，总共有14个bit用来表示长度值，最高可以表示16383 (2^14-1)。\n|10__|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes。第1个字节最高两个bit是10，那么len字段占5个字节，总共使用32个bit来表示长度值（6个bit舍弃不用），最高可以表示2^32-1。需要注意的是：在前三种情况下，"),t("data",[i._v("都是按字符串来存储的；从下面第4种情况开始，"),t("data",[i._v("开始变为按整数来存储了。\n|11000000| - 1 byte。"),t("len",[i._v("字段占用1个字节，值为0xC0，后面的数据"),t("data",[i._v("存储为2个字节的int16_t类型。\n|11010000| - 1 byte。"),t("len",[i._v("字段占用1个字节，值为0xD0，后面的数据"),t("data",[i._v("存储为4个字节的int32_t类型。\n|11100000| - 1 byte。"),t("len",[i._v("字段占用1个字节，值为0xE0，后面的数据"),t("data",[i._v("存储为8个字节的int64_t类型。\n|11110000| - 1 byte。"),t("len",[i._v("字段占用1个字节，值为0xF0，后面的数据"),t("data",[i._v("存储为3个字节长的整数。\n|11111110| - 1 byte。"),t("len",[i._v("字段占用1个字节，值为0xFE，后面的数据"),t("data",[i._v("存储为1个字节的整数。\n|1111xxxx| - - (xxxx的值在0001和1101之间)。这是一种特殊情况，xxxx从1到13一共13个值，这时就用这13个值来表示真正的数据。注意，这里是表示真正的数据，而不是数据长度了。也就是说，在这种情况下，后面不再需要一个单独的"),t("data",[i._v("字段来表示真正的数据了，而是"),t("len",[i._v("和"),t("data",[i._v("合二为一了。另外，由于xxxx只能取0001和1101这13个值了（其它可能的值和其它情况冲突了，比如0000和1110分别同前面第7种第8种情况冲突，1111跟结束标记冲突），而小数值应该从0开始，因此这13个值分别表示0到12，即xxxx的值减去1才是它所要表示的那个整数数据的值。")])])],1)])])],1)])],1)])],1)])],1)])],1)])])],1)],1)])])]),i._v(" "),t("li",[t("p",[i._v("data")])])])]),i._v(" "),t("li",[t("p",[i._v("zlend, 结束标记, 值固定255")])]),i._v(" "),t("li",[t("p",[i._v("小端（little endian）模式存储")])]),i._v(" "),t("li",[t("p",[i._v("ziplist没用struct表达\n而是简单的unsigned char *\n因为本质上是块连续内存")])])])]),i._v(" "),t("li",[t("p",[i._v("接口")]),i._v(" "),t("p",[i._v("unsigned char *ziplistNew(void);\nunsigned char *ziplistMerge(unsigned char **first, unsigned char **second);\nunsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where);\nunsigned char *ziplistIndex(unsigned char *zl, int index);\nunsigned char *ziplistNext(unsigned char *zl, unsigned char *p);\nunsigned char *ziplistPrev(unsigned char *zl, unsigned char *p);\nunsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen);\nunsigned char *ziplistDelete(unsigned char *zl, unsigned char **p);\nunsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip);\nunsigned int ziplistLen(unsigned char *zl);")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("ziplistnew, 创建一个空的ziplist")]),i._v(" "),t("p",[i._v("ziplist的数据类型，没有用自定义的struct之类的来表达，而就是简单的unsigned char *。这是因为ziplist本质上就是一块连续内存，内部组成结构又是一个高度动态的设计（变长编码），也没法用一个固定的数据结构来表达。\nziplistNew: 创建一个空的ziplist（只包含"),t("zlbytes",[t("zltail",[t("zllen",[t("zlend",[i._v("）。\nziplistMerge: 将两个ziplist合并成一个新的ziplist。\nziplistPush: 在ziplist的头部或尾端插入一段数据（产生一个新的数据项）。注意一下这个接口的返回值，是一个新的ziplist。调用方必须用这里返回的新的ziplist，替换之前传进来的旧的ziplist变量，而经过这个函数处理之后，原来旧的ziplist变量就失效了。为什么一个简单的插入操作会导致产生一个新的ziplist呢？这是因为ziplist是一块连续空间，对它的追加操作，会引发内存的realloc，因此ziplist的内存位置可能会发生变化。实际上，我们在之前介绍sds的文章中提到过类似这种接口使用模式（参见sdscatlen函数的说明）。\nziplistIndex: 返回index参数指定的数据项的内存位置。index可以是负数，表示从尾端向前进行索引。\nziplistNext和ziplistPrev分别返回一个ziplist中指定数据项p的后一项和前一项。\nziplistInsert: 在ziplist的任意数据项前面插入一个新的数据项。\nziplistDelete: 删除指定的数据项。\nziplistFind: 查找给定的数据（由vstr和vlen指定）。注意它有一个skip参数，表示查找的时候每次比较之间要跳过几个数据项。为什么会有这么一个参数呢？其实这个参数的主要用途是当用ziplist表示hash结构的时候，是按照一个field，一个value来依次存入ziplist的。也就是说，偶数索引的数据项存field，奇数索引的数据项存value。当按照field的值进行查找的时候，就需要把奇数项跳过去。\nziplistLen: 计算ziplist的长度（即包含数据项的个数）。")])],1)],1)],1)],1)]),i._v(" "),t("li",[t("p",[i._v("ziplist插入")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("ziplistPush")])]),i._v(" "),t("li",[t("p",[i._v("ziplistInsert")])]),i._v(" "),t("li",[t("p",[i._v("__ziplistInsert")]),i._v(" "),t("p",[i._v("unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen)")]),i._v(" "),t("ul",[t("li",[t("ol",[t("li",[i._v("在指定位置插入一段新的数据, 后面的数据向后移动")])])])])])])])])])]),i._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[i._v("计算插入前段数据的长度作为prevrawlen")]),i._v(" "),t("li",[i._v("计算当前数据占用总字节数(数据部分尝试转整数)")]),i._v(" "),t("li",[i._v("插入位置原来数据的prevrawlen可能变化")]),i._v(" "),t("li",[i._v("计算ziplist空间, 调整内存空间, 并将数据插入")])]),i._v(" "),t("ul",[t("li",[t("p",[i._v("hash数据类型与ziplist\n优劣, 总结, 配置")]),i._v(" "),t("ul",[t("li",[i._v("field较少, value值较小的时候, hash采用ziplist实现; 反之使用dict")]),i._v(" "),t("li",[i._v('"存储一个对象, 使用hash比string节省内存"?')])])])]),i._v(" "),t("ol",[t("li",[i._v("把对象的属性存储到多个string key上(费)")]),i._v(" "),t("li",[i._v("把对象序列化存到一个string(省)")]),i._v(" "),t("li",[i._v("hash对于序列化的优势在于对属性的操作; 劣势在于数据过多会失去存储优势(dict实现)\n"),t("ul",[t("li",[t("p",[i._v("hset key field value 会创建出 encoding为ziplist的hashOBJ")])]),i._v(" "),t("li",[t("p",[i._v("ziplist和hash的转换关系?\n配置中, 两个条件满足之一")]),i._v(" "),t("ul",[t("li",[i._v("hash-max-ziplist-entries 512\n最大数据对 512 对")]),i._v(" "),t("li",[i._v("hash-max-ziplist-value 64|\nvalue最大长度")])])]),i._v(" "),t("li",[t("p",[i._v("ziplist本来就设计为各个数据项挨在一起组成连续的内存空间，这种结构并不擅长做修改操作。\n一旦数据发生改动，就会引发内存realloc，可能导致内存拷贝。")])])])])]),i._v(" "),t("h3",{attrs:{id:"quicklist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#quicklist"}},[i._v("#")]),i._v(" quicklist")]),i._v(" "),t("p",[i._v("作为list实现")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("概述")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("A doubly linked list of ziplists")])]),i._v(" "),t("li",[t("p",[i._v("双向链表: 地址不连续, 内存开销大\nziplist: 每次修改操作可能realloc")])]),i._v(" "),t("li",[t("p",[i._v("quicklist是以ziplist为节点组成的双向链表")]),i._v(" "),t("ul",[t("li",[i._v("子主题 1")])])]),i._v(" "),t("li",[t("p",[i._v("list-max-ziplist-size -2")]),i._v(" "),t("p",[i._v("当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度:\n当取负值的时候\n-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb => 1024 bytes）\n-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。\n-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。\n-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）\n-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。")])]),i._v(" "),t("li",[t("p",[i._v("list-compress-depth 0")]),i._v(" "),t("p",[i._v("列表很长的时候, 中间的数据被访问的频率比较低\n可以配置list-compress-depth项来将中间的数据节点进行压缩\n0: 是个特殊值，表示都不压缩。这是Redis的默认值。\n1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。\n2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。\n3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。")]),i._v(" "),t("ul",[t("li",[i._v("LZF压缩算法")])])])])]),i._v(" "),t("li",[t("p",[i._v("结构")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("quicklistNode")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("prev, next 指针")])]),i._v(" "),t("li",[t("p",[i._v("zl 数据指针, 指向ziplist或LZF结构")])]),i._v(" "),t("li",[t("p",[i._v("sz 表示zl指向的ziplist大小(*无视压缩)")])]),i._v(" "),t("li",[t("p",[i._v("count 表示ziplist里的数据项个数")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("count字段这16bit是否够用?")]),i._v(" "),t("p",[i._v("我们已经知道，ziplist大小受到list-max-ziplist-size参数的限制。按照正值和负值有两种情况：\n当这个参数取正值的时候，就是恰好表示一个quicklistNode结构中zl所指向的ziplist所包含的数据项的最大值。list-max-ziplist-size参数是由quicklist结构的fill字段来存储的，而fill字段是16bit，所以它所能表达的值能够用16bit来表示。\n当这个参数取负值的时候，能够表示的ziplist最大长度是64 Kb。而ziplist中每一个数据项，最少需要2个字节来表示：1个字节的prevrawlen，1个字节的data（len字段和data合二为一；详见上一篇）。所以，ziplist中数据项的个数不会超过32 K，用16bit来表达足够了。\n实际上，在目前的quicklist的实现中，ziplist的大小还会受到另外的限制，根本不会达到这里所分析的最大值。")])])])]),i._v(" "),t("li",[t("p",[i._v("encoding 是否压缩了")])]),i._v(" "),t("li",[t("p",[i._v("container 预留字段, 表示容器类型")])]),i._v(" "),t("li",[t("p",[i._v("recompress")]),i._v(" "),t("ul",[t("li",[i._v("(若使用index解压查看数据)需要再次压缩的标记")])])])])]),i._v(" "),t("li",[t("p",[i._v("quicklistLZF")]),i._v(" "),t("ul",[t("li",[i._v("sz: 压缩后大小\ncompressd: 柔性数组 flexible array member")])])]),i._v(" "),t("li",[t("p",[i._v("quicklist")]),i._v(" "),t("ul",[t("li",[i._v("head: 指向头节点（左侧第一个节点）的指针。")]),i._v(" "),t("li",[i._v("tail: 指向尾节点（右侧第一个节点）的指针。")]),i._v(" "),t("li",[i._v("count: 所有ziplist数据项的个数总和。")]),i._v(" "),t("li",[i._v("len: quicklist节点的个数。")]),i._v(" "),t("li",[i._v("fill: 16bit, ziplist大小设置, 存放list-max-ziplist-size参数值")]),i._v(" "),t("li",[i._v("compress: 16bit, 节点压缩深度设置, list-compress-depth参数值")])])])])]),i._v(" "),t("li",[t("p",[i._v("操作")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("lpush操作会先创建quicklist\n调用quicklistCreate")]),i._v(" "),t("ul",[t("li",[i._v("创建一个空的quicklist")])])]),i._v(" "),t("li",[t("p",[i._v("quicklistPush")]),i._v(" "),t("ul",[t("li",[i._v("_quicklistNodeAllowInsert\n如果头/尾结点ziplist大小没有超过限制\n直接插入到ziplist中\n如果太大, 新建Node节点, 并加入双向链表\n(_quicklistInsertNodeAfter)")])])]),i._v(" "),t("li",[t("p",[i._v("pop操作 quicklistPopCustom")])]),i._v(" "),t("li",[t("p",[i._v("quicklistInsertAfter, quicklistInsertBefore\n指定下标的插入")]),i._v(" "),t("p",[i._v("当插入位置所在的ziplist大小没有超过限制时，直接插入到ziplist中就好了；\n当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小没有超过限制，那么就转而插入到相邻的那个quicklist链表节点的ziplist中；\n当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小也超过限制，这时需要新创建一个quicklist链表节点插入。\n对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。")])]),i._v(" "),t("li",[t("p",[i._v("quicklistSetOptions用于设置配置参数")])])])])]),i._v(" "),t("h3",{attrs:{id:"skiplist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#skiplist"}},[i._v("#")]),i._v(" skiplist")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("概述")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("有序链表->多层链表->skiplist")]),i._v(" "),t("p",[i._v("有序链表, O(n)顺序查找\n多层链表: 每相邻两个节点增加一个指针, 指向下下个节点, 可以以两倍速度查找, 再依次增加指针, 可以达到logn.问题在于多层链表的层数结构固定, 新增删除需要维护很多节点O(n)\n跳跃表: 对层数不做固定, 随机生成, 这样新增或删除只需要维护自身节点O(1), 查找效率能有O(logn)")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("层数伪随机")]),i._v(" "),t("p",[i._v("首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。\n如果一个节点有第i层(i>=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。\n节点最大的层数不允许超过一个最大值，记为MaxLevel。\nredis中, 这两个参数为\np = 1/4\nMaxLevel = 32\n平均指针1.33, 平均时间复杂度log(n)")])]),i._v(" "),t("li",[t("p",[i._v("skiplist算法性能分析(见博客)")])]),i._v(" "),t("li",[t("p",[i._v("skiplist和平衡树, 哈希表")]),i._v(" "),t("ul",[t("li",[t("ol",[t("li",[i._v("范围查找, 哈希表弱, 平衡树复杂, skiplist最快")])])])])])])])])])]),i._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("p",[i._v("插入和删除, 平衡树复杂, skiplist简单")])]),i._v(" "),t("li",[t("p",[i._v("内存占用, skiplist占优")])]),i._v(" "),t("li",[t("p",[i._v("查找, 哈希表最优")])]),i._v(" "),t("li",[t("p",[i._v("算法实现难度, skiplist易于平衡树")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("sorted set / zset")]),i._v(" "),t("ul",[t("li",[i._v("数据较少-ziplist; 数据较多-dict+skiplist")])])]),i._v(" "),t("li",[t("p",[i._v("对skiplist做改造, 允许重复, 计算排名..")])]),i._v(" "),t("li",[t("p",[i._v("作为ziplist时, 查找为顺序查找")])])])])]),i._v(" "),t("ul",[t("li",[t("p",[i._v("结构")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("zskiplistNode")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("robj sds编码")])]),i._v(" "),t("li",[t("p",[i._v("score 分数")])]),i._v(" "),t("li",[t("p",[i._v("backward")])]),i._v(" "),t("li",[t("p",[i._v("level[] 存放各层")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("forward 指针")])]),i._v(" "),t("li",[t("p",[i._v("span 指针跨越多少节点, 计算排名")]),i._v(" "),t("ul",[t("li",[i._v("查找数据时不断累加span, 可以获得排名")]),i._v(" "),t("li",[i._v("按排名查找时只要累加span使其不超过目标值")])])])])])])]),i._v(" "),t("li",[t("p",[i._v("zskiplist")]),i._v(" "),t("ul",[t("li",[i._v("head和tail")]),i._v(" "),t("li",[i._v("length 链表长度")]),i._v(" "),t("li",[i._v("level 层数最大值")])])]),i._v(" "),t("li",[t("p",[i._v("zset")]),i._v(" "),t("ul",[t("li",[i._v("dict + zskiplist")])])])])]),i._v(" "),t("li",[t("p",[i._v("操作")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("满足之一会转成zset\n元素个数, val长度")]),i._v(" "),t("ul",[t("li",[i._v("zset-max-ziplist-entries 128")]),i._v(" "),t("li",[i._v("zset-max-ziplist-value 64")])])])])])]),i._v(" "),t("h3",{attrs:{id:"intset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#intset"}},[i._v("#")]),i._v(" intset")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("概述")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("set结构数据较少intset, 数据较多用dict实现\n若添加了非int的直接转为dict实现")]),i._v(" "),t("ul",[t("li",[i._v("set-max-intset-entries\n集合元素个数")])])]),i._v(" "),t("li",[t("p",[i._v("intset是一个由整数组成的有序集合, 通过二分查找确认是否存在")]),i._v(" "),t("p",[i._v("便于在上面进行二分查找，用于快速地判断一个元素是否属于这个集合。\n它在内存分配上与ziplist有些类似\n对于大整数和小整数（按绝对值）采取了不同的编码，尽量优化内存")])])])]),i._v(" "),t("li",[t("p",[i._v("结构")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("encoding 数据编码")]),i._v(" "),t("p",[i._v("表示intset中的每个数据元素用几个字节来存储\nINTSET_ENC_INT16表示2个字节\nINTSET_ENC_INT32表示4个字节\nINTSET_ENC_INT64表示8个字节")]),i._v(" "),t("ul",[t("li",[i._v("会随着数据的添加而改变")])])]),i._v(" "),t("li",[t("p",[i._v("length 元素个数")])]),i._v(" "),t("li",[t("p",[i._v("contents[] 柔性数组, 数据元素")]),i._v(" "),t("p",[i._v("数组的总长度等于encoding * length")])])])]),i._v(" "),t("li",[t("p",[i._v("操作")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("intsetFind")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("_intsetValueEncoding 查找val的数据编码")])]),i._v(" "),t("li",[t("p",[i._v("若在数据范围之内, 调用intsetSearch二分查找")]),i._v(" "),t("p",[i._v("intsetSearch是对于二分查找算法的一个实现，它大致分为三个部分：\n特殊处理intset为空的情况。\n特殊处理两个边界情况：当要查找的value比最后一个元素还要大或者比第一个元素还要小的时候。实际上，这两部分的特殊处理，在二分查找中并不是必须的，但它们在这里提供了特殊情况下快速失败的可能。\n真正执行二分查找过程。注意：如果最后没找到，插入位置在min指定的位置。")])])])]),i._v(" "),t("li",[t("p",[i._v("intsetAdd")]),i._v(" "),t("ul",[t("li",[i._v("查编码, 比当前编码大直接升级编码并插入")]),i._v(" "),t("li",[i._v("二分查找, 如果没找到进行内存扩展(数据拷贝+插入)")])])]),i._v(" "),t("li",[t("p",[i._v("并交差集")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("sinterGenericCommand 交集")]),i._v(" "),t("p",[i._v("检查各个集合，对于不存在的集合当做空集来处理。一旦出现空集，最终的交集就是空集。\n对各个集合按照元素个数由少到多进行排序。这个排序有利于后面计算的时候从最小的集合开始，需要处理的元素个数较少。\n对排序后第一个集合（也就是最小集合）进行遍历，对于它的每一个元素，依次在后面的所有集合中进行查找。只有在所有集合中都能找到的元素，才加入到最后的结果集合中。")])]),i._v(" "),t("li",[t("p",[i._v("sunionDiffGenericCommand")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("并集")]),i._v(" "),t("p",[i._v("计算并集最简单，只需要遍历所有集合，将每一个元素都添加到最后的结果集合中。向集合中添加元素会自动去重")])]),i._v(" "),t("li",[t("p",[i._v("差集")]),i._v(" "),t("p",[i._v("计算差集有两种可能的算法，它们的时间复杂度有所区别。\n第一种算法：\n对第一个集合进行遍历，对于它的每一个元素，依次在后面的所有集合中进行查找。只有在所有集合中都找不到的元素，才加入到最后的结果集合中。")]),i._v(" "),t("p",[i._v("这种算法的时间复杂度为O(N*M)，其中N是第一个集合的元素个数，M是集合数目。\n第二种算法：\n将第一个集合的所有元素都加入到一个中间集合中。\n遍历后面所有的集合，对于碰到的每一个元素，从中间集合中删掉它。\n最后中间集合剩下的元素就构成了差集。\n这种算法的时间复杂度为O(N)，其中N是所有集合的元素个数总和。")]),i._v(" "),t("p",[i._v("在计算差集的开始部分，会先分别估算一下两种算法预期的时间复杂度，然后选择复杂度低的算法来进行运算。还有两点需要注意：\n在一定程度上优先选择第一种算法，因为它涉及到的操作比较少，只用添加，而第二种算法要先添加再删除。\n如果选择了第一种算法，那么在执行该算法之前，Redis的实现中对于第二个集合之后的所有集合，按照元素个数由多到少进行了排序。这个排序有利于以更大的概率查找到元素，从而更快地结束查找。")])])])])])])])])]),i._v(" "),t("h2",{attrs:{id:"redis工作模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis工作模型"}},[i._v("#")]),i._v(" redis工作模型")]),i._v(" "),t("h3",{attrs:{id:"单线程worker-免去加锁的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单线程worker-免去加锁的过程"}},[i._v("#")]),i._v(" 单线程worker, 免去加锁的过程")]),i._v(" "),t("ul",[t("li",[i._v("简化了数据结构和算法的实现")])]),i._v(" "),t("h3",{attrs:{id:"使用epoll进行io通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用epoll进行io通信"}},[i._v("#")]),i._v(" 使用epoll进行IO通信")]),i._v(" "),t("ul",[t("li",[i._v("异步IO和pipeline等机制来实现高速的并发访问")])]),i._v(" "),t("h2",{attrs:{id:"redis持久化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis持久化"}},[i._v("#")]),i._v(" redis持久化")]),i._v(" "),t("h3",{attrs:{id:"rdb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[i._v("#")]),i._v(" RDB")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("RedisDB快照")]),i._v(" "),t("ul",[t("li",[i._v("生成整个Redis的快照, save阻塞不提供服务, bgsave子线程非阻塞, copyonwrite机制")])])])]),i._v(" "),t("h3",{attrs:{id:"aof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[i._v("#")]),i._v(" AOF")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("AppendOnlyFile日志")]),i._v(" "),t("ul",[t("li",[i._v("将redis的操作记录在文件中, fsync由操作系统保存")])])]),i._v(" "),t("li",[t("p",[i._v("重写")]),i._v(" "),t("ul",[t("li",[i._v("解决AOF日志的无限增加, 合并命令")]),i._v(" "),t("li",[i._v("重写的两个参数:\n1.当AOF文件大小超过了上次重写的文件大小的百分之多少时进行重写\n2.文件大小超过多少才允许重写")])])])]),i._v(" "),t("h3",{attrs:{id:"区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[i._v("#")]),i._v(" 区别")]),i._v(" "),t("ul",[t("li",[t("ol",[t("li",[i._v("AOF")])])])]),i._v(" "),t("h2",{attrs:{id:"redis过期淘汰机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis过期淘汰机制"}},[i._v("#")]),i._v(" redis过期淘汰机制")]),i._v(" "),t("h3",{attrs:{id:"volatile-表示在过期时间的key中做选择"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#volatile-表示在过期时间的key中做选择"}},[i._v("#")]),i._v(" volatile: 表示在过期时间的key中做选择")]),i._v(" "),t("p",[i._v("allkeys: 在所有key中做选择\nlru 移除最久未使用的\nrandom 完全随机\nttl 选择最先过期的")]),i._v(" "),t("ul",[t("li",[i._v("volatile-lru")]),i._v(" "),t("li",[i._v("volatile-ttl")]),i._v(" "),t("li",[i._v("volatile-random")]),i._v(" "),t("li",[i._v("allkeys-lru")]),i._v(" "),t("li",[i._v("allkeys-random")])]),i._v(" "),t("h3",{attrs:{id:"noeviction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#noeviction"}},[i._v("#")]),i._v(" noeviction")]),i._v(" "),t("ul",[t("li",[i._v("不移除任何数据,返回一个写错误")])]),i._v(" "),t("h3",{attrs:{id:"_100-要求解释lru和lfu的实现-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_100-要求解释lru和lfu的实现-区别"}},[i._v("#")]),i._v(" 100%要求解释lru和lfu的实现, 区别")]),i._v(" "),t("h3",{attrs:{id:"redis的过期策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis的过期策略"}},[i._v("#")]),i._v(" redis的过期策略")]),i._v(" "),t("ul",[t("li",[i._v("定期删除")]),i._v(" "),t("li",[i._v("懒删除")]),i._v(" "),t("li",[i._v("1.首先遍历每个db进行定期删除,按照策略删除一部分key,保证过程中不占用太多资源\n2.访问key时顺便查看过期时间,如果过期直接删除")]),i._v(" "),t("li",[i._v("具体流程是,随机抽样(expire字典表中)一些(10到20)key,过期的key在抽样中如果超过25%,进行下一轮抽样和删除,直到低于25%")])]),i._v(" "),t("h2",{attrs:{id:"redis分布式集群的常见形式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式集群的常见形式"}},[i._v("#")]),i._v(" redis分布式集群的常见形式")]),i._v(" "),t("h2",{attrs:{id:"分布式锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[i._v("#")]),i._v(" 分布式锁")]),i._v(" "),t("h2",{attrs:{id:"缓存击穿"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[i._v("#")]),i._v(" 缓存击穿")]),i._v(" "),t("h2",{attrs:{id:"缓存雪崩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[i._v("#")]),i._v(" 缓存雪崩")]),i._v(" "),t("h2",{attrs:{id:"缓存一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存一致性"}},[i._v("#")]),i._v(" 缓存一致性")]),i._v(" "),t("h2",{attrs:{id:"常见问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[i._v("#")]),i._v(" 常见问题")]),i._v(" "),t("h3",{attrs:{id:"redis性能为什么高"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis性能为什么高"}},[i._v("#")]),i._v(" redis性能为什么高?")]),i._v(" "),t("h3",{attrs:{id:"单线程的redis如何利用多核cpu机器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单线程的redis如何利用多核cpu机器"}},[i._v("#")]),i._v(" 单线程的redis如何利用多核cpu机器？")]),i._v(" "),t("h3",{attrs:{id:"redis的缓存淘汰策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis的缓存淘汰策略"}},[i._v("#")]),i._v(" redis的缓存淘汰策略？")]),i._v(" "),t("h3",{attrs:{id:"redis如何持久化数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis如何持久化数据"}},[i._v("#")]),i._v(" redis如何持久化数据？")]),i._v(" "),t("h3",{attrs:{id:"redis有哪几种数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis有哪几种数据结构"}},[i._v("#")]),i._v(" redis有哪几种数据结构？")]),i._v(" "),t("h3",{attrs:{id:"redis集群有哪几种形式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis集群有哪几种形式"}},[i._v("#")]),i._v(" redis集群有哪几种形式？")]),i._v(" "),t("h3",{attrs:{id:"有海量key和value都比较小的数据-在redis中如何存储才更省内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有海量key和value都比较小的数据-在redis中如何存储才更省内存"}},[i._v("#")]),i._v(" 有海量key和value都比较小的数据，在redis中如何存储才更省内存？")]),i._v(" "),t("h3",{attrs:{id:"如何保证redis和db中的数据一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证redis和db中的数据一致性"}},[i._v("#")]),i._v(" 如何保证redis和DB中的数据一致性？")]),i._v(" "),t("h3",{attrs:{id:"如何解决缓存穿透和缓存雪崩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何解决缓存穿透和缓存雪崩"}},[i._v("#")]),i._v(" 如何解决缓存穿透和缓存雪崩？")]),i._v(" "),t("h3",{attrs:{id:"如何用redis实现分布式锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何用redis实现分布式锁"}},[i._v("#")]),i._v(" 如何用redis实现分布式锁？")]),i._v(" "),t("h3",{attrs:{id:"redis对比memcached"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis对比memcached"}},[i._v("#")]),i._v(" redis对比memcached")]),i._v(" "),t("p",[i._v("1.计算向数据移动\n2.mem的value没有类型概念,一般存json格式的字符串, redis可以存各种类型,并且每种类型提供了一系列操作api\n3.Redis可以持久化")]),i._v(" "),t("h3",{attrs:{id:"redis为什么用skiplist而不用平衡树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis为什么用skiplist而不用平衡树"}},[i._v("#")]),i._v(" Redis为什么用skiplist而不用平衡树")]),i._v(" "),t("ol",[t("li",[i._v("内存占用小, 比起b树")]),i._v(" "),t("li",[i._v("范围查找快")]),i._v(" "),t("li",[i._v("易于实现")])])])}),[],!1,null,null,null);_.default=v.exports}}]);