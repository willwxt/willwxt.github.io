(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{419:function(a,e,t){"use strict";t.r(e);var r=t(45),v=Object(r.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"分布式相关备忘录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式相关备忘录"}},[a._v("#")]),a._v(" 分布式相关备忘录")]),a._v(" "),t("h4",{attrs:{id:"🎞🎞🎞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#🎞🎞🎞"}},[a._v("#")]),a._v(" 🎞🎞🎞")]),a._v(" "),t("h2",{attrs:{id:"cap理论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cap理论"}},[a._v("#")]),a._v(" CAP理论")]),a._v(" "),t("p",[a._v("CAP 理论指出对于一个分布式计算系统来说, 不可能同时满足以下三点")]),a._v(" "),t("ol",[t("li",[t("strong",[a._v("一致性")]),a._v(": 在分布式环境中, 一致性是指数据在多个副本之间是否能够保持一致的特性, 等同于所有节点访问同一份最新的数据副本。在一致性的需求下, 当一个系统在数据一致的状态下执行更新操作后, 应该保证系统的数据仍然处于一致的状态。")]),a._v(" "),t("li",[t("strong",[a._v("可用性")]),a._v(": 每次请求都能获取到正确的响应, 但是不一定保证获取的数据为最新数据。")]),a._v(" "),t("li",[t("strong",[a._v("分区容错性")]),a._v(": 分布式系统在遇到任何网络分区故障的时候, 仍然需要能够保证对外提供满足一致性和可用性的服务, 除非是整个网络环境都发生了故障。(分布式系统往往需要保证的性质)")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://www.runoob.com/wp-content/uploads/2020/09/cap-theorem-diagram.png",alt:"cap理论"}})]),a._v(" "),t("p",[a._v("各分布式中间件实现: euraka是AP, zookeeper是CP")]),a._v(" "),t("h2",{attrs:{id:"base-理论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#base-理论"}},[a._v("#")]),a._v(" BASE 理论")]),a._v(" "),t("p",[a._v("相对于ACID")]),a._v(" "),t("p",[a._v("BASE 是 Basically Available(基本可用)、Soft-state(软状态) 和 Eventually Consistent(最终一致性) 缩写。")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("基本可用")]),a._v(": 在分布式系统出现故障, 允许损失部分可用性 (服务降级、页面降级) 。")]),a._v(" "),t("li",[t("strong",[a._v("软状态")]),a._v(": 允许分布式系统出现中间状态, 且中间状态不影响系统的可用性。这里的中间状态是指不同的 data replication (数据备份节点) 之间的数据更新可以出现延时的最终一致性。")]),a._v(" "),t("li",[t("strong",[a._v("最终一致性")]),a._v(": data replications 经过一段时间达到一致性(通常经过消息传递)")])]),a._v(" "),t("h2",{attrs:{id:"共识算法-一致性协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#共识算法-一致性协议"}},[a._v("#")]),a._v(" 共识算法/一致性协议")]),a._v(" "),t("p",[a._v("概述: 达成共识的机制, 在分布式系统中, 可以分为")]),a._v(" "),t("ul",[t("li",[a._v("崩溃容错协议crash fault tolerant,CFT")]),a._v(" "),t("li",[a._v("拜占庭容错协议Byzantine fault tolerant,BFT")])]),a._v(" "),t("h3",{attrs:{id:"paxos"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#paxos"}},[a._v("#")]),a._v(" Paxos")]),a._v(" "),t("p",[a._v("基于消息传递, 共识算法")]),a._v(" "),t("p",[t("strong",[a._v("成员列表")]),a._v(":  "),t("font",{attrs:{color:"ff5500"}},[a._v("Proposer提议者 , Acceptor接受者 , Learner学习者")]),a._v(" 每个节点身兼数职")],1),a._v(" "),t("ol",[t("li",[a._v("Proposer 发起提案")]),a._v(" "),t("li",[a._v("Acceptor 收到提案后可以接收提案")]),a._v(" "),t("li",[a._v("Learner 不参与决策, 只学习提案")])]),a._v(" "),t("h4",{attrs:{id:"算法流程-决议的提出与批准"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法流程-决议的提出与批准"}},[a._v("#")]),a._v(" 算法流程: 决议的提出与批准")]),a._v(" "),t("ol",[t("li",[a._v("prepare阶段:\n"),t("ol",[t("li",[a._v("proposer将发送prepare请求发送给大多数Acceptor, 这里假设提案id为n\n"),t("ul",[t("li",[a._v("这里会携带提案id, 无需携带内容")])])]),a._v(" "),t("li",[a._v("Acceptor收到消息后, 进行promise承诺回复\n"),t("ul",[t("li",[a._v("不再接受更多id小于等于本次请求的 prepare 请求")]),a._v(" "),t("li",[a._v("不在接收id小于本次请求的 accept 请求")]),a._v(" "),t("li",[a._v("回复收到过的最大id提案")])])])])]),a._v(" "),t("li",[a._v("Accept阶段\n"),t("ol",[t("li",[a._v("当proposer收到多数回复后, 向Acceptor发送 accept 请求\n"),t("ul",[t("li",[a._v("收到的回复带有id, 选择其中id最大者, 判断是否带有value, 有就使用此value, 否则可以用自己的value")])])]),a._v(" "),t("li",[a._v("Acceptor收到请求, 进行accept处理 (接收并持久化id和value)")])])]),a._v(" "),t("li",[a._v("Learner学习阶段: proposer收到多数accept回复, 形成决议, 并发送给所有learner")])]),a._v(" "),t("h4",{attrs:{id:"问题-paxos算法可能形成活锁而永远不会结束"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#问题-paxos算法可能形成活锁而永远不会结束"}},[a._v("#")]),a._v(" 问题: Paxos算法可能形成活锁而永远不会结束")]),a._v(" "),t("p",[a._v("两个Proposers交替Prepare成功, 而Accept失败, 形成活锁 Livelock")]),a._v(" "),t("h3",{attrs:{id:"multi-paxos算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#multi-paxos算法"}},[a._v("#")]),a._v(" Multi-Paxos算法")]),a._v(" "),t("p",[a._v("Basic Paxos网络请求较多, 极端情况下可能形成活锁, Multi-Paxos 对此进行两点改进:")]),a._v(" "),t("ol",[t("li",[a._v("针对每一个要确定的值, 运行一次Paxos算法实例 Instance, 形成决议; 每次都有唯一的Instance id标识")]),a._v(" "),t("li",[t("font",{attrs:{color:"ff5500"}},[a._v("在Proposers中选举一个Leader")]),a._v(" , 由Leader唯一地提交Proposal给Acceptors进行表决;\n"),t("ol",[t("li",[a._v("这样"),t("font",{attrs:{color:"ff5500"}},[a._v("没有Proposer竞争, 解决了活锁问题")]),a._v(" ;")],1),a._v(" "),t("li",[a._v("在仅有一个Leader进行Value提交的情况下, "),t("font",{attrs:{color:"ff5500"}},[a._v("Prepare阶段就可以跳过")]),a._v(" , 两阶段变为一阶段, "),t("font",{attrs:{color:"ff5500"}},[a._v("提高效率")])],1)])],1)]),a._v(" "),t("ul",[t("li",[a._v("Leader选举: leader的确定也是一次决议的形成, 可以执行一次Basic Paxos选举leader")]),a._v(" "),t("li",[a._v("改变prepare作用范围: leader只需执行一次prepare, 后续只需要执行accept")])]),a._v(" "),t("h3",{attrs:{id:"zab"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zab"}},[a._v("#")]),a._v(" ZAB")]),a._v(" "),t("p",[a._v("专门为zookeeper设计的一种 (支持奔溃恢复的) 原子广播协议 "),t("a",{attrs:{href:"https://houbb.github.io/2018/10/30/zab",target:"_blank",rel:"noopener noreferrer"}},[a._v("参考博客-ZAB"),t("OutboundLink")],1)]),a._v(" "),t("h4",{attrs:{id:"请求提交过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请求提交过程"}},[a._v("#")]),a._v(" 请求提交过程")]),a._v(" "),t("ol",[t("li",[a._v("客户端向leader发起写请求")]),a._v(" "),t("li",[a._v("leader发起事务提案, 广播给所有follower")]),a._v(" "),t("li",[a._v("follower写入事务日志, 反馈ack")]),a._v(" "),t("li",[a._v("leader收到多数ack, 视为已提交, 回复客户端")]),a._v(" "),t("li",[a._v("发起commit消息, 广播给所有follower, follower收到后进行真正提交")])]),a._v(" "),t("h4",{attrs:{id:"过程保证-奔溃恢复要求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#过程保证-奔溃恢复要求"}},[a._v("#")]),a._v(" 过程保证 / 奔溃恢复要求")]),a._v(" "),t("ol",[t("li",[a._v("leader已提交的事务, 必须最终在所有的follower提交\n"),t("ul",[t("li",[a._v("leader已提交事务, 说明大多数follower有事务日志, 新leader对未提交事务进行大多数投票")])])]),a._v(" "),t("li",[a._v("丢弃被leader提出, 但没有被提交的事务\n"),t("ul",[t("li",[a._v("事务id中的高32位代表epoch纪元, epoch是递增的, 旧leader会丢弃未被提交的事务")])])])]),a._v(" "),t("h4",{attrs:{id:"崩溃恢复模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#崩溃恢复模式"}},[a._v("#")]),a._v(" 崩溃恢复模式")]),a._v(" "),t("ol",[t("li",[a._v("集群启动过程中, 或者Leader服务器异常, 网络中断, 会进入崩溃恢复模式 (此时服务不可用) ;")]),a._v(" "),t("li",[a._v("进入崩溃恢复模式后, 集群选举产生新的leader;\n"),t("ol",[t("li",[a._v("选举条件: 新leader不能包含未提交的事务提案")]),a._v(" "),t("li",[a._v("新leader节点中含有最大的事务id")])])]),a._v(" "),t("li",[a._v("leader与follower进行数据同步")]),a._v(" "),t("li",[a._v("过半的节点完成数据同步之后, 退出崩溃恢复模式, 进入消息广播模式;")]),a._v(" "),t("li",[a._v("此外, 新的节点加入集群, 该节点自动进入恢复模式, 完成数据同步后再提供服务")])]),a._v(" "),t("h3",{attrs:{id:"raft"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#raft"}},[a._v("#")]),a._v(" Raft")]),a._v(" "),t("p",[a._v("Raft是一种用于替代"),t("a",{attrs:{href:"https://zh.wikipedia.org/wiki/Paxos",target:"_blank",rel:"noopener noreferrer"}},[a._v("Paxos"),t("OutboundLink")],1),a._v("的"),t("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%85%B1%E8%AD%98%E6%A9%9F%E5%88%B6",target:"_blank",rel:"noopener noreferrer"}},[a._v("共识"),t("OutboundLink")],1),a._v("算法。")]),a._v(" "),t("p",[a._v('名字来源于"Reliable, Replicated, Redundant, And Fault-Tolerant" (可靠、可复制、可冗余、可容错) 的缩写')]),a._v(" "),t("ul",[t("li",[a._v("比起Paxos, 算法本身能被更好地理解, 安全性更高, 提供一些额外的特性")]),a._v(" "),t("li",[a._v("在分布式系统之间部署有限状态机, 并提供通用方法, 以此来确保任意节点在某种状态转换上保持一致")]),a._v(" "),t("li",[a._v("集群内的节点都对选举出的领袖采取信任")])]),a._v(" "),t("p",[a._v("可视化演示: http://thesecretlivesofdata.com/raft/")]),a._v(" "),t("h4",{attrs:{id:"算法实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法实现"}},[a._v("#")]),a._v(" 算法实现")]),a._v(" "),t("p",[a._v("Raft集群中有三种身份, 节点有机会在这些身份之间切换:")]),a._v(" "),t("ol",[t("li",[a._v("leader 领袖")]),a._v(" "),t("li",[a._v("follower 追随者")]),a._v(" "),t("li",[a._v("candidate 候选人")]),a._v(" "),t("li",[a._v("正常情况只会有一个leader, 其他都是follower")]),a._v(" "),t("li",[a._v("leader负责所有外部请求, 如一请求不是leader收到, 会被传导给leader")]),a._v(" "),t("li",[a._v("leader发送心跳, 让follower知道leader状态")]),a._v(" "),t("li",[a._v("follower设计超时机制, 超过一定时间没有收到心跳, 就会进入选举状态")])]),a._v(" "),t("p",[a._v("Raft将问题拆成数个子问题分开解决")]),a._v(" "),t("ol",[t("li",[a._v("领袖选举 Leader Election : 如何选举leader")]),a._v(" "),t("li",[a._v("记录复写 Log Replication : 如何保证所有节点的数据一致性")]),a._v(" "),t("li",[a._v("安全性 Safety")])]),a._v(" "),t("h4",{attrs:{id:"领袖选举-leader-election"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#领袖选举-leader-election"}},[a._v("#")]),a._v(" 领袖选举 Leader Election")]),a._v(" "),t("p",[a._v("概述: 简单版本")]),a._v(" "),t("ol",[t("li",[a._v("follower心跳超时则升级为candidate, 向其他节点发送拉票请求")]),a._v(" "),t("li",[a._v("其他节点只要收到请求就同意投票, 过半节点同意, candidate直接当选新leader")])]),a._v(" "),t("p",[a._v("细节:")]),a._v(" "),t("ol",[t("li",[t("strong",[a._v("任期term")]),a._v(":")])]),a._v(" "),t("ul",[t("li",[a._v("每次有candidate诞生都会开启新一轮任期选举term election")]),a._v(" "),t("li",[a._v("candidate会先给自己投一票")]),a._v(" "),t("li",[a._v("同个任期选举中一个节点只能投1票, 往往投给该任期的首个拉票请求")]),a._v(" "),t("li",[a._v("候选人收到其他候选人的拉票, 拉票任期不小于自己的任期, 自己会放弃竞选, 并反给对方投票")]),a._v(" "),t("li",[a._v("如果超时后还未选出新领袖, 此任期终止, 开始新任期")])]),a._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[a._v("election timeout: follower多久升级为candidate (区间内的随机值)\n"),t("ol",[t("li",[a._v("只要收到拉票 / 心跳, 都会刷新这个超时(自旋)")])])]),a._v(" "),t("li",[a._v("任期选举冷却: 本轮任期选举中, 多个候选者平票, 这些候选者需要经过这个自旋后才能继续下一轮任期选举")]),a._v(" "),t("li",[a._v("Raft每个服务器的超时期限是随机的, 降低同时竞选的概率")])]),a._v(" "),t("h4",{attrs:{id:"记录复写-log-replication"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#记录复写-log-replication"}},[a._v("#")]),a._v(" 记录复写 Log Replication")]),a._v(" "),t("p",[a._v("更新数据的责任在leader上")]),a._v(" "),t("p",[a._v("简要流程:")]),a._v(" "),t("ol",[t("li",[a._v("leader接收到数据指令, 并做记录, 然后向所有节点发送信息")]),a._v(" "),t("li",[a._v("节点收到后也将数据做记录, 并返回确认")]),a._v(" "),t("li",[a._v("leader收到过半确认后, 才真正将数据修改, 给客户端响应操作成功")]),a._v(" "),t("li",[a._v("leader向所有节点发送确认修改信息")])]),a._v(" "),t("p",[a._v("细节:")]),a._v(" "),t("ol",[t("li",[a._v("其实这些信息是随着心跳一起发送的")])]),a._v(" "),t("h4",{attrs:{id:"分区容错性-partition"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分区容错性-partition"}},[a._v("#")]),a._v(" 分区容错性 partition")]),a._v(" "),t("p",[a._v("如果出现了网络分区问题, 可能会形成多个leader集群:")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("此假设情境下, 旧leader(D)和新leader(B)可以共存, 但新leader的term更高\n\t\tA\nB(L)\t\t\tC\n================== 网络中断\n \tD(L)\tE\n此时, 如果B集群收到请求, 如果AC正常, 是可以正常使用的(收到了足够多的返回确认)\n如果D集群收到请求, 因为没有足够的节点返回确认信息, 所以是不可用的\n### 至此避免了脑裂问题\n其次, 当网络分区问题修复后, 就会以term更高的作为leader, 并对数据进行同步\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br")])]),t("h3",{attrs:{id:"gossip协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gossip协议"}},[a._v("#")]),a._v(" Gossip协议")]),a._v(" "),t("p",[a._v("一个节点想要分享一些信息给网络中的其他的一些节点。于是, 它"),t("strong",[a._v("周期性")]),a._v("的"),t("strong",[a._v("随机")]),a._v("选择一些节点, 并把信息传递给这些节点。这些收到信息的节点接下来会做同样的事情, 即把这些信息传递给其他一些随机选择的节点")]),a._v(" "),t("ul",[t("li",[a._v("无leader")]),a._v(" "),t("li",[a._v("不支持拜占庭问题")])]),a._v(" "),t("p",[t("a",{attrs:{href:"https://tech.meituan.com/2017/04/21/mt-leaf.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("美团分布式id leaf"),t("OutboundLink")],1)]),a._v(" "),t("h2",{attrs:{id:"akf拆分原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#akf拆分原则"}},[a._v("#")]),a._v(" AKF拆分原则")]),a._v(" "),t("ul",[t("li",[a._v("x轴:全量镜像,读写分离")]),a._v(" "),t("li",[a._v("y轴:根据业务/功能拆分,数据分开存储")]),a._v(" "),t("li",[a._v("z轴:基于规则拆分/逻辑拆分")])])])}),[],!1,null,null,null);e.default=v.exports}}]);