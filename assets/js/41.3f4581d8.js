(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{395:function(s,t,a){"use strict";a.r(t);var e=a(45),r=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"redis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[s._v("#")]),s._v(" redis")]),s._v(" "),a("blockquote",[a("p",[s._v("目录结构参考 "),a("a",{attrs:{href:"https://github.com/7-sevens/Developer-Books/tree/master/Redis",target:"_blank",rel:"noopener noreferrer"}},[s._v("Redis开发与运维.pdf"),a("OutboundLink")],1)]),s._v(" "),a("p",[a("RouterLink",{attrs:{to:"/point/04cache/redis-structure/"}},[s._v("redis多数据底层源码参考")]),s._v(" 🎈 "),a("RouterLink",{attrs:{to:"/point/04cache/redis-config-file/"}},[s._v("redis配置文件")])],1)]),s._v(" "),a("h2",{attrs:{id:"_01-简单概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_01-简单概述"}},[s._v("#")]),s._v(" 01. 简单概述")]),s._v(" "),a("p",[s._v("概述: 一种基于键值对的NoSQL数据库, 支持如下特性: 多数据类型, 高读写性能, 支持快照和日志的持久化, 还有键过期, 发布订阅, 事务, Lua脚本等")]),s._v(" "),a("p",[s._v("全称: Remote Dictionary Server")]),s._v(" "),a("h4",{attrs:{id:"redis特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis特性"}},[s._v("#")]),s._v(" redis特性")]),s._v(" "),a("ul",[a("li",[s._v("内存数据库, 速度快: 单机10万/秒")]),s._v(" "),a("li",[s._v("单线程架构: 避免了高并发多线程问题 (6.x引入多线程IO, worker还是单线程的)")]),s._v(" "),a("li",[s._v("多数据类型: 字符串, 列表, 哈希, 集合, 有序集合; 字符串还能扩展为位图, 地理信息定位等")]),s._v(" "),a("li",[s._v("键过期, 发布订阅, Lua脚本, 简单事务, Pipeline等功能")]),s._v(" "),a("li",[s._v("持久化: RDB 和 AOF (4.x可混合使用)")]),s._v(" "),a("li",[s._v("主从复制(Redis副本), 高可用(Sentinel), 分布式集群(Cluster)")])]),s._v(" "),a("h4",{attrs:{id:"redis-vs-memcached"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-vs-memcached"}},[s._v("#")]),s._v(" redis vs memcached")]),s._v(" "),a("ul",[a("li",[s._v("memcached中value只有一种类型string, redis多数据类型")]),s._v(" "),a("li",[s._v("内存管理机制不同")]),s._v(" "),a("li",[s._v("redis使用单线程worker, memcached可以多线程")]),s._v(" "),a("li",[s._v("memcached没有原生支持分布式架构")])]),s._v(" "),a("h4",{attrs:{id:"应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[s._v("#")]),s._v(" 应用场景")]),s._v(" "),a("ol",[a("li",[s._v("缓存: 通过合理的缓存设计减少数据库压力")]),s._v(" "),a("li",[s._v("排行榜: 通过zset构建各种排行榜系统")]),s._v(" "),a("li",[s._v("计数器: 对一些视频网站的浏览次数进行累计")]),s._v(" "),a("li",[s._v("社交网络: 应对社交网站的高访问量: 点赞数, 推送, 共同好友/爱好(交集)")]),s._v(" "),a("li",[s._v("消息队列: 满足一般的消息队列功能")])]),s._v(" "),a("p",[s._v("建议: 根据数据规模和数据冷热等特性决定是否使用redis")]),s._v(" "),a("h2",{attrs:{id:"_02-redis-api的理解和使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_02-redis-api的理解和使用"}},[s._v("#")]),s._v(" 02. redis API的理解和使用")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("keys * "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#查看所有键")]),s._v("\ndbsize "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#查看键总数")]),s._v("\nexist key\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#查询键是否存在")]),s._v("\ndel key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#删除键")]),s._v("\nexpire key seconds\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#给键设置过期时间")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("type")]),s._v(" key\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#键的数据结构类型")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h3",{attrs:{id:"数据结构和内部编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和内部编码"}},[s._v("#")]),s._v(" 数据结构和内部编码")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("type")]),s._v(" key\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#返回的数据结构类型有这些(string, hash, list, set, zset)")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#但这些只是堆外的数据结果, 都有自己底层的内部编码实现(而且是多种实现)")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#redis会在合适的场景选择合适的内部编码")]),s._v("\nobject encoding key\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#查看内部编码实现")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#例如")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#list数据结果包含了linkedlist和ziplist两种内部编码")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[a("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5waHAuY24vdXBsb2FkL2FydGljbGUvMDAwLzA1NC8wMjUvNDFhYWFkZWNhOThlMTQ2NDA5NDhiZGJhOGJjNGJhMTItMS5wbmc?x-oss-process=image/format,png",alt:"内部编码"}})]),s._v(" "),a("h4",{attrs:{id:"单线程架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单线程架构"}},[s._v("#")]),s._v(" 单线程架构")]),s._v(" "),a("p",[s._v("概述: 命令到达redis会进入一个队列中, 然后逐个执行, 不存在多个命令被同时执行的情况")]),s._v(" "),a("ol",[a("li",[s._v("单线程模型")]),s._v(" "),a("li",[a("strong",[s._v("为什么单线程模型还能那么快")]),s._v(" "),a("ol",[a("li",[s._v("纯内存访问")]),s._v(" "),a("li",[s._v("非阻塞IO, 使用epoll的IO多路复用技术处理tcp连接/关闭, buffer读写")]),s._v(" "),a("li",[s._v("单线程避免了线程切换, 高并发下锁问题")]),s._v(" "),a("li",[s._v("redis6.0开始使用多线程io threads")])])]),s._v(" "),a("li",[a("strong",[s._v("问题")]),s._v(": 如果某个命令执行时间过长, 会造成其他命令阻塞")])]),s._v(" "),a("h4",{attrs:{id:"io-threads"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#io-threads"}},[s._v("#")]),s._v(" IO threads")]),s._v(" "),a("div",{staticClass:"language-sh line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#旧redis处理两条指令: 指令1,指令2")]),s._v("\n读取IO1  计算1\t   写IO1   读取IO2   计算2   写IO2\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#IO THREADS\t6.x 以后提供")]),s._v("\n\t\t计算1\t\t计算2\t\t\t\t\tworker\n读取IO1\t\t\t写IO1\t\t\t\tio thread1\n读取IO2\t\t\t\t\t写IO2\t\tio thread2\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("不能保证先处理C1还是C2, 但如果是同一个客户端, 同一个IO中的读取顺序是可以保证的")]),s._v(" "),a("h3",{attrs:{id:"字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串"}},[s._v("#")]),s._v(" 字符串")]),s._v(" "),a("p",[s._v("概述: 最基础的数据结构;")]),s._v(" "),a("ul",[a("li",[s._v("key都是字符串类型, 其他的几种数据结构都是在字符串基础上构建的")]),s._v(" "),a("li",[s._v("可以存储数值, 二进制, 但是最大不能超过512MB")])]),s._v(" "),a("h4",{attrs:{id:"string基本操作api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string基本操作api"}},[s._v("#")]),s._v(" string基本操作API")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#set and get")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" key value "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("ex seconds"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("px millisenconds"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("nx"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v("xx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#设置kv, 秒级/毫秒级超时时间, ")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#键必须不存在NX(锁) / 必须存在XX(更新)")]),s._v("\nget key\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#查询")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#计数")]),s._v("\nincr key\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#对值做自增操作")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#不常用命令")]),s._v("\nappend key value\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#追加值")]),s._v("\nstrlen key \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#字符串长度")]),s._v("\ngetset key value "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#设置并返回原值")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("h4",{attrs:{id:"string内部编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string内部编码"}},[s._v("#")]),s._v(" string内部编码")]),s._v(" "),a("p",[s._v("字符串类型的内部编码:")]),s._v(" "),a("ol",[a("li",[s._v("int: 8个字节的长整形")]),s._v(" "),a("li",[s._v("embstr: 小于等于39个字节的字符串")]),s._v(" "),a("li",[s._v("raw: 大于39个字节的字符串")])]),s._v(" "),a("h4",{attrs:{id:"string典型使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string典型使用场景"}},[s._v("#")]),s._v(" string典型使用场景")]),s._v(" "),a("h5",{attrs:{id:"_1-缓存功能-加速读写-降低后端压力"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-缓存功能-加速读写-降低后端压力"}},[s._v("#")]),s._v(" 1. 缓存功能: 加速读写, 降低后端压力")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5waHAuY24vdXBsb2FkL2FydGljbGUvMDAwLzA1NC8wMjUvNzJmMTQ3ZDAwZDIwNzUxZGFkNjk4OTg5ZTY2NmNiYzgtNS5wbmc?x-oss-process=image/format,png",alt:"缓存"}})]),s._v(" "),a("h5",{attrs:{id:"_2-计数-将redis作为基础计数组件-再异步落到其他数据源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-计数-将redis作为基础计数组件-再异步落到其他数据源"}},[s._v("#")]),s._v(" 2. 计数: 将redis作为基础计数组件, 再异步落到其他数据源")]),s._v(" "),a("p",[s._v("比如说秒杀, 将库存数量缓存到redis, 被秒杀到0后结束秒杀;")]),s._v(" "),a("p",[s._v("点赞, 评论数")]),s._v(" "),a("h5",{attrs:{id:"_3-共享session"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-共享session"}},[s._v("#")]),s._v(" 3. 共享session")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5waHAuY24vdXBsb2FkL2FydGljbGUvMDAwLzA1NC8wMjUvNzJmMTQ3ZDAwZDIwNzUxZGFkNjk4OTg5ZTY2NmNiYzgtNi5wbmc?x-oss-process=image/format,png",alt:"session"}})]),s._v(" "),a("h5",{attrs:{id:"_4-限流-通过incr和超时时间做"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-限流-通过incr和超时时间做"}},[s._v("#")]),s._v(" 4. 限流: 通过incr和超时时间做")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" key "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" ex "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("60")]),s._v(" nx "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#如果没有就设置为1")]),s._v("\nincr key\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#判断递增后的结果是否超限")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#超时时间还可以做限时优惠活动, 手机验证码...")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("h4",{attrs:{id:"合理设置键名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合理设置键名"}},[s._v("#")]),s._v(" 合理设置键名")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("推荐使用如下规则, 保证足够区分度下控制key的长度越小越好\n业务名/数据库名:对象名:id:[属性] 比如user:123:password\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h3",{attrs:{id:"hash-哈希"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-哈希"}},[s._v("#")]),s._v(" hash 哈希")]),s._v(" "),a("p",[s._v("哈希, 字典, 关联数组")]),s._v(" "),a("h4",{attrs:{id:"hash-基本操作api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-基本操作api"}},[s._v("#")]),s._v(" hash 基本操作API")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("hset key field value\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#增加")]),s._v("\nhget key field\t\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#查询")]),s._v("\nhdel key field\t\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#删除")]),s._v("\nhlen key\nhexist key field\nhkeys key\nhvals key\nhgetall key\t\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#获取所有kv对")]),s._v("\nhincrby key field\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#自增")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("注意: hgetall等命令如果元素个数较多可能阻塞redis")]),s._v(" "),a("h4",{attrs:{id:"hash内部编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash内部编码"}},[s._v("#")]),s._v(" hash内部编码")]),s._v(" "),a("p",[s._v("有两种:")]),s._v(" "),a("ol",[a("li",[s._v("ziplist(压缩列表):\n"),a("ul",[a("li",[s._v("当元素个数小于hash-max-ziplist-entries(512个)")]),s._v(" "),a("li",[s._v("每个元素的值都小于hash-max-ziplist-value(64字节)")]),s._v(" "),a("li",[s._v("ziplist使用更加紧凑的内存结构, 以节省空间")])])]),s._v(" "),a("li",[s._v("hashtable(哈希表):\n"),a("ul",[a("li",[s._v("超出ziplist的条件时会使用, 因为ziplist的读写效率在此时下降")])])])]),s._v(" "),a("h4",{attrs:{id:"hash使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash使用场景"}},[s._v("#")]),s._v(" hash使用场景")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("例如: 用户表, 根据用户id来保存对应用户的信息;")])]),s._v(" "),a("li",[a("p",[s._v("聚集数据(多个地方的数据汇总,频繁访问,但是较少修改), 商品/用户的详情页")])]),s._v(" "),a("li",[a("p",[s._v("避免redis的哈希表膨胀")])])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5waHAuY24vdXBsb2FkL2FydGljbGUvMDAwLzA1NC8wMjUvM2ZlODYwNWQxMGQ4ZTc0MmIwYWUxYjU2YzExZWYzY2ItOS5wbmc?x-oss-process=image/format,png",alt:"hash使用"}})]),s._v(" "),a("h4",{attrs:{id:"使用hash和使用格式化string的优劣"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用hash和使用格式化string的优劣"}},[s._v("#")]),s._v(" 使用hash和使用格式化string的优劣")]),s._v(" "),a("ul",[a("li",[s._v("哈希类型: 简单直观, 但是如果内部编码转换为hashtable, 会消耗较多内存")]),s._v(" "),a("li",[s._v("序列化字符串类型: 简化编程, 提高内存利用率, 但是每次都需要全量读取, 还需要额外序列化开销")])]),s._v(" "),a("h3",{attrs:{id:"list-列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list-列表"}},[s._v("#")]),s._v(" list 列表")]),s._v(" "),a("p",[s._v("存储有序元素(string), 是一种灵活的数据结构, 可以充当栈和队列, 阻塞队列")]),s._v(" "),a("ul",[a("li",[s._v("列表中元素是有序的, 可以通过索引下标获取某个元素或范围")]),s._v(" "),a("li",[s._v("元素可重复")])]),s._v(" "),a("h4",{attrs:{id:"list基本操作api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list基本操作api"}},[s._v("#")]),s._v(" list基本操作api")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("rpush lpush linsert\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 添加")]),s._v("\nlrange lindex llen\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 查询")]),s._v("\nrpop lpop lrem ltrim\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 删除")]),s._v("\nlset\t\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 修改")]),s._v("\nblpop brpop\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 阻塞操作")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h4",{attrs:{id:"list内部编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list内部编码"}},[s._v("#")]),s._v(" list内部编码")]),s._v(" "),a("ol",[a("li",[s._v("ziplist: 压缩列表 (压缩+偏移量, 大大减少每个key存储空间, 但无法存储大量key)\n"),a("ul",[a("li",[s._v("元素个数小于 list-max-ziplist-entries (默认512个)")]),s._v(" "),a("li",[s._v("每个元素值小于 list-max-ziplist-value (默认64字节)")])])]),s._v(" "),a("li",[s._v("linkedlist: 链表")]),s._v(" "),a("li",[s._v("quicklist: Redis3.2开始提供的内部编码, 可简单的认为以ziplist作为节点的链表, 是对上述数据结构的优化 "),a("a",{attrs:{href:"https://matt.sh/redis-quicklist",target:"_blank",rel:"noopener noreferrer"}},[s._v("quicklist原理&优势"),a("OutboundLink")],1)])]),s._v(" "),a("h4",{attrs:{id:"list使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list使用场景"}},[s._v("#")]),s._v(" list使用场景")]),s._v(" "),a("ol",[a("li",[s._v("消息队列: lpush+brpop生产消费者模型实现阻塞队列")]),s._v(" "),a("li",[s._v("文章列表, 评论列表: 列表不但有序, 还支持按索引范围查找")]),s._v(" "),a("li",[s._v("替代java一些容器 - JVM(服务)无状态 - 数据可靠")])]),s._v(" "),a("ul",[a("li",[s._v("lpush+lpop=Stack (栈)")]),s._v(" "),a("li",[s._v("lpush+rpop=Queue (队列)")]),s._v(" "),a("li",[s._v("lpsh+ltrim=Capped Collection (有限集合)")]),s._v(" "),a("li",[s._v("lpush+brpop=Message Queue (消息队列)")])]),s._v(" "),a("h3",{attrs:{id:"set-集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set-集合"}},[s._v("#")]),s._v(" set 集合")]),s._v(" "),a("p",[s._v("集合中不允许有重复元素, 并且集合中的元素是无序的")]),s._v(" "),a("h4",{attrs:{id:"set基本操作api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set基本操作api"}},[s._v("#")]),s._v(" set基本操作api")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 增删改查")]),s._v("\nsadd \nsrem \nscard \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#元素个数")]),s._v("\nsismember\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#contains")]),s._v("\nsrandmember\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#随机元素")]),s._v("\nspop\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#随机弹出")]),s._v("\nSADD k1 ooxx xxoo oxox xoxo oxxo xoox ooxx\nSMEMBERS k1 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 随机返回大小为2的set")]),s._v("\nSRANDMEMBER k1 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 随机返回大小为2的set, 如果超出set大小不补全")]),s._v("\nSRANDMEMBER k1 -8\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 随机返回大小为8的set, 如果超出set大小补全")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 集合操作")]),s._v("\nsinterstore "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#将交集的结果保存")]),s._v("\nSUNION k1 k2\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 并集")]),s._v("\nSINTER k1 k2\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 交集")]),s._v("\nSDIFF k1 k2\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 差集有方向")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 场景: 共同好友(游戏...), 好友/游戏/商品推荐")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br")])]),a("h4",{attrs:{id:"set内部编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set内部编码"}},[s._v("#")]),s._v(" set内部编码")]),s._v(" "),a("ol",[a("li",[s._v("intset: 整数集合\n"),a("ul",[a("li",[s._v("元素都是整数且个数小于 set-max-intset-entries (默认512个)")])])]),s._v(" "),a("li",[s._v("hashtable")])]),s._v(" "),a("h4",{attrs:{id:"set使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set使用场景"}},[s._v("#")]),s._v(" set使用场景")]),s._v(" "),a("ol",[a("li",[s._v("set的典型使用场景是标签(tag), 可以给用户贴标签, 进行分类/分析")]),s._v(" "),a("li",[s._v("共同好友(游戏...), 好友/游戏/商品推荐")]),s._v(" "),a("li",[s._v("抽奖, 验证码, 扑克牌游戏")]),s._v(" "),a("li",[s._v("利用唯一性, 可以统计访问网站的所有独立 IP")])]),s._v(" "),a("h3",{attrs:{id:"zset排序集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zset排序集合"}},[s._v("#")]),s._v(" zset排序集合")]),s._v(" "),a("p",[s._v("不能有重复member, 但是元素可以根据score进行排序")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5waHAuY24vdXBsb2FkL2FydGljbGUvMDAwLzA1NC8wMjUvMmUyZTU2MGFjMzM0MjIxNDAwNmU1NzA3MGY3MWQzY2MtMTYucG5n?x-oss-process=image/format,png",alt:"zset"}})]),s._v(" "),a("h4",{attrs:{id:"zset基本操作api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zset基本操作api"}},[s._v("#")]),s._v(" zset基本操作api")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#增删改查")]),s._v("\nzadd\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#增加操作复杂度提高至logN")]),s._v("\nzcard\nzscore\nzrank\tzrevrank\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#排名")]),s._v("\nzrange\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#返回范围内的member")]),s._v("\nzrangebyscore\nZADD k1 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("22.5")]),s._v(" apple "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("11")]),s._v(" orange "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("33")]),s._v(" banana\t\nZRANGE k1 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" -1 WITHSCORES\nZREVRANGE k1 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 逆向, 注意正负索引")]),s._v("\nZRANGEBYSCORE k1 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("33")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 分数区间")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#集合间操作, 参数较多, 设计分数的计算, 权重...")]),s._v("\nzinterstore \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("h4",{attrs:{id:"zset内部编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zset内部编码"}},[s._v("#")]),s._v(" zset内部编码")]),s._v(" "),a("ol",[a("li",[s._v("ziplist: 压缩列表\n"),a("ul",[a("li",[s._v("当有序集合元素小于 zset-max-ziplist-entries (默认128个)")]),s._v(" "),a("li",[s._v("每个元素值小于 zset-max-ziplist-value (64字节)")])])]),s._v(" "),a("li",[s._v("skiplist: 跳跃表\n"),a("ul",[a("li",[s._v("链表, 每个节点拥有随机的层级, head头结点是满层的, 查询元素时从头开始向右下遍历")]),s._v(" "),a("li",[s._v("插入元素的时候随机造层, 上层元素需要找到周围层的指针地址, 进行高层的指针修改")])])])]),s._v(" "),a("h4",{attrs:{id:"zset使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zset使用场景"}},[s._v("#")]),s._v(" zset使用场景")]),s._v(" "),a("ol",[a("li",[s._v("zset典型使用场景是排行榜系统")]),s._v(" "),a("li",[s._v("做权重队列, 重要任务先执行")])]),s._v(" "),a("h3",{attrs:{id:"key管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#key管理"}},[s._v("#")]),s._v(" key管理")]),s._v(" "),a("h4",{attrs:{id:"单key管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单key管理"}},[s._v("#")]),s._v(" 单key管理")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("rename")]),s._v(" key newkey\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#key重命名")]),s._v("\nrandomkey\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#随机返回一个key")]),s._v("\nexpire key seconds\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#key过期时间, 注意字符串类型设置值会去掉过期时间")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("迁移键: 例如把部分数据从生产redis迁移到测试redis")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("move key db\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#redis内部数据库移动数据 (没啥用)")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# dump+restore可以实现在不同的Redis实例之间进行数据迁移")]),s._v("\ndump key\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#在源Redis上, dump命令会将键值序列化, 格式采用的是RDB格式")]),s._v("\nrestore key ttl value\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#在目标Redis上复原")]),s._v("\nmigrate\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#本质就是dump, restore, del三个命令进行组合, 不过是原子性的")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("遍历键:")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("key pattern\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#支持格式匹配, 避免遍历大量key, 导致redis阻塞")]),s._v("\nscan\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#渐进式遍历, 游标, (分页?), 可能遍历到的不是当前快照")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h3",{attrs:{id:"数据库管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库管理"}},[s._v("#")]),s._v(" 数据库管理")]),s._v(" "),a("p",[s._v("略")]),s._v(" "),a("h2",{attrs:{id:"_03-其他功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_03-其他功能"}},[s._v("#")]),s._v(" 03. 其他功能")]),s._v(" "),a("p",[s._v("慢查询分析, Redis Shell, Pipeline(管道/流水线), 事务与Lua, Bitmaps, 发布订阅, HyperLogLog, GEO")]),s._v(" "),a("h4",{attrs:{id:"慢查询分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#慢查询分析"}},[s._v("#")]),s._v(" 慢查询分析")]),s._v(" "),a("p",[s._v("概述: 系统在命令执行前后计算执行时间, 将超过阈值的命令信息记录下来")]),s._v(" "),a("h4",{attrs:{id:"redis-shell"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-shell"}},[s._v("#")]),s._v(" redis-shell")]),s._v(" "),a("p",[s._v("执行多次, 每隔几秒执行一次, 从标准输入读取数据, 集群, 鉴权, 从节点, rdb, 管道, bigkeys, eval执行Lua脚本, 检测网络延迟, stat统计信息, raw返回原始格式")]),s._v(" "),a("h4",{attrs:{id:"redis-sever"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-sever"}},[s._v("#")]),s._v(" redis-sever")]),s._v(" "),a("p",[s._v("test-memory内存测试, benchmark性能测试")]),s._v(" "),a("h3",{attrs:{id:"pipeline"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pipeline"}},[s._v("#")]),s._v(" Pipeline")]),s._v(" "),a("p",[s._v("redis的瓶颈之一在于网络往返延迟, pipeline将一组redis命令组装, 一次执行n条命令, 减少网络往返次数从而降低延迟; 该功能一般通过客户端软件实现")]),s._v(" "),a("h3",{attrs:{id:"事务与lua"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务与lua"}},[s._v("#")]),s._v(" 事务与Lua")]),s._v(" "),a("p",[s._v("redis提供简单的事务, 可以使用WATH进行CAS监控让指令不执行, 但不支持回滚")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("watch")]),s._v(" key\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#监控某个key未被其他客户端修改, 才会正常执行事务")]),s._v("\nmulti\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#开启事务")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v(".\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#事务内容")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("exec")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#提交事务")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("h4",{attrs:{id:"lua简单功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lua简单功能"}},[s._v("#")]),s._v(" Lua简单功能")]),s._v(" "),a("div",{staticClass:"language-lua line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-lua"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("local")]),s._v(" strings val "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"world"')]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("--定义局部变量, 字符串")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("print")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("val"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("local")]),s._v(" tables array "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"redis"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"jedis"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("88.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("--数组")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- for, while循环; if else判断; hash类型tables")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 函数定义")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h4",{attrs:{id:"redis使用lua"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis使用lua"}},[s._v("#")]),s._v(" redis使用lua")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("eval")]),s._v("\nevalsha\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#可复用脚本")]),s._v("\nredis.call\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#Lua可以调用redis.call函数实现对redis的访问")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("h3",{attrs:{id:"bitmaps"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bitmaps"}},[s._v("#")]),s._v(" Bitmaps")]),s._v(" "),a("p",[s._v("实现了对位的操作, 其本身不是一种数据结构, 实际上就是字符串")]),s._v(" "),a("h4",{attrs:{id:"bitmaps应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bitmaps应用"}},[s._v("#")]),s._v(" Bitmaps应用")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#将每个独立用户是否访问过网站存放在Bitmaps中")]),s._v("\nsetbit unique:users:2016-04-05 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#这天用户0访问了网站")]),s._v("\nsetbit unique:users:2016-04-05 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#这天用户5访问了网站...")]),s._v("\ngetbit unique:users:2016-04-05 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#查询用户8这天是否访问过网站")]),s._v("\nbitcount "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("start"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("end"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#查询指定范围1的个数")]),s._v("\nbitop "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("op")]),s._v(" destkey key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("."),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#二进制操作,与或非异或(and or not xor)")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#场景: 统计10万用户任意时间窗口的登录情况 ")]),s._v("\nSETBIT username "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 记录用户第10天的登录")]),s._v("\nBITCOUNT username\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 统计登录数")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#场景: 活动前统计活跃用户, 僵尸用户, 权限")]),s._v("\nSETBIT "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("20200101")]),s._v(" 用户id "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\nBITCOUNT "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("20200101")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 统计当天活跃用户")]),s._v("\nBITOP or result "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("20200101")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("20200102")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#做或运算统计活跃用户, 波形")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("h4",{attrs:{id:"hyperloglog-发布订阅-geo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hyperloglog-发布订阅-geo"}},[s._v("#")]),s._v(" HyperLogLog, 发布订阅, GEO")]),s._v(" "),a("p",[s._v("略")]),s._v(" "),a("h2",{attrs:{id:"_04-客户端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_04-客户端"}},[s._v("#")]),s._v(" 04. 客户端")]),s._v(" "),a("p",[s._v("redis制定RESP通讯协议, 简单高效, 容易识别")]),s._v(" "),a("h4",{attrs:{id:"jedis使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jedis使用"}},[s._v("#")]),s._v(" Jedis使用")]),s._v(" "),a("p",[s._v("略")]),s._v(" "),a("h4",{attrs:{id:"jedis连接池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jedis连接池"}},[s._v("#")]),s._v(" Jedis连接池")]),s._v(" "),a("p",[s._v("JedisPool连接池, 可以降低开销, 保护机器资源不被滥用; 难点在于合理规划连接池的参数配置")]),s._v(" "),a("h4",{attrs:{id:"jedis使用管道-lua脚本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jedis使用管道-lua脚本"}},[s._v("#")]),s._v(" Jedis使用管道, Lua脚本")]),s._v(" "),a("p",[s._v("略")]),s._v(" "),a("h3",{attrs:{id:"客户端管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客户端管理"}},[s._v("#")]),s._v(" 客户端管理")]),s._v(" "),a("p",[s._v("客户端信息, 输入缓冲区qbuf/qbuf-free, 输出缓冲区obl/oll/omem, 客户端类型, monitor监控, 客户端配置, 客户端常见异常, 常见问题, 案例分析")]),s._v(" "),a("h2",{attrs:{id:"_05-持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_05-持久化"}},[s._v("#")]),s._v(" 05. 持久化")]),s._v(" "),a("p",[s._v("redis支持RDB和AOF两种持久化机制")]),s._v(" "),a("h3",{attrs:{id:"rdb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[s._v("#")]),s._v(" RDB")]),s._v(" "),a("p",[s._v("把当前进程数据生成快照保存到硬盘, 特点是全量, 按时间点备份, 体积与真实数据相近, 恢复速度较快(不需要cpu计算)")]),s._v(" "),a("h4",{attrs:{id:"触发机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#触发机制"}},[s._v("#")]),s._v(" 触发机制")]),s._v(" "),a("ol",[a("li",[s._v("手动触发: save(阻塞) 和 bgsave(非阻塞)\n"),a("ul",[a("li",[s._v("bgsave: fork出子进程生成RDB")])])]),s._v(" "),a("li",[s._v("自动触发: 使用配置, 从节点复制...")])]),s._v(" "),a("h4",{attrs:{id:"特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[s._v("#")]),s._v(" 特点")]),s._v(" "),a("ul",[a("li",[s._v("紧凑压缩的二进制文件, 适用于备份, 全量复制, 恢复数据速度快")]),s._v(" "),a("li",[s._v("没办法做到实时持久化, 新老版本RDB不兼容")]),s._v(" "),a("li",[s._v("fork后, 内存会被克隆, 要考虑内存膨胀")])]),s._v(" "),a("h3",{attrs:{id:"aof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[s._v("#")]),s._v(" AOF")]),s._v(" "),a("p",[s._v("append only file持久化: 以独立日志的方式记录(行为记录), 趋向于实时性")]),s._v(" "),a("h4",{attrs:{id:"aof流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof流程"}},[s._v("#")]),s._v(" AOF流程")]),s._v(" "),a("p",[s._v("所有写入的命令都追加到aof_buf缓冲区, 根据策略进行同步操作")]),s._v(" "),a("p",[s._v("write: 触发延时写: 将输入写入linux内核缓冲区, 根据操作系统配置同步到磁盘")]),s._v(" "),a("p",[s._v("fsync: 强制硬盘同步: 阻塞写入硬盘后返回")]),s._v(" "),a("h4",{attrs:{id:"rewrite重写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rewrite重写"}},[s._v("#")]),s._v(" rewrite重写")]),s._v(" "),a("p",[s._v("由于AOF日志文件越来越大, rewrite通过删除无效命令, 整合多条命令来减小日志size")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("bgrewriteaof\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#手动触发")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#自动触发则使用配置")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#auto-aof-rewrite-min-size\t\t触发重写最小体积")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#auto-aof-rewrite-percentage\t和上次重写后AOF文件空间比值")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#还有aof_current_size和aof_base_size两个统计信息")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h4",{attrs:{id:"重启加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重启加载"}},[s._v("#")]),s._v(" 重启加载")]),s._v(" "),a("p",[s._v("优先加载AOF文件, 如果AOF不存在, 加载RDB文件, 如果文件存在错误, 启动失败")]),s._v(" "),a("p",[s._v("文件校验-手动修改, 自动忽略")]),s._v(" "),a("h4",{attrs:{id:"问题定位与优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题定位与优化"}},[s._v("#")]),s._v(" 问题定位与优化")]),s._v(" "),a("p",[s._v("fork操作, 子进程, 内存, 硬盘, AOF追加阻塞, 同机器多实例部署时开启AOF重写")]),s._v(" "),a("h4",{attrs:{id:"aof特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof特点"}},[s._v("#")]),s._v(" AOF特点")]),s._v(" "),a("ol",[a("li",[s._v("趋于实时性, 最多丢失两秒数据")]),s._v(" "),a("li",[s._v("日志文件太大, AOF追加阻塞, 恢复数据较慢")])]),s._v(" "),a("h4",{attrs:{id:"持久化推荐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持久化推荐"}},[s._v("#")]),s._v(" 持久化推荐")]),s._v(" "),a("p",[s._v("如果重启redis数据全部丢失? 如果缓存不要求强一致性可以用最快的持久化方案, 或网络异地主从备 (用主从做数据备份)")]),s._v(" "),a("h2",{attrs:{id:"_06-复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_06-复制"}},[s._v("#")]),s._v(" 06. 复制")]),s._v(" "),a("p",[s._v("概述: 为了解决单点问题而把数据复制多个副本部署到其他机器, 满足故障恢复和负载均衡等需求; redis本身提供了复制功能")]),s._v(" "),a("h4",{attrs:{id:"redis主从复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis主从复制"}},[s._v("#")]),s._v(" redis主从复制")]),s._v(" "),a("p",[s._v("redis分主从节点, 单主多从")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("slaveof "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("masterHost"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("masterPort"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#建立复制no one")]),s._v("\nslaveof no one\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#断开复制, 成为主节点\t#切主")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#安全性, 主节点设置密码, 从节点配置密码才能正确连接")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#只读, 为保证数据一致, 从节点必须只读")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#传输延迟, repl-disable-tcp-nodelay参数")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#拓扑: 一主一从, 一主多从, 树状主从")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h3",{attrs:{id:"复制原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复制原理"}},[s._v("#")]),s._v(" 复制原理")]),s._v(" "),a("ol",[a("li",[s._v("保存主节点 ip, port 信息")]),s._v(" "),a("li",[s._v("主从建立socket连接")]),s._v(" "),a("li",[s._v("发送ping命令, 检测socket是否可用")]),s._v(" "),a("li",[s._v("权限验证")]),s._v(" "),a("li",[s._v("同步数据集, 首次连接开始复制, 首次一般是全量复制 sync/psync")]),s._v(" "),a("li",[s._v("后续命令持续复制")])]),s._v(" "),a("h4",{attrs:{id:"psync"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#psync"}},[s._v("#")]),s._v(" psync")]),s._v(" "),a("p",[s._v("redis2.8开始使用psync完成主从同步")]),s._v(" "),a("ol",[a("li",[s._v("复制偏移量")]),s._v(" "),a("li",[s._v("复制积压缓冲区")]),s._v(" "),a("li",[s._v("主节点运行ID")]),s._v(" "),a("li",[s._v("使用 psync 命令完成部分复制和全量复制")])]),s._v(" "),a("h4",{attrs:{id:"全量复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全量复制"}},[s._v("#")]),s._v(" 全量复制")]),s._v(" "),a("ol",[a("li",[s._v("首次复制, 发送psync-1")]),s._v(" "),a("li",[s._v("主节点收到命令并回复+FULLRESYNC响应")]),s._v(" "),a("li",[s._v("从节点接收响应数据")]),s._v(" "),a("li",[s._v("主节点执行bgsave保存RDB")]),s._v(" "),a("li",[s._v("主节点发送RDB文件给从节点, 从节点接收并保存至本地")]),s._v(" "),a("li",[s._v("主节点在传递RDB文件期间依然接收指令, 这些指令将保存在缓冲区 (如果传输时间过长导致缓冲区溢出会复制失败), 从节点接收并加载完毕RDB后, 再把缓冲区内数据发送给从节点")]),s._v(" "),a("li",[s._v("从节点清空自身旧数据")]),s._v(" "),a("li",[s._v("从节点开始加载RDB")]),s._v(" "),a("li",[s._v("从节点加载完RDB后, 查看AOF是否开启, 决定是否执行bgrewriteaof")])]),s._v(" "),a("p",[s._v("总结: 慢")]),s._v(" "),a("h4",{attrs:{id:"部分复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#部分复制"}},[s._v("#")]),s._v(" 部分复制")]),s._v(" "),a("ol",[a("li",[s._v("当主从节点出现网络中断, 超时")]),s._v(" "),a("li",[s._v("主从中断期间, 主节点在缓冲区保存最近一段时间的写命令")]),s._v(" "),a("li",[s._v("主从网络恢复后, 从节点将原来保存的复制偏移量和主节点运行id发送给主节点")]),s._v(" "),a("li",[s._v("逐渐点检查参数, 返回+CONTINUE响应")]),s._v(" "),a("li",[s._v("主节点根据偏移量把复制积压缓冲区里的数据发送给从节点")])]),s._v(" "),a("h4",{attrs:{id:"心跳"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#心跳"}},[s._v("#")]),s._v(" 心跳")]),s._v(" "),a("p",[s._v("主从节点在建立复制后, 它们之间维护长连接并彼此发送心跳")]),s._v(" "),a("ol",[a("li",[s._v("主从互为对方的客户端发送命令")]),s._v(" "),a("li",[s._v("主节点默认10秒对从节点发送ping命令, 检测从节点存活状态")]),s._v(" "),a("li",[s._v("从节点每个1秒发送主节点replconf ack{offset}命令, 上报当前复制偏移量")])]),s._v(" "),a("h4",{attrs:{id:"异步复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步复制"}},[s._v("#")]),s._v(" 异步复制")]),s._v(" "),a("p",[s._v("概述: 主节点不但负责数据读写, 还负责把写命令同步给从节点; 写命令的发送是异步的: 主节点自身处理完毕后直接返回客户端, 并不等待从节点复制完成")]),s._v(" "),a("p",[s._v("正常情况下延迟在1秒以内")]),s._v(" "),a("h3",{attrs:{id:"问题解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题解决"}},[s._v("#")]),s._v(" 问题解决")]),s._v(" "),a("h4",{attrs:{id:"读写分离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#读写分离"}},[s._v("#")]),s._v(" 读写分离")]),s._v(" "),a("ol",[a("li",[s._v("数据延迟: 使用monitor监控主从, 避免复制偏移量过大")]),s._v(" "),a("li",[s._v("读到过期数据:\n"),a("ul",[a("li",[a("strong",[s._v("惰性删除")]),s._v(": 每次读取命令时会检查key是否超时, 如果超时会执行del删除key")]),s._v(" "),a("li",[a("strong",[s._v("定期删除")]),s._v(": redis主节点定时循环采样一定数量的key, 如果过期将执行del")]),s._v(" "),a("li",[s._v("以上两个操作会同步给从节点, 如果从节点还未收到del命令, 存在主从不一致现象, redis3.2解决了该问题")])])]),s._v(" "),a("li",[s._v("从节点故障\n"),a("ul",[a("li",[s._v("需要客户端维护可用从节点列表, 当从节点故障时立刻切换到其他节点")]),s._v(" "),a("li",[s._v("总结: 不推荐主从, 推荐优化主节点, 或者使用Redis Cluster分布式方案")])])])]),s._v(" "),a("h4",{attrs:{id:"主从配置不一致"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从配置不一致"}},[s._v("#")]),s._v(" 主从配置不一致")]),s._v(" "),a("p",[s._v("看配置")]),s._v(" "),a("h4",{attrs:{id:"规避全量复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#规避全量复制"}},[s._v("#")]),s._v(" 规避全量复制")]),s._v(" "),a("h4",{attrs:{id:"规避复制风暴"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#规避复制风暴"}},[s._v("#")]),s._v(" 规避复制风暴")]),s._v(" "),a("p",[s._v("略")]),s._v(" "),a("h2",{attrs:{id:"_07-redis阻塞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_07-redis阻塞"}},[s._v("#")]),s._v(" 07. redis阻塞")]),s._v(" "),a("h4",{attrs:{id:"发现阻塞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#发现阻塞"}},[s._v("#")]),s._v(" 发现阻塞")]),s._v(" "),a("p",[s._v("redis连接异常时, 打印连接实例的ip号和端口号, 使用redis监控系统")]),s._v(" "),a("h4",{attrs:{id:"内在原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内在原因"}},[s._v("#")]),s._v(" 内在原因")]),s._v(" "),a("ol",[a("li",[s._v("API和数据结果使用不合理")]),s._v(" "),a("li",[s._v("CPU饱和")]),s._v(" "),a("li",[s._v("持久化相关阻塞")])]),s._v(" "),a("h4",{attrs:{id:"外在原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#外在原因"}},[s._v("#")]),s._v(" 外在原因")]),s._v(" "),a("ol",[a("li",[s._v("CPU竞争")]),s._v(" "),a("li",[s._v("内存交换")]),s._v(" "),a("li",[s._v("网络问题")])]),s._v(" "),a("h2",{attrs:{id:"_08-理解内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_08-理解内存"}},[s._v("#")]),s._v(" 08. 理解内存")]),s._v(" "),a("h4",{attrs:{id:"内存消耗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存消耗"}},[s._v("#")]),s._v(" 内存消耗")]),s._v(" "),a("ul",[a("li",[s._v("内存使用统计")]),s._v(" "),a("li",[s._v("内存分类")]),s._v(" "),a("li",[s._v("子进程消耗内存")])]),s._v(" "),a("h4",{attrs:{id:"内存管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[s._v("#")]),s._v(" 内存管理")]),s._v(" "),a("ul",[a("li",[s._v("设置内存上限, 动态调整内存上限")]),s._v(" "),a("li",[s._v("内存回收策略")])]),s._v(" "),a("h4",{attrs:{id:"内存回收策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存回收策略"}},[s._v("#")]),s._v(" 内存回收策略")]),s._v(" "),a("h5",{attrs:{id:"删除过期key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除过期key"}},[s._v("#")]),s._v(" 删除过期key")]),s._v(" "),a("p",[s._v("惰性删除: 基于CPU成本考虑, 但是存在内存泄漏")]),s._v(" "),a("p",[s._v("定时任务删除: redis维护的定时任务, 默认每秒运行10次, 并采用自适应算法")]),s._v(" "),a("p",[s._v("定时任务流程:")]),s._v(" "),a("ol",[a("li",[s._v("在每个数据库随机检查20个key, 发现过期就删除")]),s._v(" "),a("li",[s._v("如果超过25%的key过期, 循环步骤1直到过期key占比不足25%或运行超时(25ms)")]),s._v(" "),a("li",[s._v("如果步骤2超时, 触发快模式进行回收, 超时时间1ms且2秒内只运行一次")])]),s._v(" "),a("h4",{attrs:{id:"内存溢出控制策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存溢出控制策略"}},[s._v("#")]),s._v(" 内存溢出控制策略")]),s._v(" "),a("p",[s._v("redis使用内存达到 maxmemory 触发相关策略, redis支持以下模式")]),s._v(" "),a("ol",[a("li",[s._v("noeviction(默认): 不删除任何数据, 拒绝写入操作")]),s._v(" "),a("li",[s._v("volatile-lru: 按LRU算法删除设置了超时时间的key, 直到腾出足够空间")]),s._v(" "),a("li",[s._v("allkeys-lru: 按LRU删除key(不管有没有设置超时时间)")]),s._v(" "),a("li",[s._v("allkeys-random: 随机删除任意key")]),s._v(" "),a("li",[s._v("volatile-random: 随机删除设置超时时间的key")]),s._v(" "),a("li",[s._v("volatile-ttl: 根据ttl删除最快过期的数据")])]),s._v(" "),a("p",[s._v("LRU: 最近最少使用: 每个key拥有一个LRU计时, 淘汰最久没被访问的")]),s._v(" "),a("p",[s._v("LFU: 最不经常使用: 根据每个key的访问次数, 淘汰最少访问的")]),s._v(" "),a("h3",{attrs:{id:"内存优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存优化"}},[s._v("#")]),s._v(" 内存优化")]),s._v(" "),a("h4",{attrs:{id:"redisobject对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redisobject对象"}},[s._v("#")]),s._v(" redisObject对象")]),s._v(" "),a("p",[s._v("redis存储的所有值对象定义为redisObject结构体, 其中当value为字符串类型时, 尽量保持小于39字节")]),s._v(" "),a("h4",{attrs:{id:"缩减键值对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缩减键值对象"}},[s._v("#")]),s._v(" 缩减键值对象")]),s._v(" "),a("ul",[a("li",[s._v("缩减 key 和 value 的长度")]),s._v(" "),a("li",[s._v("使用高效序列化工具: protostuff/kryo; java自带序列化压缩效果差, 速度辣鸡")])]),s._v(" "),a("h4",{attrs:{id:"共享对象池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#共享对象池"}},[s._v("#")]),s._v(" 共享对象池")]),s._v(" "),a("p",[s._v("redis内部维护了[0-9999]的整数对象, 推荐多使用整数对象")]),s._v(" "),a("h4",{attrs:{id:"字符串优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串优化"}},[s._v("#")]),s._v(" 字符串优化")]),s._v(" "),a("p",[s._v("字符串是最常用的数据结构")]),s._v(" "),a("h4",{attrs:{id:"字符串结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串结构"}},[s._v("#")]),s._v(" 字符串结构")]),s._v(" "),a("p",[s._v("redis自己实现了字符串结构, 简单动态字符串SDS(simple dynamic string)")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("len 已用字节长度")])]),s._v(" "),a("li",[a("p",[s._v("free 未用字节长度")])]),s._v(" "),a("li",[a("p",[s._v("buf[] 字节数组")])]),s._v(" "),a("li",[a("p",[s._v("用于保存字节数组, 安全的二进制存储")])]),s._v(" "),a("li",[a("p",[s._v("内部实现空间预分配机制: 避免内存频繁分配")])]),s._v(" "),a("li",[a("p",[s._v("惰性删除机制: 缩减后空间不释放, 作为预分配空间")])])]),s._v(" "),a("h4",{attrs:{id:"预分配机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#预分配机制"}},[s._v("#")]),s._v(" 预分配机制")]),s._v(" "),a("ol",[a("li",[s._v("第一次创建已用字节长度等于实际大小, 未用字节长度等于0, 即不做预分配")]),s._v(" "),a("li",[s._v("修改后如果free空间不够且数据小于1MB, 每次预分配一倍容量\n"),a("ul",[a("li",[s._v("60, 0 >>>> 120, 120")])])]),s._v(" "),a("li",[s._v("修改后free空间不够且数据大于1MB, 每次预分配1MB数据")])]),s._v(" "),a("h4",{attrs:{id:"字符串重构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串重构"}},[s._v("#")]),s._v(" 字符串重构")]),s._v(" "),a("p",[s._v("使用hash存储json格式字符串, 同时修改配置保证hash内部编码为ziplist, 可以减少内存占用")]),s._v(" "),a("h4",{attrs:{id:"编码优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编码优化"}},[s._v("#")]),s._v(" 编码优化")]),s._v(" "),a("ul",[a("li",[s._v("redis想通过不同编码实现效率和空间的平衡")]),s._v(" "),a("li",[s._v("编码类型转换在写入数据时自动完成, 只能从小内存编码向大内存编码转换")])]),s._v(" "),a("h4",{attrs:{id:"ziplist编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ziplist编码"}},[s._v("#")]),s._v(" ziplist编码")]),s._v(" "),a("p",[s._v("ziplist编码主要目的是为了节约内存, 采用线性连续的内存结构")]),s._v(" "),a("ul",[a("li",[s._v("zlbytes : 记录整个ziplist的字节长度")]),s._v(" "),a("li",[s._v("zltail : 记录tail的偏移量, 方便pop")]),s._v(" "),a("li",[s._v("zllen : 记录zipist节点数量")]),s._v(" "),a("li",[s._v("entry-1 : 具体节点\n"),a("ul",[a("li",[s._v("prev_entry_bytes_length : 前一个节点所占空间, 可以视为prev指针")]),s._v(" "),a("li",[s._v("encoding : 表示当前节点编码和长度")]),s._v(" "),a("li",[s._v("contents : 节点的value")])])]),s._v(" "),a("li",[s._v("entry-2 ....")]),s._v(" "),a("li",[s._v("zlend : 结尾标记")])]),s._v(" "),a("p",[s._v("特点: 大幅降低内存占用, 但是命令操作更耗时")]),s._v(" "),a("h4",{attrs:{id:"intset编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#intset编码"}},[s._v("#")]),s._v(" intset编码")]),s._v(" "),a("ul",[a("li",[s._v("encoding : 表示类型, 分为 int-16, int-32, int-64, 根据长度自动升级")]),s._v(" "),a("li",[s._v("length : 集合元素长度")]),s._v(" "),a("li",[s._v("contents : 整数数组, 从小到大顺序保存")])]),s._v(" "),a("p",[s._v("尽量保持整数返回一致")]),s._v(" "),a("h4",{attrs:{id:"控制键的数量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#控制键的数量"}},[s._v("#")]),s._v(" 控制键的数量")]),s._v(" "),a("p",[s._v("可以把大量key分组映射到多个hash结构中降低key的数量, 比如将100万个key映射到1000个hash中, 可以配置参数在hash中使用ziplist编码")]),s._v(" "),a("h2",{attrs:{id:"_09-哨兵"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_09-哨兵"}},[s._v("#")]),s._v(" 09. 哨兵")]),s._v(" "),a("p",[s._v("redis主从复制下, 如果主节点故障将不能提供服务; redis2.8开始提供了 redis sentinel 哨兵来解决这个问题")]),s._v(" "),a("h4",{attrs:{id:"解决痛点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决痛点"}},[s._v("#")]),s._v(" 解决痛点")]),s._v(" "),a("ul",[a("li",[s._v("主节点挂了需要人为操作从节点, 切换从节点的slaveof, 重启旧主节点作为从节点")]),s._v(" "),a("li",[s._v("判断节点不可达是否标准")]),s._v(" "),a("li",[s._v("通知客户端新的主节点")])]),s._v(" "),a("p",[s._v("当主节点出现故障时, redis sentinel 能自动完成故障发现和故障转移, 并通知应用方")]),s._v(" "),a("p",[s._v("流程")]),s._v(" "),a("ol",[a("li",[s._v("sentinel节点将监控所有其他redis节点, 并定期检查其他节点是否可用")]),s._v(" "),a("li",[s._v("主节点挂了, sentinel发现")]),s._v(" "),a("li",[s._v("多个sentinel对主节点的故障达成一致, 则选举出一个sentinel节点进行故障转移")]),s._v(" "),a("li",[s._v("sentinel leader执行故障转移")]),s._v(" "),a("li",[s._v("将转移结果通知应用方")])]),s._v(" "),a("h4",{attrs:{id:"sentinel实际操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sentinel实际操作"}},[s._v("#")]),s._v(" sentinel实际操作")]),s._v(" "),a("p",[s._v("略")]),s._v(" "),a("h4",{attrs:{id:"sentinel实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sentinel实现原理"}},[s._v("#")]),s._v(" sentinel实现原理")]),s._v(" "),a("h4",{attrs:{id:"三个定时监控任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三个定时监控任务"}},[s._v("#")]),s._v(" 三个定时监控任务")]),s._v(" "),a("ol",[a("li",[s._v("每隔10秒, 每个sentinel向主节点和从节点发送info命令获取最新拓扑结构\n"),a("ul",[a("li",[s._v("info从主节点获取从节点信息")]),s._v(" "),a("li",[s._v("有新的从节点加入可以立即感知")]),s._v(" "),a("li",[s._v("节点挂掉后, 通过info命令更新节点拓扑信息")])])]),s._v(" "),a("li",[s._v("每隔2秒, 每个sentinel向redis的 "),a("code",[s._v("__sentinel__频道")]),s._v(" 上发送其信息以及对主节点的判断;  同时每个sentinel订阅该频道\n"),a("ul",[a("li",[s._v("发现新的sentinel节点")]),s._v(" "),a("li",[s._v("sentinel之间交换主节点状态, 作为后续下线以及leader选举的依据")])])]),s._v(" "),a("li",[s._v("每隔1秒, 每个sentinel向主节点, 从节点, 其他sentinel发送ping命令\n"),a("ul",[a("li",[s._v("确认这些节点是否可达")])])])]),s._v(" "),a("h4",{attrs:{id:"主观下线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主观下线"}},[s._v("#")]),s._v(" 主观下线")]),s._v(" "),a("p",[s._v("在ping心跳检测时, 节点超过 down-after-milliseconds 没有回复, 就视为主观下线")]),s._v(" "),a("h4",{attrs:{id:"客观下线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客观下线"}},[s._v("#")]),s._v(" 客观下线")]),s._v(" "),a("p",[s._v("当sentinel主观下线主节点, sentinel会通过命令向其他sentinel投票, 超过一定票数, 将对主节点进行客观下线")]),s._v(" "),a("h4",{attrs:{id:"领导者sentinel节点选举"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#领导者sentinel节点选举"}},[s._v("#")]),s._v(" 领导者sentinel节点选举")]),s._v(" "),a("p",[s._v("当sentinel对主节点进行客观下线, sentinel之间做leader选举的工作, 再让leader进行故障转移工作;")]),s._v(" "),a("p",[s._v("redis使用了Raft算法实现领导者选举")]),s._v(" "),a("ol",[a("li",[s._v("sentinel确认主观下线时, 则竞选, 并拉票")]),s._v(" "),a("li",[s._v("收到拉票的sentinel直接同意")]),s._v(" "),a("li",[s._v("如果拉票的sentinel收到半数选票, 当选为leader")]),s._v(" "),a("li",[s._v("如果选举失败则进行下一次选举")])]),s._v(" "),a("h4",{attrs:{id:"故障转移"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#故障转移"}},[s._v("#")]),s._v(" 故障转移")]),s._v(" "),a("ol",[a("li",[s._v("在从节点中选择一个节点作为新的主节点\n"),a("ol",[a("li",[s._v("过滤 主观下线, 短信, 5秒内没有回复过sentinel, 与主节点失联10秒以上的")]),s._v(" "),a("li",[s._v("选择从节点优先级最高的从节点列表")]),s._v(" "),a("li",[s._v("选择复制偏移量最大的节点")]),s._v(" "),a("li",[s._v("选择runid最小的从节点")])])]),s._v(" "),a("li",[s._v("对从节点执行slaveof no one")]),s._v(" "),a("li",[s._v("leader向剩余的从节点发送slaveof, 切换主节点")]),s._v(" "),a("li",[s._v("sentinel集群将原来的主节点更新为从节点, 当其回复后去slaveof新主节点")])]),s._v(" "),a("h4",{attrs:{id:"开发与运维中的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开发与运维中的问题"}},[s._v("#")]),s._v(" 开发与运维中的问题")]),s._v(" "),a("p",[s._v("故障转移日志分析, 节点运维, 读写分离高可用")]),s._v(" "),a("h2",{attrs:{id:"_10-集群-redis-cluster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-集群-redis-cluster"}},[s._v("#")]),s._v(" 10. 集群 redis cluster")]),s._v(" "),a("p",[s._v("redis cluster是redis的分布式解决方案")]),s._v(" "),a("h3",{attrs:{id:"数据分布-分区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据分布-分区"}},[s._v("#")]),s._v(" 数据分布/分区")]),s._v(" "),a("p",[s._v("分布式数据库首先要把数据分区映射到多个节点中, 让每个节点负责整体数据的一个子集")]),s._v(" "),a("h4",{attrs:{id:"分区规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分区规则"}},[s._v("#")]),s._v(" 分区规则")]),s._v(" "),a("ol",[a("li",[s._v("哈希分区 : redis cluster, cassandra")]),s._v(" "),a("li",[s._v("顺序分区 : Bigtable HBase")])]),s._v(" "),a("h4",{attrs:{id:"哈希分区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哈希分区"}},[s._v("#")]),s._v(" 哈希分区")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("节点取余分区")]),s._v(" : 简单, 一般需要根据数据量规划预分区, 一旦需要扩容需要迁移数据")]),s._v(" "),a("li",[a("strong",[s._v("一致性哈希分区")]),s._v(" "),a("ul",[a("li",[s._v("取 0~2³² 范围作为哈希环, 为每个集群节点各分配一个hash值;")]),s._v(" "),a("li",[s._v("key计算出hash后, 顺时针寻找到最近的节点")]),s._v(" "),a("li",[s._v("优势在于新增节点会影响一部分数据, 其他节点不影响")]),s._v(" "),a("li",[s._v("存在哈希倾斜; 分布式节点多的效果更好")])])]),s._v(" "),a("li",[a("strong",[s._v("虚拟槽分区")]),s._v(" : 用分散度好的hash将数据映射到固定范围的整数集合中\n"),a("ul",[a("li",[s._v("整数集合size远远大于分布式节点数量, 方便数据拆分和集群扩展")]),s._v(" "),a("li",[s._v("redis cluster槽范围0-16383, 如果有5个节点则每个节点负责3276个槽")])])])]),s._v(" "),a("h4",{attrs:{id:"redis数据分区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis数据分区"}},[s._v("#")]),s._v(" redis数据分区")]),s._v(" "),a("p",[s._v("redis采用虚拟槽分区, 每一个节点负责维护一部分槽, 所有的key映射到这些槽内")]),s._v(" "),a("p",[a("code",[s._v("slot=CRC16(key) & 16383")])]),s._v(" "),a("ul",[a("li",[s._v("解耦数据和节点之间的关系, 简化了节点扩容和缩容的难度")]),s._v(" "),a("li",[s._v("节点自身维护槽的映射关系, 不需要其他代理服务维护")]),s._v(" "),a("li",[s._v("支持节点, 槽, key之间的映射查询, 用于数据路由, 在线伸缩")])]),s._v(" "),a("h4",{attrs:{id:"redis-cluster集群功能限制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-cluster集群功能限制"}},[s._v("#")]),s._v(" redis cluster集群功能限制")]),s._v(" "),a("ol",[a("li",[s._v("key批量操作支持有线, 如mset, mget只支持相同slot内的key执行批量操作")]),s._v(" "),a("li",[s._v("不同槽位的key不支持事务")]),s._v(" "),a("li",[s._v("无法将一个大key(可能是hash, list)拆分到多个槽")]),s._v(" "),a("li",[s._v("不支持多数据库空间, 集群模式下只能使用db0")]),s._v(" "),a("li",[s._v("复制结构只支持一层主从")])]),s._v(" "),a("h3",{attrs:{id:"搭建redis-cluster集群"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#搭建redis-cluster集群"}},[s._v("#")]),s._v(" 搭建redis cluster集群")]),s._v(" "),a("h4",{attrs:{id:"准备节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#准备节点"}},[s._v("#")]),s._v(" 准备节点")]),s._v(" "),a("p",[s._v("节点数量至少6个才能保证组成完整高可用的集群, 3主3从")]),s._v(" "),a("h4",{attrs:{id:"节点握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节点握手"}},[s._v("#")]),s._v(" 节点握手")]),s._v(" "),a("p",[s._v("集群模式下的节点通过Gossip协议彼此通信, 通过发送meet, ping, pong消息通信")]),s._v(" "),a("h4",{attrs:{id:"分配槽位"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分配槽位"}},[s._v("#")]),s._v(" 分配槽位")]),s._v(" "),a("p",[s._v("cluster addslots 命令分配槽位")]),s._v(" "),a("h4",{attrs:{id:"节点通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节点通信"}},[s._v("#")]),s._v(" 节点通信")]),s._v(" "),a("p",[s._v("分布式存储中需要提供 [维护节点元数据信息] 的机制: 主要包括 节点负责哪些数据, 节点状态信息;  常见的元数据维护方式有 集中式和P2P方式")]),s._v(" "),a("p",[s._v("redis cluster采用 P2P的 Gossip协议 : 节点之间不断通信交换信息")]),s._v(" "),a("ol",[a("li",[s._v("集群中的每个节点都会单独开辟一个TCP端口, 端口号是基础端口上加10000")]),s._v(" "),a("li",[s._v("每个节点通过特定规则定时发送ping消息, 接收到ping的节点响应pong消息")])]),s._v(" "),a("h3",{attrs:{id:"gossip消息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gossip消息"}},[s._v("#")]),s._v(" Gossip消息")]),s._v(" "),a("p",[s._v("Gossip协议的主要职责是信息交换")]),s._v(" "),a("ol",[a("li",[s._v("meet消息: 通知新节点加入, meet消息正常完成后, 接收节点加入集群周期发送ping/pong消息")]),s._v(" "),a("li",[s._v("ping消息: 每个节点每秒向多个其他节点发送, 用于检测节点是否在线, 交换彼此状态信息")]),s._v(" "),a("li",[s._v("pong消息: 当接收到ping/meet消息, 作为响应回复对方; 消息内部封装了自身状态数据; 也可以向集群内广播pong消息来通知自身状态的更新")]),s._v(" "),a("li",[s._v("fail消息: 当节点判定另一个节点下线时, 会向集群内广播fail消息, 用于故障转移")])]),s._v(" "),a("h4",{attrs:{id:"gossip消息通讯节点选择"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gossip消息通讯节点选择"}},[s._v("#")]),s._v(" Gossip消息通讯节点选择")]),s._v(" "),a("p",[s._v("redis的Gossip协议需要兼顾信息交换实时性和通讯成本开销")]),s._v(" "),a("ol",[a("li",[s._v("首先, 定时任务是每秒执行10次")]),s._v(" "),a("li",[s._v("选择发送的节点, 发送ping消息\n"),a("ul",[a("li",[s._v("每秒一次: 选取5个节点, 选择最久没有通信的节点发送ping消息")]),s._v(" "),a("li",[s._v("每秒10次: 扫描本地节点列表, 找出最近一次接受pong消息时间大于cluster_node_timeout/2的节点发送ping消息")])])]),s._v(" "),a("li",[s._v("消息数据量: ping消息携带本节点信息+十分之一其他节点信息")])]),s._v(" "),a("h3",{attrs:{id:"集群伸缩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集群伸缩"}},[s._v("#")]),s._v(" 集群伸缩")]),s._v(" "),a("p",[s._v("redis在不影响集群对外服务的情况下, 可以扩容缩容: 其原理可以简单理解为槽位在不同节点之间灵活移动")]),s._v(" "),a("h4",{attrs:{id:"集群扩容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集群扩容"}},[s._v("#")]),s._v(" 集群扩容")]),s._v(" "),a("ul",[a("li",[s._v("推荐使用 redis-trib.rb工具加入新节点, 同时注意不要不同集群的节点互相加入")]),s._v(" "),a("li",[s._v("新节点加入集群后, 可以进行部分槽迁移作为扩容, 或是作为其他主节点的从节点负责故障转移")])]),s._v(" "),a("h4",{attrs:{id:"槽位迁移-数据迁移"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#槽位迁移-数据迁移"}},[s._v("#")]),s._v(" 槽位迁移,数据迁移")]),s._v(" "),a("p",[s._v("槽迁移需要确保每个节点负责相似数量的槽, 尽量保证各节点数据均匀")]),s._v(" "),a("ol",[a("li",[s._v("目标节点准备导入槽的数据")]),s._v(" "),a("li",[s._v("源节点准备迁出槽的数据")]),s._v(" "),a("li",[s._v("原节点批量迁移到目标节点")]),s._v(" "),a("li",[s._v("通知所有主节点, 更新槽映射指向新节点")])]),s._v(" "),a("h4",{attrs:{id:"集群缩容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集群缩容"}},[s._v("#")]),s._v(" 集群缩容")]),s._v(" "),a("ol",[a("li",[s._v("确定下线节点是否有负责的槽位, 如果有需要把槽迁移到其他节点")]),s._v(" "),a("li",[s._v("通知集群内其他节点忘记下线节点, 然后将下线节点正常关闭")])]),s._v(" "),a("h4",{attrs:{id:"请求路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请求路由"}},[s._v("#")]),s._v(" 请求路由")]),s._v(" "),a("p",[s._v("redis cluster并没有采用代理, 而是客户端直连")]),s._v(" "),a("h3",{attrs:{id:"请求重定向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请求重定向"}},[s._v("#")]),s._v(" 请求重定向")]),s._v(" "),a("p",[s._v("redis cluster模式下, redis接收任何key相关命令首先计算对应的槽和节点; 如果节点是自身则处理命令, 否则回复MOVED重定向错误")]),s._v(" "),a("ol",[a("li",[s._v("使用redis客户端, 在客户端中维护slot和node的映射, 本地实现key到节点的查找")]),s._v(" "),a("li",[s._v("也有可能返回ASK重定向异常 说明集群正在进行slot数据迁移")])]),s._v(" "),a("h3",{attrs:{id:"故障转移-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#故障转移-2"}},[s._v("#")]),s._v(" 故障转移")]),s._v(" "),a("p",[s._v("redis cluster自身实现了高可用, 解决节点故障问题")]),s._v(" "),a("h4",{attrs:{id:"故障发现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#故障发现"}},[s._v("#")]),s._v(" 故障发现")]),s._v(" "),a("p",[s._v("redis cluster通过ping/pong消息实现节点通信, 传播节点状态")]),s._v(" "),a("ol",[a("li",[s._v("主观下线(pfail): 发送节点发送ping消息, 如果目标节点超过超时时间都未响应pong消息, 则被视为pfail")]),s._v(" "),a("li",[s._v("客观下线(fail): 主观下线通过Gossip消息在集群内传播, 当半数以上持有槽的主节点都主观下线目标节点, 则触发客观下线")]),s._v(" "),a("li",[s._v("广播一条fail消息, 将目标节点标记为客观下线")])]),s._v(" "),a("h4",{attrs:{id:"故障恢复"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#故障恢复"}},[s._v("#")]),s._v(" 故障恢复")]),s._v(" "),a("ol",[a("li",[s._v("资格检查")]),s._v(" "),a("li",[s._v("准备选举时间")]),s._v(" "),a("li",[s._v("发起选举")]),s._v(" "),a("li",[s._v("选举投票")]),s._v(" "),a("li",[s._v("替换主节点")])]),s._v(" "),a("h3",{attrs:{id:"集群运维"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集群运维"}},[s._v("#")]),s._v(" 集群运维")]),s._v(" "),a("p",[s._v("超大规模集群带宽消耗,  pub/sub广播问题, 集群节点倾斜问题, 手动故障转移, 在线迁移数据")]),s._v(" "),a("h2",{attrs:{id:"_11-缓存设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-缓存设计"}},[s._v("#")]),s._v(" 11. 缓存设计")]),s._v(" "),a("p",[s._v("缓存使用技巧, 设计方案")]),s._v(" "),a("h4",{attrs:{id:"缓存的收益和成本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存的收益和成本"}},[s._v("#")]),s._v(" 缓存的收益和成本")]),s._v(" "),a("ol",[a("li",[s._v("加速读写")]),s._v(" "),a("li",[s._v("降低后端负载")]),s._v(" "),a("li",[s._v("数据不一致")]),s._v(" "),a("li",[s._v("代码维护成本")]),s._v(" "),a("li",[s._v("运维成本")])]),s._v(" "),a("p",[s._v("场景:")]),s._v(" "),a("ol",[a("li",[s._v("开销大的复杂计算")]),s._v(" "),a("li",[s._v("加速请求响应")])]),s._v(" "),a("h3",{attrs:{id:"缓存更新策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存更新策略"}},[s._v("#")]),s._v(" 缓存更新策略")]),s._v(" "),a("p",[s._v("缓存数据通常有生命周期, 在指定时间后被删除或更新, 这样可以保证缓存空间在一个可控范围")]),s._v(" "),a("ol",[a("li",[s._v("LRU LFU FIFO算法剔除 : 通常用于使用量超过预设值\n"),a("ul",[a("li",[s._v("一致性差(不是人为决定的剔除哪些key)")]),s._v(" "),a("li",[s._v("成本低(仅需配置策略即可)")])])]),s._v(" "),a("li",[s._v("超时剔除 : 给缓存设置过期时间\n"),a("ul",[a("li",[s._v("一段时间内存在一致性问题")]),s._v(" "),a("li",[s._v("成本不高")])])]),s._v(" "),a("li",[s._v("主动更新 : 需要真实数据更新后, 立即更新缓存数据\n"),a("ul",[a("li",[s._v("一致性最高")]),s._v(" "),a("li",[s._v("维护成本高")])])])]),s._v(" "),a("p",[s._v("最佳实践: 低一致性业务甚至可以只靠淘汰策略")]),s._v(" "),a("p",[s._v("高一致性业务结合使用超时剔除和主动更新, 即使主动更新失败, 也能保证过期时间后删除脏数据")]),s._v(" "),a("h4",{attrs:{id:"缓存粒度控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存粒度控制"}},[s._v("#")]),s._v(" 缓存粒度控制")]),s._v(" "),a("p",[s._v("缓存全部属性更通用, 但空间占用大, 网络开销大, 代码维护少; 缓存部分属性则反之")]),s._v(" "),a("h3",{attrs:{id:"缓存穿透优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透优化"}},[s._v("#")]),s._v(" 缓存穿透优化")]),s._v(" "),a("p",[s._v("缓存穿透值查询一个根本不存在的数据, 缓存层和存储层都不会命中, 通常从存储层查不到的数据都不写入缓存")]),s._v(" "),a("p",[s._v("缓存穿透的每次请求都到达存储层, 可能是恶意攻击和代码bug造成")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("缓存空对象")]),s._v(" "),a("ul",[a("li",[s._v("占用更多内存空间, 可以通过设置较短ttl自动剔除")]),s._v(" "),a("li",[s._v("可能导致数据不一致")])])]),s._v(" "),a("li",[a("strong",[s._v("布隆过滤器拦截")]),s._v(" "),a("ul",[a("li",[s._v("可以将所有数据做成布隆过滤器, 判断数据是否存在")]),s._v(" "),a("li",[s._v("适用于数据命中不高, 数据相对固定, 实时性低的引用场景")]),s._v(" "),a("li",[s._v("代码复杂但缓存空间占用少")]),s._v(" "),a("li",[s._v("redis4.0开始提供RedisBloom插件")])])])]),s._v(" "),a("h4",{attrs:{id:"布隆过滤器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#布隆过滤器"}},[s._v("#")]),s._v(" 布隆过滤器")]),s._v(" "),a("ol",[a("li",[s._v("通过多个映射函数将已有的元素映射到bitmap上, 一个元素会映射到多个bit")]),s._v(" "),a("li",[s._v("如果目标元素经过函数映射到没有数据的bitmap位置上, 说明数据库中肯定没有, 但会有一定概率穿透(误判), 1%")]),s._v(" "),a("li",[s._v("传统的布隆过滤器并不支持删除操作(会增加误判率), 使用counting布隆或布谷鸟过滤器")])]),s._v(" "),a("h4",{attrs:{id:"无底洞优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#无底洞优化"}},[s._v("#")]),s._v(" 无底洞优化")]),s._v(" "),a("p",[s._v("大量redis节点反而导致性能下降 --- 分布式下的批量操作")]),s._v(" "),a("ol",[a("li",[s._v("命令本身优化")]),s._v(" "),a("li",[s._v("减少网络通信次数")]),s._v(" "),a("li",[s._v("降低接入成本, 长连接/连接池/NIO")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdn.net/20180424144835553?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ltMTIzNDU2Njc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70",alt:"comp"}})]),s._v(" "),a("p",[s._v("方案选择")]),s._v(" "),a("ol",[a("li",[s._v("串行 get key * n次")]),s._v(" "),a("li",[s._v("将一个批量命令按节点拆分成多个mget, 发送给对应节点处理")]),s._v(" "),a("li",[s._v("并行IO, 使用异步发送方案2中的多个mget")]),s._v(" "),a("li",[s._v("hash_tag实现: 将多个key强制分配到一个节点上")])]),s._v(" "),a("h3",{attrs:{id:"缓存雪崩优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩优化"}},[s._v("#")]),s._v(" 缓存雪崩优化")]),s._v(" "),a("p",[s._v("大量请求下, 缓存down掉后, 所有请求到达数据库造成级联宕机的情况")]),s._v(" "),a("ol",[a("li",[s._v("保证缓存服务高可用性")]),s._v(" "),a("li",[s._v("隔离组件为后端限流, 降级 : 将重要资源隔离, Hystrix")]),s._v(" "),a("li",[s._v("提前演练: 项目上线前演练缓存宕机之后, 应用及后端负载情况, 以及可能出现的问题")])]),s._v(" "),a("h3",{attrs:{id:"热点key重建优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#热点key重建优化"}},[s._v("#")]),s._v(" 热点key重建优化")]),s._v(" "),a("p",[s._v("使用 缓存+过期时间 策略能满足大部分需求, 但是")]),s._v(" "),a("ol",[a("li",[s._v("当前key上一个热点key, 并发量非常大")]),s._v(" "),a("li",[s._v("重建缓存不能短时间完成, 可能是个复杂计算, 多次SQL, 多次IO")]),s._v(" "),a("li",[s._v("缓存失效瞬间, 大量请求达到后端数据库")])]),s._v(" "),a("p",[s._v("解决")]),s._v(" "),a("ol",[a("li",[s._v("分布式锁\n"),a("ul",[a("li",[s._v("死锁风险, 线程池阻塞, 但是数据一致性保证")])])]),s._v(" "),a("li",[s._v("永远不过期\n"),a("ol",[a("li",[s._v("不设置过期时间")]),s._v(" "),a("li",[s._v("设置逻辑过期时间, 用单独的线程不断构建缓存(可能不一致)")])])])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdn.net/20180424151829748?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ltMTIzNDU2Njc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70",alt:"热点key"}})]),s._v(" "),a("h2",{attrs:{id:"_12-其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-其他"}},[s._v("#")]),s._v(" 12. 其他")]),s._v(" "),a("p",[s._v("开发运维, CacheCloud, 配置目录等, 略")]),s._v(" "),a("h3",{attrs:{id:"补充"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#补充"}},[s._v("#")]),s._v(" 补充")]),s._v(" "),a("h3",{attrs:{id:"redis分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁"}},[s._v("#")]),s._v(" Redis分布式锁")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/s8xjm1ZCKIoTGT3DCVA4aw",target:"_blank",rel:"noopener noreferrer"}},[s._v("Redis分布式锁到底安全吗, 关于RedLock的争论"),a("OutboundLink")],1)]),s._v(" "),a("h4",{attrs:{id:"redis分布式锁实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁实现"}},[s._v("#")]),s._v(" redis分布式锁实现")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("加锁")]),s._v(": Lua脚本, SET lock_key $unique_id EX $expire_time NX\n"),a("ul",[a("li",[s._v("最初版: setnx 命令抢占锁 (SET if Not Exist) , 此时目标key (此处为lock_key) 作为锁")]),s._v(" "),a("li",[s._v("解决死锁问题: 设置EX超时时间, 避免占锁线程挂掉, 导致的死锁")])])]),s._v(" "),a("li",[a("strong",[s._v("释放锁")]),s._v(":\n"),a("ul",[a("li",[s._v("解决释放别人的锁的问题: key中的value还没用到, 设置为UUID吧! 先 GET 判断锁是否归属自己, 再决定是否 DEL 释放锁, 整个过程为了"),a("strong",[s._v("保证原子性, 使用Lua脚本")])])])]),s._v(" "),a("li",[a("strong",[s._v("锁续期")]),s._v(" :\n"),a("ul",[a("li",[s._v("解决锁过期时间不好评估的问题: 如果占锁线程正常, 定时对锁续期")])])]),s._v(" "),a("li",[s._v("仍然存在的"),a("strong",[s._v("问题")]),s._v(": redis主从集群下, 数据不同步导致锁失效\n"),a("ul",[a("li",[s._v("主机设置完锁后还未同步到从机就宕机了, 此时新主机根本没有上锁")])])])]),s._v(" "),a("p",[s._v("Redisson提供了基于redis的分布式锁, 实现了自动续期功能")]),s._v(" "),a("h4",{attrs:{id:"redlock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redlock"}},[s._v("#")]),s._v(" RedLock")]),s._v(" "),a("p",[s._v("至少要部署 5 个 Redis 实例, 而且都是主库, 它们之间没有任何关系")]),s._v(" "),a("ol",[a("li",[s._v("客户端先获取「当前时间戳T1」")]),s._v(" "),a("li",[s._v("客户端依次向这 5 个 Redis 实例发起加锁请求 (用前面讲到的 SET 命令)\n"),a("ul",[a("li",[s._v("且每个请求会设置超时时间 (毫秒级, 要远小于锁的有效时间)")]),s._v(" "),a("li",[s._v("如果某一个实例加锁失败 (包括网络超时、锁被其它人持有等各种异常情况) , 就立即向下一个 Redis 实例申请加锁")])])]),s._v(" "),a("li",[s._v("如果客户端在 >=3 个 Redis 实例加锁成功 (大多数加锁成功) , 则\n"),a("ol",[a("li",[s._v("再次获取「当前时间戳T2」")]),s._v(" "),a("li",[s._v("判断 T2 - T1 < 锁的过期时间, 如果还未超过过期(有效)时间, 则加锁成功, 否则加锁失败")])])]),s._v(" "),a("li",[s._v("加锁成功, 去操作共享资源")]),s._v(" "),a("li",[s._v("加锁失败, 向「全部节点」发起释放锁请求 (前面讲到的 Lua 脚本释放锁)")])]),s._v(" "),a("p",[a("svg",{attrs:{id:"SvgjsSvg1006",width:"327",height:"333",xmlns:"http://www.w3.org/2000/svg",version:"1.1","xmlns:xlink":"http://www.w3.org/1999/xlink","xmlns:svgjs":"http://svgjs.com/svgjs"}},[a("defs",{attrs:{id:"SvgjsDefs1007"}},[a("marker",{attrs:{id:"SvgjsMarker1046",markerWidth:"16",markerHeight:"12",refX:"16",refY:"6",viewBox:"0 0 16 12",orient:"auto",markerUnits:"userSpaceOnUse","stroke-dasharray":"0,0"}},[a("path",{attrs:{id:"SvgjsPath1047",d:"M0,2 L14,6 L0,11 L0,2",fill:"#323232",stroke:"#323232","stroke-width":"2"}})]),a("marker",{attrs:{id:"SvgjsMarker1050",markerWidth:"16",markerHeight:"12",refX:"16",refY:"6",viewBox:"0 0 16 12",orient:"auto",markerUnits:"userSpaceOnUse","stroke-dasharray":"0,0"}},[a("path",{attrs:{id:"SvgjsPath1051",d:"M0,2 L14,6 L0,11 L0,2",fill:"#323232",stroke:"#323232","stroke-width":"2"}})]),a("marker",{attrs:{id:"SvgjsMarker1054",markerWidth:"16",markerHeight:"12",refX:"16",refY:"6",viewBox:"0 0 16 12",orient:"auto",markerUnits:"userSpaceOnUse","stroke-dasharray":"0,0"}},[a("path",{attrs:{id:"SvgjsPath1055",d:"M0,2 L14,6 L0,11 L0,2",fill:"#323232",stroke:"#323232","stroke-width":"2"}})]),a("marker",{attrs:{id:"SvgjsMarker1058",markerWidth:"16",markerHeight:"12",refX:"16",refY:"6",viewBox:"0 0 16 12",orient:"auto",markerUnits:"userSpaceOnUse","stroke-dasharray":"0,0"}},[a("path",{attrs:{id:"SvgjsPath1059",d:"M0,2 L14,6 L0,11 L0,2",fill:"#323232",stroke:"#323232","stroke-width":"2"}})]),a("marker",{attrs:{id:"SvgjsMarker1062",markerWidth:"16",markerHeight:"12",refX:"16",refY:"6",viewBox:"0 0 16 12",orient:"auto",markerUnits:"userSpaceOnUse","stroke-dasharray":"0,0"}},[a("path",{attrs:{id:"SvgjsPath1063",d:"M0,2 L14,6 L0,11 L0,2",fill:"#323232",stroke:"#323232","stroke-width":"2"}})])]),a("g",{attrs:{id:"SvgjsG1008",transform:"translate(25,131.5)"}},[a("path",{attrs:{id:"SvgjsPath1009",d:"M 0 35C 0 -11.666666666666666 70 -11.666666666666666 70 35C 70 81.66666666666667 0 81.66666666666667 0 35Z",stroke:"rgba(50,50,50,1)","stroke-width":"2","fill-opacity":"1",fill:"#bbdefb"}}),a("g",{attrs:{id:"SvgjsG1010"}},[a("text",{attrs:{id:"SvgjsText1011","font-family":"微软雅黑","text-anchor":"middle","font-size":"13px",width:"50px",fill:"#323232","font-weight":"400",align:"middle",lineHeight:"125%",anchor:"middle",family:"微软雅黑",size:"13px",weight:"400","font-style":"",opacity:"1",y:"25.375",transform:"rotate(0)"}},[a("tspan",{attrs:{id:"SvgjsTspan1012",dy:"16",x:"35"}},[a("tspan",{staticStyle:{},attrs:{id:"SvgjsTspan1013"}},[s._v("app")])])])])]),a("g",{attrs:{id:"SvgjsG1014",transform:"translate(210,25)"}},[a("path",{attrs:{id:"SvgjsPath1015",d:"M 0 4Q 0 0 4 0L 88 0Q 92 0 92 4L 92 38Q 92 42 88 42L 4 42Q 0 42 0 38Z",stroke:"rgba(50,50,50,1)","stroke-width":"2","fill-opacity":"1",fill:"#ffcdd2"}}),a("g",{attrs:{id:"SvgjsG1016"}},[a("text",{attrs:{id:"SvgjsText1017","font-family":"微软雅黑","text-anchor":"middle","font-size":"13px",width:"72px",fill:"#323232","font-weight":"400",align:"middle",lineHeight:"125%",anchor:"middle",family:"微软雅黑",size:"13px",weight:"400","font-style":"",opacity:"1",y:"11.375",transform:"rotate(0)"}},[a("tspan",{attrs:{id:"SvgjsTspan1018",dy:"16",x:"46"}},[a("tspan",{staticStyle:{},attrs:{id:"SvgjsTspan1019"}},[s._v("Redis")])])])])]),a("g",{attrs:{id:"SvgjsG1020",transform:"translate(210,85.25)"}},[a("path",{attrs:{id:"SvgjsPath1021",d:"M 0 4Q 0 0 4 0L 88 0Q 92 0 92 4L 92 38Q 92 42 88 42L 4 42Q 0 42 0 38Z",stroke:"rgba(50,50,50,1)","stroke-width":"2","fill-opacity":"1",fill:"#ffcdd2"}}),a("g",{attrs:{id:"SvgjsG1022"}},[a("text",{attrs:{id:"SvgjsText1023","font-family":"微软雅黑","text-anchor":"middle","font-size":"13px",width:"72px",fill:"#323232","font-weight":"400",align:"middle",lineHeight:"125%",anchor:"middle",family:"微软雅黑",size:"13px",weight:"400","font-style":"",opacity:"1",y:"11.375",transform:"rotate(0)"}},[a("tspan",{attrs:{id:"SvgjsTspan1024",dy:"16",x:"46"}},[a("tspan",{staticStyle:{},attrs:{id:"SvgjsTspan1025"}},[s._v("Redis")])])])])]),a("g",{attrs:{id:"SvgjsG1026",transform:"translate(210,145.5)"}},[a("path",{attrs:{id:"SvgjsPath1027",d:"M 0 4Q 0 0 4 0L 88 0Q 92 0 92 4L 92 38Q 92 42 88 42L 4 42Q 0 42 0 38Z",stroke:"rgba(50,50,50,1)","stroke-width":"2","fill-opacity":"1",fill:"#ffcdd2"}}),a("g",{attrs:{id:"SvgjsG1028"}},[a("text",{attrs:{id:"SvgjsText1029","font-family":"微软雅黑","text-anchor":"middle","font-size":"13px",width:"72px",fill:"#323232","font-weight":"400",align:"middle",lineHeight:"125%",anchor:"middle",family:"微软雅黑",size:"13px",weight:"400","font-style":"",opacity:"1",y:"11.375",transform:"rotate(0)"}},[a("tspan",{attrs:{id:"SvgjsTspan1030",dy:"16",x:"46"}},[a("tspan",{staticStyle:{},attrs:{id:"SvgjsTspan1031"}},[s._v("Redis")])])])])]),a("g",{attrs:{id:"SvgjsG1032",transform:"translate(210,205.75)"}},[a("path",{attrs:{id:"SvgjsPath1033",d:"M 0 4Q 0 0 4 0L 88 0Q 92 0 92 4L 92 38Q 92 42 88 42L 4 42Q 0 42 0 38Z",stroke:"rgba(50,50,50,1)","stroke-width":"2","fill-opacity":"1",fill:"#ffcdd2"}}),a("g",{attrs:{id:"SvgjsG1034"}},[a("text",{attrs:{id:"SvgjsText1035","font-family":"微软雅黑","text-anchor":"middle","font-size":"13px",width:"72px",fill:"#323232","font-weight":"400",align:"middle",lineHeight:"125%",anchor:"middle",family:"微软雅黑",size:"13px",weight:"400","font-style":"",opacity:"1",y:"11.375",transform:"rotate(0)"}},[a("tspan",{attrs:{id:"SvgjsTspan1036",dy:"16",x:"46"}},[a("tspan",{staticStyle:{},attrs:{id:"SvgjsTspan1037"}},[s._v("Redis")])])])])]),a("g",{attrs:{id:"SvgjsG1038",transform:"translate(210,266)"}},[a("path",{attrs:{id:"SvgjsPath1039",d:"M 0 4Q 0 0 4 0L 88 0Q 92 0 92 4L 92 38Q 92 42 88 42L 4 42Q 0 42 0 38Z",stroke:"rgba(50,50,50,1)","stroke-width":"2","fill-opacity":"1",fill:"#ffcdd2"}}),a("g",{attrs:{id:"SvgjsG1040"}},[a("text",{attrs:{id:"SvgjsText1041","font-family":"微软雅黑","text-anchor":"middle","font-size":"13px",width:"72px",fill:"#323232","font-weight":"400",align:"middle",lineHeight:"125%",anchor:"middle",family:"微软雅黑",size:"13px",weight:"400","font-style":"",opacity:"1",y:"11.375",transform:"rotate(0)"}},[a("tspan",{attrs:{id:"SvgjsTspan1042",dy:"16",x:"46"}},[a("tspan",{staticStyle:{},attrs:{id:"SvgjsTspan1043"}},[s._v("Redis")])])])])]),a("g",{attrs:{id:"SvgjsG1044"}},[a("path",{attrs:{id:"SvgjsPath1045",d:"M95 166.5C 161.37408368287248 172.30697987417233 143.3723781003704 46 210 46",stroke:"#323232","stroke-width":"2",fill:"none","marker-end":"url(#SvgjsMarker1046)"}})]),a("g",{attrs:{id:"SvgjsG1048"}},[a("path",{attrs:{id:"SvgjsPath1049",d:"M95 166.5C 146.733206919738 171.02606913331795 158.06918063423223 106.25 210 106.25",stroke:"#323232","stroke-width":"2",fill:"none","marker-end":"url(#SvgjsMarker1050)"}})]),a("g",{attrs:{id:"SvgjsG1052"}},[a("path",{attrs:{id:"SvgjsPath1053",d:"M95 166.5C 140.8249561122203 170.50916416639225 164 166.5 210 166.5",stroke:"#323232","stroke-width":"2",fill:"none","marker-end":"url(#SvgjsMarker1054)"}})]),a("g",{attrs:{id:"SvgjsG1056"}},[a("path",{attrs:{id:"SvgjsPath1057",d:"M95 166.5C 146.733206919738 171.02606913331795 158.06918063423223 226.75 210 226.75",stroke:"#323232","stroke-width":"2",fill:"none","marker-end":"url(#SvgjsMarker1058)"}})]),a("g",{attrs:{id:"SvgjsG1060"}},[a("path",{attrs:{id:"SvgjsPath1061",d:"M95 166.5C 161.37408368287248 172.30697987417233 143.3723781003704 287 210 287",stroke:"#323232","stroke-width":"2",fill:"none","marker-end":"url(#SvgjsMarker1062)"}})])])]),s._v(" "),a("h4",{attrs:{id:"spring整合redis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring整合redis"}},[s._v("#")]),s._v(" Spring整合redis")]),s._v(" "),a("p",[s._v("jedis, lettuce")]),s._v(" "),a("ol",[a("li",[s._v("连接redis")]),s._v(" "),a("li",[s._v("选择高阶或低阶的api进行调用")]),s._v(" "),a("li",[s._v("数据要序列化成什么样子放进去 (Jackson2JsonRedisSerializer)")])]),s._v(" "),a("h4",{attrs:{id:"select-epoll"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#select-epoll"}},[s._v("#")]),s._v(" select epoll")]),s._v(" "),a("ol",[a("li",[s._v("早期对内核socket读取是阻塞的")]),s._v(" "),a("li",[s._v("后来对socket可以非阻塞读取, 轮询读取, 多个socket还是要每个去读取")]),s._v(" "),a("li",[s._v("出现select, 使用后内核一次返回哪些socket可以读取")]),s._v(" "),a("li")])])}),[],!1,null,null,null);t.default=r.exports}}]);