(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{438:function(v,_,i){"use strict";i.r(_);var l=i(45),a=Object(l.a)({},(function(){var v=this,_=v.$createElement,i=v._self._c||_;return i("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[i("h1",{attrs:{id:"point"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#point"}},[v._v("#")]),v._v(" point")]),v._v(" "),i("h2",{attrs:{id:"java"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#java"}},[v._v("#")]),v._v(" Java")]),v._v(" "),i("h3",{attrs:{id:"真·java基础"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#真·java基础"}},[v._v("#")]),v._v(" 真·Java基础")]),v._v(" "),i("ul",[i("li",[v._v("String")])]),v._v(" "),i("h3",{attrs:{id:"集合"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#集合"}},[v._v("#")]),v._v(" 集合")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("普通集合")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("List")]),v._v(" "),i("ul",[i("li",[v._v("ArrayList")]),v._v(" "),i("li",[v._v("LinkedList")]),v._v(" "),i("li",[v._v("List接口")])])]),v._v(" "),i("li",[i("p",[v._v("Map")]),v._v(" "),i("ul",[i("li",[v._v("HashMap")]),v._v(" "),i("li",[v._v("LinkedHashMap")]),v._v(" "),i("li",[v._v("TreeMap")])])]),v._v(" "),i("li",[i("p",[v._v("Set")]),v._v(" "),i("ul",[i("li",[v._v("实现基本同Map")])])])])]),v._v(" "),i("li",[i("p",[v._v("JUC线程安全集合")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("Collections.synchronized")])]),v._v(" "),i("li",[i("p",[v._v("CopyOnWriteArrayList")])]),v._v(" "),i("li",[i("p",[v._v("ConcurrentHashMap")])]),v._v(" "),i("li",[i("p",[v._v("BlockingQueue")]),v._v(" "),i("ul",[i("li",[v._v("LinkedBlockingQueue")]),v._v(" "),i("li",[v._v("ArrayBlockingQueue")]),v._v(" "),i("li",[v._v("DelayQueue")]),v._v(" "),i("li",[v._v("SynchronousQueue")])])])])]),v._v(" "),i("li",[i("p",[v._v("常见问题")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("hashmap如何解决hash冲突，为什么hashmap中的链表需要转成红黑树？")])]),v._v(" "),i("li",[i("p",[v._v("hashmap什么时候会触发扩容？")])]),v._v(" "),i("li",[i("p",[v._v("jdk1.8之前并发操作hashmap时为什么会有死循环的问题？")])]),v._v(" "),i("li",[i("p",[v._v("hashmap扩容时每个entry需要再计算一次hash吗？")])]),v._v(" "),i("li",[i("p",[v._v("hashmap的数组长度为什么要保证是2的幂？")])]),v._v(" "),i("li",[i("p",[v._v("LinkedHashMap")]),v._v(" "),i("ul",[i("li",[v._v("如何用LinkedHashMap实现LRU？")])])]),v._v(" "),i("li",[i("p",[v._v("TreeMap")]),v._v(" "),i("ul",[i("li",[v._v("如何用TreeMap实现一致性hash？")])])]),v._v(" "),i("li",[i("p",[v._v("ConcurrentHashMap是如何在保证并发安全的同时提高性能？")])]),v._v(" "),i("li",[i("p",[v._v("ConcurrentHashMap是如何让多线程同时参与扩容？")])]),v._v(" "),i("li",[i("p",[v._v("LinkedBlockingQueue、DelayQueue是如何实现的？")])]),v._v(" "),i("li",[i("p",[v._v("CopyOnWriteArrayList是如何保证线程安全的？")])])])])]),v._v(" "),i("h3",{attrs:{id:"并发"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#并发"}},[v._v("#")]),v._v(" 并发")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("常见问题")]),v._v(" "),i("ul",[i("li",[v._v("synchronized与ReentrantLock的区别？")]),v._v(" "),i("li",[v._v("乐观锁和悲观锁的区别？")]),v._v(" "),i("li",[v._v("如何实现一个乐观锁？")]),v._v(" "),i("li",[v._v("AQS是如何唤醒下一个线程的？")]),v._v(" "),i("li",[v._v("ReentrantLock如何实现公平和非公平锁是如何实现？")]),v._v(" "),i("li",[v._v("CountDownLatch和CyclicBarrier的区别？各自适用于什么场景？")]),v._v(" "),i("li",[v._v("适用ThreadLocal时要注意什么？比如说内存泄漏?")]),v._v(" "),i("li",[v._v("说一说往线程池里提交一个任务会发生什么？")]),v._v(" "),i("li",[v._v("线程池的几个参数如何设置？")]),v._v(" "),i("li",[v._v("线程池的非核心线程什么时候会被释放？")]),v._v(" "),i("li",[v._v("如何排查死锁？")]),v._v(" "),i("li",[v._v("进程, 线程, 协程区别")])])]),v._v(" "),i("li",[i("p",[v._v("sync, cas, aqs, ThreadLocal, 线程池")])])]),v._v(" "),i("h3",{attrs:{id:"引用"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[v._v("#")]),v._v(" 引用")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("软引用")])]),v._v(" "),i("li",[i("p",[v._v("弱引用")])]),v._v(" "),i("li",[i("p",[v._v("虚引用")])]),v._v(" "),i("li",[i("p",[v._v("适用场景以及释放机制")])]),v._v(" "),i("li",[i("p",[v._v("常见问题")]),v._v(" "),i("ul",[i("li",[v._v("软引用什么时候会被释放")]),v._v(" "),i("li",[v._v("弱引用什么时候会被释放")])])])]),v._v(" "),i("h3",{attrs:{id:"类加载"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#类加载"}},[v._v("#")]),v._v(" 类加载")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("双亲委派机制")])]),v._v(" "),i("li",[i("p",[v._v("常见问题")]),v._v(" "),i("ul",[i("li",[v._v("双亲委派机制的作用？")]),v._v(" "),i("li",[v._v("Tomcat的classloader结构")]),v._v(" "),i("li",[v._v("如何自己实现一个classloader打破双亲委派")]),v._v(" "),i("li",[v._v("Tomcat如何保证类隔离")])])])]),v._v(" "),i("h3",{attrs:{id:"io"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#io"}},[v._v("#")]),v._v(" IO")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("BIO和NIO的区别")])]),v._v(" "),i("li",[i("p",[v._v("多路复用机制")])]),v._v(" "),i("li",[i("p",[v._v("常见问题")]),v._v(" "),i("ul",[i("li",[v._v("同步阻塞、同步非阻塞、异步的区别？")]),v._v(" "),i("li",[v._v("select、poll、eopll的区别？")]),v._v(" "),i("li",[v._v("java NIO与BIO的区别？")]),v._v(" "),i("li",[v._v("reactor线程模型是什么?")])])])]),v._v(" "),i("h3",{attrs:{id:"jvm"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[v._v("#")]),v._v(" JVM")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("GC")]),v._v(" "),i("ul",[i("li",[v._v("垃圾回收基本原理、几种常见的垃圾回收器的特性、重点了解CMS（或G1）以及一些重要的参数")])])]),v._v(" "),i("li",[i("p",[v._v("内存区域")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("能说清jvm的内存划分")])]),v._v(" "),i("li",[i("p",[v._v("直接内存")]),v._v(" "),i("ul",[i("li",[v._v("直接内存属于本地系统的IO操作, 堆需要在堆内存和本地内存中来回拷贝")])])]),v._v(" "),i("li",[i("p",[v._v("变化")]),v._v(" "),i("ul",[i("li",[v._v("方法区的变化:\n1.6及以下, 方法区(永久代)存在于堆外(依然隶属于VM内存), 存放常量池, class对象\n1.7将字符串常量池移到堆中, 运行时常量池和class对象不变\n1.8移除永久代, 由元数据区取代, 在直接内存")])])])])]),v._v(" "),i("li",[i("p",[v._v("常见问题")]),v._v(" "),i("ul",[i("li",[v._v("CMS GC回收分为哪几个阶段？分别做了什么事情？")]),v._v(" "),i("li",[v._v("CMS有哪些重要参数？")]),v._v(" "),i("li",[v._v("Concurrent Model Failure和ParNew promotion failed什么情况下会发生？")]),v._v(" "),i("li",[v._v("CMS的优缺点？")]),v._v(" "),i("li",[v._v("有做过哪些GC调优？")]),v._v(" "),i("li",[v._v("为什么要划分成年轻代和老年代？")]),v._v(" "),i("li",[v._v("年轻代为什么被划分成eden、survivor区域？")]),v._v(" "),i("li",[v._v("年轻代为什么采用的是复制算法？")]),v._v(" "),i("li",[v._v("老年代为什么采用的是标记清除、标记整理算法")]),v._v(" "),i("li",[v._v("什么情况下使用堆外内存？要注意些什么？")]),v._v(" "),i("li",[v._v("堆外内存如何被回收？")]),v._v(" "),i("li",[v._v("jvm内存区域划分是怎样的？")])])])]),v._v(" "),i("h2",{attrs:{id:"中间件"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#中间件"}},[v._v("#")]),v._v(" 中间件")]),v._v(" "),i("h3",{attrs:{id:"spring"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[v._v("#")]),v._v(" Spring")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("bean的生命周期")])]),v._v(" "),i("li",[i("p",[v._v("循环依赖问题")])]),v._v(" "),i("li",[i("p",[v._v("AOP的实现")])]),v._v(" "),i("li",[i("p",[v._v("spring事务传播")])]),v._v(" "),i("li",[i("p",[v._v("spring cloud")])]),v._v(" "),i("li",[i("p",[v._v("常见问题")]),v._v(" "),i("ul",[i("li",[v._v("java动态代理和cglib动态代理的区别（经常结合spring一起问所以就放这里了）")]),v._v(" "),i("li",[v._v("spring中bean的生命周期是怎样的？")]),v._v(" "),i("li",[v._v("属性注入和构造器注入哪种会有循环依赖的问题？")])])])]),v._v(" "),i("h3",{attrs:{id:"dubbo-或其他rpc框架"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#dubbo-或其他rpc框架"}},[v._v("#")]),v._v(" Dubbo（或其他Rpc框架")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("服务发现")])]),v._v(" "),i("li",[i("p",[v._v("路由")])]),v._v(" "),i("li",[i("p",[v._v("异步调用")])]),v._v(" "),i("li",[i("p",[v._v("限流降级")])]),v._v(" "),i("li",[i("p",[v._v("失败重试")])]),v._v(" "),i("li",[i("p",[v._v("常见问题")]),v._v(" "),i("ul",[i("li",[v._v("Dubbo如何做负载均衡？")]),v._v(" "),i("li",[v._v("Dubbo如何做限流降级？")]),v._v(" "),i("li",[v._v("Dubbo如何优雅的下线服务？")]),v._v(" "),i("li",[v._v("Dubbo如何实现异步调用的？")])])])]),v._v(" "),i("h3",{attrs:{id:"rocketmq-或其他消息中间件"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq-或其他消息中间件"}},[v._v("#")]),v._v(" RocketMq（或其他消息中间件）")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("高可用和高吞吐")])]),v._v(" "),i("li",[i("p",[v._v("消息顺序")])]),v._v(" "),i("li",[i("p",[v._v("重复消费")])]),v._v(" "),i("li",[i("p",[v._v("事务消息")])]),v._v(" "),i("li",[i("p",[v._v("延迟消息")])]),v._v(" "),i("li",[i("p",[v._v("死信队列")])]),v._v(" "),i("li",[i("p",[v._v("常见问题")]),v._v(" "),i("ul",[i("li",[v._v("RocketMq如何保证高可用的？")]),v._v(" "),i("li",[v._v("RocketMq如何保证高吞吐的？")]),v._v(" "),i("li",[v._v("RocketMq的消息是有序的吗？")]),v._v(" "),i("li",[v._v("RocketMq的消息局部顺序是如何保证的?")]),v._v(" "),i("li",[v._v("RocketMq事务消息的实现机制？")]),v._v(" "),i("li",[v._v("RocketMq会有重复消费的问题吗？如何解决？")]),v._v(" "),i("li",[v._v("RocketMq支持什么级别的延迟消息？如何实现的？")]),v._v(" "),i("li",[v._v("RocketMq是推模型还是拉模型？")]),v._v(" "),i("li",[v._v("Consumer的负载均衡是怎么样的？")])])])]),v._v(" "),i("h3",{attrs:{id:"redis-或其他缓存系统"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#redis-或其他缓存系统"}},[v._v("#")]),v._v(" Redis（或其他缓存系统）")]),v._v(" "),i("p",[v._v("Redis本质上是一个数据结构服务器\n(data structures server);")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("redis数据结构")]),v._v(" "),i("p",[v._v("使用者角度/Redis暴露的接口")]),v._v(" "),i("ul",[i("li",[v._v("string")]),v._v(" "),i("li",[v._v("bitmap")]),v._v(" "),i("li",[v._v("hash")]),v._v(" "),i("li",[v._v("list")]),v._v(" "),i("li",[v._v("set")]),v._v(" "),i("li",[v._v("zset")])])]),v._v(" "),i("li",[i("p",[v._v("redis内部数据结构")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("研究目标\n存储效率（memory efficiency）\n快速响应时间（fast response time）\n单线程（single-threaded）")])]),v._v(" "),i("li",[i("p",[v._v("dict\n所谓的hashtable")]),v._v(" "),i("p",[v._v("https://mp.weixin.qq.com/s/qFDOFr4HYpgUg-J_VCNvQw")])]),v._v(" "),i("li",[i("p",[v._v("sds\n字符串")]),v._v(" "),i("p",[v._v("Simple Dynamic String")]),v._v(" "),i("p",[v._v("https://mp.weixin.qq.com/s/_uqWOC1Gau-yCja1fmTdqA")])]),v._v(" "),i("li",[i("p",[v._v("robj(redisObject)\n可以表示多种类型")]),v._v(" "),i("p",[v._v("https://mp.weixin.qq.com/s/Jlv6AgaO4QrCXvjr6RipIQ")]),v._v(" "),i("p",[v._v("为多种数据类型提供一种统一的表示方式。\n允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。\n支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。")])]),v._v(" "),i("li",[i("p",[v._v('ziplist\n特殊的"双向链表"')]),v._v(" "),i("p",[v._v("ziplist将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存")])]),v._v(" "),i("li",[i("p",[v._v("quicklist\n作为list实现")])]),v._v(" "),i("li",[i("p",[v._v("skiplist")])]),v._v(" "),i("li",[i("p",[v._v("intset")])])])]),v._v(" "),i("li",[i("p",[v._v("redis工作模型")]),v._v(" "),i("ul",[i("li",[v._v("单线程worker, 免去加锁的过程")])])]),v._v(" "),i("li",[i("p",[v._v("redis持久化")]),v._v(" "),i("ul",[i("li",[v._v("RDB")]),v._v(" "),i("li",[v._v("AOF")]),v._v(" "),i("li",[v._v("区别")])])]),v._v(" "),i("li",[i("p",[v._v("redis过期淘汰机制")])]),v._v(" "),i("li",[i("p",[v._v("redis分布式集群的常见形式")])]),v._v(" "),i("li",[i("p",[v._v("分布式锁")])]),v._v(" "),i("li",[i("p",[v._v("缓存击穿")])]),v._v(" "),i("li",[i("p",[v._v("缓存雪崩")])]),v._v(" "),i("li",[i("p",[v._v("缓存一致性")])]),v._v(" "),i("li",[i("p",[v._v("常见问题")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("redis性能为什么高?")])]),v._v(" "),i("li",[i("p",[v._v("单线程的redis如何利用多核cpu机器？")])]),v._v(" "),i("li",[i("p",[v._v("redis的缓存淘汰策略？")])]),v._v(" "),i("li",[i("p",[v._v("redis如何持久化数据？")])]),v._v(" "),i("li",[i("p",[v._v("redis有哪几种数据结构？")])]),v._v(" "),i("li",[i("p",[v._v("redis集群有哪几种形式？")])]),v._v(" "),i("li",[i("p",[v._v("有海量key和value都比较小的数据，在redis中如何存储才更省内存？")])]),v._v(" "),i("li",[i("p",[v._v("如何保证redis和DB中的数据一致性？")])]),v._v(" "),i("li",[i("p",[v._v("如何解决缓存穿透和缓存雪崩？")])]),v._v(" "),i("li",[i("p",[v._v("如何用redis实现分布式锁？")])]),v._v(" "),i("li",[i("p",[v._v("redis对比memcached")]),v._v(" "),i("ul",[i("li",[v._v("1.计算向数据移动\n2.mem的value没有类型概念,一般存json格式的字符串, redis可以存各种类型,并且每种类型提供了一系列操作api\n3.Redis可以持久化")])])]),v._v(" "),i("li",[i("p",[v._v("Redis为什么用skiplist而不用平衡树")]),v._v(" "),i("ul",[i("li",[i("ol",[i("li",[v._v("内存占用小, 比起b树")])])])])])])])]),v._v(" "),i("ol",{attrs:{start:"2"}},[i("li",[v._v("范围查找快")]),v._v(" "),i("li",[v._v("易于实现")])]),v._v(" "),i("h3",{attrs:{id:"mysql"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[v._v("#")]),v._v(" Mysql")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("结构")])]),v._v(" "),i("li",[i("p",[v._v("事务隔离级别")])]),v._v(" "),i("li",[i("p",[v._v("锁")])]),v._v(" "),i("li",[i("p",[v._v("索引的数据结构")])]),v._v(" "),i("li",[i("p",[v._v("聚簇索引和非聚簇索引")])]),v._v(" "),i("li",[i("p",[v._v("最左匹配原则")])]),v._v(" "),i("li",[i("p",[v._v("查询优化（explain等命令）")])]),v._v(" "),i("li",[i("p",[v._v("常见问题")]),v._v(" "),i("ul",[i("li",[v._v("死磕mysql，从数据类型，引擎，索引，事务隔离级别怼到主从复制，读写分离")]),v._v(" "),i("li",[v._v("Mysql(innondb 下同) 有哪几种事务隔离级别？")]),v._v(" "),i("li",[v._v("不同事务隔离级别分别会加哪些锁？")]),v._v(" "),i("li",[v._v("mysql的行锁、表锁、间隙锁、意向锁分别是做什么的？")]),v._v(" "),i("li",[v._v("说说什么是最左匹配？")]),v._v(" "),i("li",[v._v("如何优化慢查询？")]),v._v(" "),i("li",[v._v("mysql索引为什么用的是b+ tree而不是b tree、红黑树")]),v._v(" "),i("li",[v._v("分库分表如何选择分表键")]),v._v(" "),i("li",[v._v("分库分表的情况下，查询时一般是如何做排序的？")])])])]),v._v(" "),i("h3",{attrs:{id:"zookeeper"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper"}},[v._v("#")]),v._v(" zookeeper")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("zk大致原理（可以了解下原理相近的Raft算法）")])]),v._v(" "),i("li",[i("p",[v._v("zk实现分布式锁")])]),v._v(" "),i("li",[i("p",[v._v("zk做集群master选举")])]),v._v(" "),i("li",[i("p",[v._v("常见问题")]),v._v(" "),i("ul",[i("li",[v._v("如何用zk实现分布式锁，与redis分布式锁有和优缺点")])])])]),v._v(" "),i("h3",{attrs:{id:"hbase-如简历有写"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#hbase-如简历有写"}},[v._v("#")]),v._v(" HBase（如简历有写）")]),v._v(" "),i("ul",[i("li",[v._v("HBase适用的场景")]),v._v(" "),i("li",[v._v("架构")]),v._v(" "),i("li",[v._v("merge和split")]),v._v(" "),i("li",[v._v("查写数据的流程")])]),v._v(" "),i("h3",{attrs:{id:"storm-如简历有写"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#storm-如简历有写"}},[v._v("#")]),v._v(" Storm（如简历有写）")]),v._v(" "),i("ul",[i("li",[v._v("Storm与Map Reduce、Spark、Flink的比较")]),v._v(" "),i("li",[v._v("Storm高可用")]),v._v(" "),i("li",[v._v("消息ack机制")])]),v._v(" "),i("h2",{attrs:{id:"理论"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#理论"}},[v._v("#")]),v._v(" 理论")]),v._v(" "),i("h3",{attrs:{id:"算法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[v._v("#")]),v._v(" 算法")]),v._v(" "),i("p",[v._v("算法的话不是所有公司都会问，但最好还是准备下，主要是靠刷题，在leetcode上刷个100-200道easy和medium的题，然后对应公司的面经多看看，问题应该不大。")]),v._v(" "),i("h3",{attrs:{id:"数据结构"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[v._v("#")]),v._v(" 数据结构")]),v._v(" "),i("h3",{attrs:{id:"设计模式"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[v._v("#")]),v._v(" 设计模式")]),v._v(" "),i("h3",{attrs:{id:"分布式理论"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#分布式理论"}},[v._v("#")]),v._v(" 分布式理论")]),v._v(" "),i("h2",{attrs:{id:"项目"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#项目"}},[v._v("#")]),v._v(" 项目")]),v._v(" "),i("h2",{attrs:{id:"网络"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#网络"}},[v._v("#")]),v._v(" 网络")]),v._v(" "),i("p",[i("em",[v._v("XMind - Trial Version")])])])}),[],!1,null,null,null);_.default=a.exports}}]);