(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{402:function(a,t,s){"use strict";s.r(t);var r=s(45),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"rocketmq"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq"}},[a._v("#")]),a._v(" RocketMQ")]),a._v(" "),s("p",[a._v("RocketMQ是一个纯Java、分布式、队列模型的开源消息中间件，前身是MetaQ，是阿里参考Kafka特点研发的一个队列模型的消息中间件，后开源给apache基金会成为了apache的顶级开源项目，具有高性能、高可靠、高实时、分布式特点。")]),a._v(" "),s("h4",{attrs:{id:"重要概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重要概念"}},[a._v("#")]),a._v(" 重要概念")]),a._v(" "),s("ul",[s("li",[a._v("NameServer\n"),s("ul",[s("li",[a._v("是消息队列的协调者，Broker向它注册路由信息，Client向其获取路由信息，类似zookeeper")]),a._v(" "),s("li",[a._v("NameServer本身是没有状态的，可以横向扩展多台，Broker会和每一台NameServer建立长连接")])])]),a._v(" "),s("li",[a._v("Broker\n"),s("ul",[s("li",[a._v("Broker是RocketMQ的核心，提供了消息的接收，存储，拉取等功能，一般要保证Broker高可用，所以配置Broker Slave，当Master挂掉之后，Consumer可以消费Slave")]),a._v(" "),s("li",[a._v("一主多从, 通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave")])])]),a._v(" "),s("li",[a._v("producer 生产者\n"),s("ul",[s("li",[a._v("从NS获取topic路由信息, 与对应的broker master建立连接, 发送消息至broker")]),a._v(" "),s("li",[a._v("提供了三种发送方式: 同步, 异步, 单向")])])]),a._v(" "),s("li",[a._v("consumer 消费者\n"),s("ul",[s("li",[a._v("从NS获取topic路由信息, 与对应broker master/slave建立连接")]),a._v(" "),s("li",[a._v("支持推+拉模式消费")])])]),a._v(" "),s("li",[s("strong",[a._v("集群消费")]),a._v(": 一个消费者group消费一个主题的多个队列, 一个队列只会被一个消费者消费")]),a._v(" "),s("li",[s("strong",[a._v("广播消费")]),a._v(": 消费group中每个消费者都能够消费到")])]),a._v(" "),s("h4",{attrs:{id:"消息领域模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息领域模型"}},[a._v("#")]),a._v(" 消息领域模型")]),a._v(" "),s("ul",[s("li",[a._v("message: 消息, 每条消息必须指定topic, 选填tag")]),a._v(" "),s("li",[a._v("topic: 主题, 消息的第一级归类")]),a._v(" "),s("li",[a._v("tag: 标签, 可以看做子主题, 消息的 第二级归类")]),a._v(" "),s("li",[a._v("group: 分组, 分为consumer group, producer group, 以分组的形式生产/消费消息")]),a._v(" "),s("li",[a._v("queue: 队列, 内部有序, 分为读和写队列")]),a._v(" "),s("li",[a._v("message queue:")]),a._v(" "),s("li",[a._v("offset: 偏移量, 用来访问指定位置的消息")])]),a._v(" "),s("h4",{attrs:{id:"消息确认与刷盘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息确认与刷盘"}},[a._v("#")]),a._v(" 消息确认与刷盘")]),a._v(" "),s("p",[a._v("消息收到以后, RocketMQ会返回一个CONSUME_SUCCESS成功标志, 同时还需要对消息进行存储")]),a._v(" "),s("ol",[s("li",[a._v("同步刷盘: 使用NIO的MappedByteBuffer.force()将映射区数据写入磁盘, 超时会FLUSH_DISK_TIMEOUT")]),a._v(" "),s("li",[a._v("异步刷盘: 将消息写入 CommitLog 映射区后就完成;")])]),a._v(" "),s("h4",{attrs:{id:"顺序消息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#顺序消息"}},[a._v("#")]),a._v(" 顺序消息")]),a._v(" "),s("h4",{attrs:{id:"分布式事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[a._v("#")]),a._v(" 分布式事务")]),a._v(" "),s("h4",{attrs:{id:"half-message-半消息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#half-message-半消息"}},[a._v("#")]),a._v(" Half Message 半消息")]),a._v(" "),s("p",[a._v("已经由生产者投递至broker, 但是暂时不能被消费的消息; 需要生产者对消息二次确认提交后, 才允许消费; 也有可能不提交, 直接回滚了")]),a._v(" "),s("h4",{attrs:{id:"消息回查"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息回查"}},[a._v("#")]),a._v(" 消息回查")]),a._v(" "),s("ul",[s("li",[a._v("场景: 由于网络, 节点故障等原因, 生产者一直没有对半消息进行确认;")]),a._v(" "),s("li",[a._v("broker的定时任务扫描到超时半消息, 主送询问生产者该消息的最终状态(commit / rollback)")])]),a._v(" "),s("div",{staticClass:"language-properties line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-properties"}},[s("code",[s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("A服务先发送个Half Message给broker端，消息中携带 B服务 即将要+100元的信息。")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("当A服务知道Half Message发送成功后，那么开始第3步执行本地事务。")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("执行本地事务(会有三种情况1、执行成功。2、执行失败。3、网络等原因导致没有响应)。")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("如果本地事务成功，那么Product向broker发送Commit,这样B服务就可以消费该message。")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("果本地事务失败，那么Product向broker发送Rollback,直接删除上面这条半消息。")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("6")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("如果因为网络等原因迟迟没有返回失败还是成功，那么会执行RocketMQ的回调接口,来进行事务的回查。")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[a._v("根据回查的结果，对该消息commit/rollback。")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("h4",{attrs:{id:"定时消息-延时消息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定时消息-延时消息"}},[a._v("#")]),a._v(" 定时消息/延时消息")]),a._v(" "),s("p",[a._v("支持, 但不是任意精度: 5s, 10s, 1m等")]),a._v(" "),s("h4",{attrs:{id:"消息过滤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息过滤"}},[a._v("#")]),a._v(" 消息过滤")]),a._v(" "),s("p",[a._v("broker消息过滤: 减少消息到consumer, 但是家中broker负担")]),a._v(" "),s("p",[a._v("consumer端消息过滤: 可定制化更好, consumer的消耗消息变多")]),a._v(" "),s("h4",{attrs:{id:"消息堆积"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息堆积"}},[a._v("#")]),a._v(" 消息堆积")]),a._v(" "),s("ol",[s("li",[a._v("堆积在内存")]),a._v(" "),s("li",[a._v("在磁盘")])]),a._v(" "),s("h4",{attrs:{id:"批量消息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#批量消息"}},[a._v("#")]),a._v(" 批量消息")]),a._v(" "),s("p",[a._v("等待批量消息一次性发送减少网络IO")]),a._v(" "),s("ol",[s("li",[a._v("只允许相同的topic和相同的waitStoreMsgOK")]),a._v(" "),s("li",[a._v("总大小不超过1M")])])])}),[],!1,null,null,null);t.default=e.exports}}]);