(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{416:function(_,v,e){"use strict";e.r(v);var t=e(45),r=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"分布式锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[_._v("#")]),_._v(" 分布式锁")]),_._v(" "),e("p",[_._v("分布式锁用于什么场景?")]),_._v(" "),e("p",[_._v("多机操作同一目标资源")]),_._v(" "),e("h3",{attrs:{id:"redis锁实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis锁实现"}},[_._v("#")]),_._v(" redis锁实现")]),_._v(" "),e("ul",[e("li",[_._v("推荐直接参考 Redisson 的实现就好了, "),e("font",{attrs:{color:"red"}},[_._v("Redission还提供可重入锁, 读写锁, 乐观锁, 公平锁, Redlock")])],1)]),_._v(" "),e("h4",{attrs:{id:"redis分布式锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁"}},[_._v("#")]),_._v(" Redis分布式锁")]),_._v(" "),e("p",[_._v("锁过程要点如下")]),_._v(" "),e("ol",[e("li",[e("strong",[_._v("加锁")]),_._v(": SET lock_key $unique_id EX $expire_time NX\n"),e("ul",[e("li",[_._v("最初版: setnx 命令抢占锁 (SET if Not Exist) , 此时目标key (此处为lock_key) 作为锁")]),_._v(" "),e("li",[e("font",{attrs:{color:"red"}},[_._v("解决死锁问题")]),_._v(": 设置EX超时时间, 避免占锁线程挂掉, 导致的死锁")],1)])]),_._v(" "),e("li",[e("strong",[_._v("释放锁")]),_._v(":\n"),e("ul",[e("li",[e("font",{attrs:{color:"red"}},[_._v("解决释放别人的锁的问题")]),_._v(": key中的value还没用到, 设置为UUID吧! 先 GET 判断锁是否归属自己, 再决定是否 DEL 释放锁, 整个过程为了"),e("strong",[_._v("保证原子性, 使用Lua脚本")])],1)])]),_._v(" "),e("li",[e("strong",[_._v("锁续期")]),_._v(" :\n"),e("ul",[e("li",[e("font",{attrs:{color:"red"}},[_._v("解决锁过期时间不好评估的问题")]),_._v(": 如果占锁线程正常, 定时对锁续期")],1)])]),_._v(" "),e("li",[_._v("仍然存在的"),e("strong",[_._v("问题")]),_._v(": redis主从集群下, 数据不同步导致锁失效\n"),e("ul",[e("li",[_._v("主机设置完锁后还未同步到从机就宕机了, 此时新主机根本没有上锁")])])])]),_._v(" "),e("h4",{attrs:{id:"redlock"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redlock"}},[_._v("#")]),_._v(" Redlock")]),_._v(" "),e("p",[_._v("至少要部署 5 个 Redis 实例, 而且都是主库, 它们之间没有任何关系")]),_._v(" "),e("ol",[e("li",[_._v("客户端先获取"),e("font",{attrs:{color:"red"}},[_._v("「当前时间戳T1」")])],1),_._v(" "),e("li",[_._v("客户端依次"),e("font",{attrs:{color:"red"}},[_._v("向这 5 个 Redis 实例发起加锁请求")]),_._v(" (用前面讲到的 SET 命令)\n"),e("ul",[e("li",[_._v("且每个请求会设置超时时间 (毫秒级, 要远小于锁的有效时间)")]),_._v(" "),e("li",[_._v("如果某一个实例加锁失败 (包括网络超时、锁被其它人持有等各种异常情况) , 就立即向下一个 Redis 实例申请加锁")])])],1),_._v(" "),e("li",[_._v("如果客户端"),e("font",{attrs:{color:"red"}},[_._v("在 >=3 个 Redis 实例加锁成功")]),_._v(" (大多数加锁成功) , 则\n"),e("ol",[e("li",[_._v("再次获取「当前时间戳T2」")]),_._v(" "),e("li",[_._v("判断 T2 - T1 < 锁的过期时间, 如果还未超过过期(有效)时间, 则加锁成功, 否则加锁失败 (因为加锁过程需要一段时间, 如果直接超过了锁的有效时间, 则视为失败)")])])],1),_._v(" "),e("li",[_._v("加锁成功, 去操作共享资源")]),_._v(" "),e("li",[_._v("加锁失败, 向「全部节点」发起释放锁请求 (前面讲到的 Lua 脚本释放锁)")])]),_._v(" "),e("h5",{attrs:{id:"特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[_._v("#")]),_._v(" 特点")]),_._v(" "),e("ol",[e("li",[_._v("多个实例加锁: 容错, 部分机器宕机依旧可用")])]),_._v(" "),e("h5",{attrs:{id:"分布式问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式问题"}},[_._v("#")]),_._v(" 分布式问题")]),_._v(" "),e("p",[_._v("N P C: Net Delay网络延迟; Process Pause进程暂停(GC); Clock Drift时钟漂移")]),_._v(" "),e("h4",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),e("ol",[e("li",[_._v("所以，我对 Redlock 的个人看法是，尽量不用它，而且它的性能不如单机版 Redis，部署成本也高，我还是会优先考虑使用主从+ 哨兵的模式 实现分布式锁。")]),_._v(" "),e("li",[_._v("使用分布式锁，在上层完成「互斥」目的，虽然极端情况下锁会失效，但它可以最大程度把并发请求阻挡在最上层，减轻操作资源层的压力。")]),_._v(" "),e("li",[_._v("但对于要求数据绝对正确的业务，在资源层一定要做好「兜底」，设计思路可以借鉴 fecing token 的方案来做。")])]),_._v(" "),e("p",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/s8xjm1ZCKIoTGT3DCVA4aw",target:"_blank",rel:"noopener noreferrer"}},[_._v("深度剖析：Redis分布式锁到底安全吗？"),e("OutboundLink")],1)]),_._v(" "),e("h4",{attrs:{id:"fecing-token-的方案-保证正确性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fecing-token-的方案-保证正确性"}},[_._v("#")]),_._v(" fecing token 的方案，保证正确性")]),_._v(" "),e("p",[_._v("fecing token 方案保证分布式锁的正确性。")]),_._v(" "),e("p",[_._v("这个模型流程如下：")]),_._v(" "),e("ol",[e("li",[_._v("客户端在获取锁时，锁服务可以提供一个「递增」的 token")]),_._v(" "),e("li",[_._v("客户端拿着这个 token 去操作共享资源")]),_._v(" "),e("li",[_._v("共享资源可以根据 token 拒绝「后来者」的请求 (资源执行的token已经到了34, 那么33就不允许执行)")])]),_._v(" "),e("p",[e("a",{attrs:{href:"https://mmbiz.qpic.cn/mmbiz_png/gB9Yvac5K3N9hGL63cpMX4cTuPjx5Y0lP2fUL2pWuJStiarHJo13HuCpvKhicRb7knu5Jh71bYubribdSaqm1oolw/640",target:"_blank",rel:"noopener noreferrer"}},[_._v("fencing token模型"),e("OutboundLink")],1)]),_._v(" "),e("h3",{attrs:{id:"zookeeper锁实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper锁实现"}},[_._v("#")]),_._v(" zookeeper锁实现")]),_._v(" "),e("p",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/73807097",target:"_blank",rel:"noopener noreferrer"}},[_._v("分布式锁用Redis还是Zookeeper？"),e("OutboundLink")],1)]),_._v(" "),e("ol",[e("li",[_._v("客户端 1 和 2 都尝试创建「临时节点」，例如 /lock")]),_._v(" "),e("li",[_._v("假设客户端 1 先到达，则加锁成功，客户端 2 加锁失败")]),_._v(" "),e("li",[_._v("客户端 1 操作共享资源")]),_._v(" "),e("li",[_._v("客户端 1 删除 /lock 节点，释放锁")])]),_._v(" "),e("p",[_._v("如果客户端 1 异常崩溃了，那么这个临时节点会自动删除，保证了锁一定会被释放。")]),_._v(" "),e("p",[_._v("客户端 1 此时会与 Zookeeper 服务器维护一个 Session，这个 Session 会依赖客户端「定时心跳」来维持连接。")]),_._v(" "),e("h4",{attrs:{id:"watch机制锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch机制锁"}},[_._v("#")]),_._v(" watch机制锁")]),_._v(" "),e("p",[_._v("zk基础知识, znode特性:")]),_._v(" "),e("ol",[e("li",[e("strong",[_._v("有序节点")]),_._v(": 创建 "),e("code",[_._v("/lock/node-")]),_._v(" 子节点时指明有序, 那么实际会顺序生成 "),e("code",[_._v("/lock/node-0000000000")])]),_._v(" "),e("li",[e("strong",[_._v("临时节点")]),_._v(": 建立的临时节点, 在会话结束或者会话超时后, 会被  自动删除")]),_._v(" "),e("li",[e("strong",[_._v("事件监听")]),_._v(": 对节点设置事件监听, 当节点数据或结构变化时, zk会通知客户端")])]),_._v(" "),e("p",[_._v("zk分布式锁实现:")]),_._v(" "),e("ol",[e("li",[_._v("在 "),e("code",[_._v("/lock/")]),_._v(" 下"),e("font",{attrs:{color:"0099FF"}},[_._v("创建临时+有序节点")])],1),_._v(" "),e("li",[_._v("获取 "),e("code",[_._v("/lock/")]),_._v(" 下所有节点, 判断当前创建的"),e("font",{attrs:{color:"0099FF"}},[_._v("节点序号 是否最小")]),_._v(" "),e("ul",[e("li",[_._v("如果最小, 认为获取成功")]),_._v(" "),e("li",[_._v("如果不是最小, 则"),e("font",{attrs:{color:"0099FF"}},[_._v("对前一个节点添加事件监听")])],1)])],1),_._v(" "),e("li",[_._v("释放锁就是将持有的临时节点删除, 于是就可以顺序触发下个节点的事件(锁获取成功)")])]),_._v(" "),e("p",[_._v("代码实现参考 Curator")]),_._v(" "),e("h4",{attrs:{id:"zookeeper-和-redis-锁的优劣总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper-和-redis-锁的优劣总结"}},[_._v("#")]),_._v(" Zookeeper 和 redis 锁的优劣总结：")]),_._v(" "),e("ol",[e("li",[_._v("获取锁的方式\n"),e("ol",[e("li",[_._v("redis获取失败, 需要重试获取, 而zk加锁失败只需要加上监听器进行watch, 不用一直轮询")]),_._v(" "),e("li",[_._v("但是监听器过多会导致zk集群压力较大")]),_._v(" "),e("li",[_._v("zk不需要考虑过期时间")])])]),_._v(" "),e("li",[_._v("数据一致性\n"),e("ol",[e("li",[_._v("redis不是强一致性, 主机宕机会导致锁失效")]),_._v(" "),e("li",[_._v("zk强一致性, 允许宕机的数量更多, 可靠性更高")])])]),_._v(" "),e("li",[_._v("在架构本身有redis的情况下, 是否引入zk模块 (增加系统复杂性, 成本)")]),_._v(" "),e("li",[_._v("性能: 显然redis吞吐量更高")])])])}),[],!1,null,null,null);v.default=r.exports}}]);